var q_ = Object.defineProperty; var Z_ = (t, e, n) => e in t ? q_(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n; var F = (t, e, n) => (Z_(t, typeof e != "symbol" ? e + "" : e, n), n); function J_(t, e) { for (var n = 0; n < e.length; n++) { const i = e[n]; if (typeof i != "string" && !Array.isArray(i)) { for (const r in i) if (r !== "default" && !(r in t)) { const s = Object.getOwnPropertyDescriptor(i, r); s && Object.defineProperty(t, r, s.get ? s : { enumerable: !0, get: () => i[r] }) } } } return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" })) } (function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r); new MutationObserver(r => { for (const s of r) if (s.type === "childList") for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && i(o) }).observe(document, { childList: !0, subtree: !0 }); function n(r) { const s = {}; return r.integrity && (s.integrity = r.integrity), r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? s.credentials = "include" : r.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s } function i(r) { if (r.ep) return; r.ep = !0; const s = n(r); fetch(r.href, s) } })(); var ha = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function e2(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } function t2(t) { if (t.__esModule) return t; var e = t.default; if (typeof e == "function") { var n = function i() { if (this instanceof i) { var r = [null]; r.push.apply(r, arguments); var s = Function.bind.apply(e, r); return new s } return e.apply(this, arguments) }; n.prototype = e.prototype } else n = {}; return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(t).forEach(function (i) { var r = Object.getOwnPropertyDescriptor(t, i); Object.defineProperty(n, i, r.get ? r : { enumerable: !0, get: function () { return t[i] } }) }), n } var w = {}, n2 = { get exports() { return w }, set exports(t) { w = t } }, yc = {}, M = {}, i2 = { get exports() { return M }, set exports(t) { M = t } }, ie = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Ho = Symbol.for("react.element"), r2 = Symbol.for("react.portal"), s2 = Symbol.for("react.fragment"), o2 = Symbol.for("react.strict_mode"), a2 = Symbol.for("react.profiler"), l2 = Symbol.for("react.provider"), c2 = Symbol.for("react.context"), u2 = Symbol.for("react.forward_ref"), d2 = Symbol.for("react.suspense"), f2 = Symbol.for("react.memo"), h2 = Symbol.for("react.lazy"), Qp = Symbol.iterator; function p2(t) { return t === null || typeof t != "object" ? null : (t = Qp && t[Qp] || t["@@iterator"], typeof t == "function" ? t : null) } var bv = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, _v = Object.assign, Sv = {}; function rs(t, e, n) { this.props = t, this.context = e, this.refs = Sv, this.updater = n || bv } rs.prototype.isReactComponent = {}; rs.prototype.setState = function (t, e) { if (typeof t != "object" && typeof t != "function" && t != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, t, e, "setState") }; rs.prototype.forceUpdate = function (t) { this.updater.enqueueForceUpdate(this, t, "forceUpdate") }; function kv() { } kv.prototype = rs.prototype; function th(t, e, n) { this.props = t, this.context = e, this.refs = Sv, this.updater = n || bv } var nh = th.prototype = new kv; nh.constructor = th; _v(nh, rs.prototype); nh.isPureReactComponent = !0; var qp = Array.isArray, Pv = Object.prototype.hasOwnProperty, ih = { current: null }, Cv = { key: !0, ref: !0, __self: !0, __source: !0 }; function Mv(t, e, n) { var i, r = {}, s = null, o = null; if (e != null) for (i in e.ref !== void 0 && (o = e.ref), e.key !== void 0 && (s = "" + e.key), e) Pv.call(e, i) && !Cv.hasOwnProperty(i) && (r[i] = e[i]); var a = arguments.length - 2; if (a === 1) r.children = n; else if (1 < a) { for (var l = Array(a), c = 0; c < a; c++)l[c] = arguments[c + 2]; r.children = l } if (t && t.defaultProps) for (i in a = t.defaultProps, a) r[i] === void 0 && (r[i] = a[i]); return { $$typeof: Ho, type: t, key: s, ref: o, props: r, _owner: ih.current } } function m2(t, e) { return { $$typeof: Ho, type: t.type, key: e, ref: t.ref, props: t.props, _owner: t._owner } } function rh(t) { return typeof t == "object" && t !== null && t.$$typeof === Ho } function g2(t) { var e = { "=": "=0", ":": "=2" }; return "$" + t.replace(/[=:]/g, function (n) { return e[n] }) } var Zp = /\/+/g; function cu(t, e) { return typeof t == "object" && t !== null && t.key != null ? g2("" + t.key) : e.toString(36) } function sl(t, e, n, i, r) { var s = typeof t; (s === "undefined" || s === "boolean") && (t = null); var o = !1; if (t === null) o = !0; else switch (s) { case "string": case "number": o = !0; break; case "object": switch (t.$$typeof) { case Ho: case r2: o = !0 } }if (o) return o = t, r = r(o), t = i === "" ? "." + cu(o, 0) : i, qp(r) ? (n = "", t != null && (n = t.replace(Zp, "$&/") + "/"), sl(r, e, n, "", function (c) { return c })) : r != null && (rh(r) && (r = m2(r, n + (!r.key || o && o.key === r.key ? "" : ("" + r.key).replace(Zp, "$&/") + "/") + t)), e.push(r)), 1; if (o = 0, i = i === "" ? "." : i + ":", qp(t)) for (var a = 0; a < t.length; a++) { s = t[a]; var l = i + cu(s, a); o += sl(s, e, n, l, r) } else if (l = p2(t), typeof l == "function") for (t = l.call(t), a = 0; !(s = t.next()).done;)s = s.value, l = i + cu(s, a++), o += sl(s, e, n, l, r); else if (s === "object") throw e = String(t), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead."); return o } function pa(t, e, n) { if (t == null) return t; var i = [], r = 0; return sl(t, i, "", "", function (s) { return e.call(n, s, r++) }), i } function y2(t) { if (t._status === -1) { var e = t._result; e = e(), e.then(function (n) { (t._status === 0 || t._status === -1) && (t._status = 1, t._result = n) }, function (n) { (t._status === 0 || t._status === -1) && (t._status = 2, t._result = n) }), t._status === -1 && (t._status = 0, t._result = e) } if (t._status === 1) return t._result.default; throw t._result } var ht = { current: null }, ol = { transition: null }, v2 = { ReactCurrentDispatcher: ht, ReactCurrentBatchConfig: ol, ReactCurrentOwner: ih }; ie.Children = { map: pa, forEach: function (t, e, n) { pa(t, function () { e.apply(this, arguments) }, n) }, count: function (t) { var e = 0; return pa(t, function () { e++ }), e }, toArray: function (t) { return pa(t, function (e) { return e }) || [] }, only: function (t) { if (!rh(t)) throw Error("React.Children.only expected to receive a single React element child."); return t } }; ie.Component = rs; ie.Fragment = s2; ie.Profiler = a2; ie.PureComponent = th; ie.StrictMode = o2; ie.Suspense = d2; ie.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = v2; ie.cloneElement = function (t, e, n) { if (t == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + "."); var i = _v({}, t.props), r = t.key, s = t.ref, o = t._owner; if (e != null) { if (e.ref !== void 0 && (s = e.ref, o = ih.current), e.key !== void 0 && (r = "" + e.key), t.type && t.type.defaultProps) var a = t.type.defaultProps; for (l in e) Pv.call(e, l) && !Cv.hasOwnProperty(l) && (i[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l]) } var l = arguments.length - 2; if (l === 1) i.children = n; else if (1 < l) { a = Array(l); for (var c = 0; c < l; c++)a[c] = arguments[c + 2]; i.children = a } return { $$typeof: Ho, type: t.type, key: r, ref: s, props: i, _owner: o } }; ie.createContext = function (t) { return t = { $$typeof: c2, _currentValue: t, _currentValue2: t, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, t.Provider = { $$typeof: l2, _context: t }, t.Consumer = t }; ie.createElement = Mv; ie.createFactory = function (t) { var e = Mv.bind(null, t); return e.type = t, e }; ie.createRef = function () { return { current: null } }; ie.forwardRef = function (t) { return { $$typeof: u2, render: t } }; ie.isValidElement = rh; ie.lazy = function (t) { return { $$typeof: h2, _payload: { _status: -1, _result: t }, _init: y2 } }; ie.memo = function (t, e) { return { $$typeof: f2, type: t, compare: e === void 0 ? null : e } }; ie.startTransition = function (t) { var e = ol.transition; ol.transition = {}; try { t() } finally { ol.transition = e } }; ie.unstable_act = function () { throw Error("act(...) is not supported in production builds of React.") }; ie.useCallback = function (t, e) { return ht.current.useCallback(t, e) }; ie.useContext = function (t) { return ht.current.useContext(t) }; ie.useDebugValue = function () { }; ie.useDeferredValue = function (t) { return ht.current.useDeferredValue(t) }; ie.useEffect = function (t, e) { return ht.current.useEffect(t, e) }; ie.useId = function () { return ht.current.useId() }; ie.useImperativeHandle = function (t, e, n) { return ht.current.useImperativeHandle(t, e, n) }; ie.useInsertionEffect = function (t, e) { return ht.current.useInsertionEffect(t, e) }; ie.useLayoutEffect = function (t, e) { return ht.current.useLayoutEffect(t, e) }; ie.useMemo = function (t, e) { return ht.current.useMemo(t, e) }; ie.useReducer = function (t, e, n) { return ht.current.useReducer(t, e, n) }; ie.useRef = function (t) { return ht.current.useRef(t) }; ie.useState = function (t) { return ht.current.useState(t) }; ie.useSyncExternalStore = function (t, e, n) { return ht.current.useSyncExternalStore(t, e, n) }; ie.useTransition = function () { return ht.current.useTransition() }; ie.version = "18.2.0"; (function (t) { t.exports = ie })(i2); const Et = e2(M), md = J_({ __proto__: null, default: Et }, [M]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var x2 = M, w2 = Symbol.for("react.element"), b2 = Symbol.for("react.fragment"), _2 = Object.prototype.hasOwnProperty, S2 = x2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, k2 = { key: !0, ref: !0, __self: !0, __source: !0 }; function Tv(t, e, n) { var i, r = {}, s = null, o = null; n !== void 0 && (s = "" + n), e.key !== void 0 && (s = "" + e.key), e.ref !== void 0 && (o = e.ref); for (i in e) _2.call(e, i) && !k2.hasOwnProperty(i) && (r[i] = e[i]); if (t && t.defaultProps) for (i in e = t.defaultProps, e) r[i] === void 0 && (r[i] = e[i]); return { $$typeof: w2, type: t, key: s, ref: o, props: r, _owner: S2.current } } yc.Fragment = b2; yc.jsx = Tv; yc.jsxs = Tv; (function (t) { t.exports = yc })(n2); var gd = {}, Pl = {}, P2 = { get exports() { return Pl }, set exports(t) { Pl = t } }, Lt = {}, yd = {}, C2 = { get exports() { return yd }, set exports(t) { yd = t } }, Ev = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (t) { function e(L, j) { var W = L.length; L.push(j); e: for (; 0 < W;) { var Y = W - 1 >>> 1, ae = L[Y]; if (0 < r(ae, j)) L[Y] = j, L[W] = ae, W = Y; else break e } } function n(L) { return L.length === 0 ? null : L[0] } function i(L) { if (L.length === 0) return null; var j = L[0], W = L.pop(); if (W !== j) { L[0] = W; e: for (var Y = 0, ae = L.length, Te = ae >>> 1; Y < Te;) { var je = 2 * (Y + 1) - 1, mt = L[je], $e = je + 1, tn = L[$e]; if (0 > r(mt, W)) $e < ae && 0 > r(tn, mt) ? (L[Y] = tn, L[$e] = W, Y = $e) : (L[Y] = mt, L[je] = W, Y = je); else if ($e < ae && 0 > r(tn, W)) L[Y] = tn, L[$e] = W, Y = $e; else break e } } return j } function r(L, j) { var W = L.sortIndex - j.sortIndex; return W !== 0 ? W : L.id - j.id } if (typeof performance == "object" && typeof performance.now == "function") { var s = performance; t.unstable_now = function () { return s.now() } } else { var o = Date, a = o.now(); t.unstable_now = function () { return o.now() - a } } var l = [], c = [], u = 1, d = null, f = 3, h = !1, m = !1, p = !1, x = typeof setTimeout == "function" ? setTimeout : null, y = typeof clearTimeout == "function" ? clearTimeout : null, g = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function v(L) { for (var j = n(c); j !== null;) { if (j.callback === null) i(c); else if (j.startTime <= L) i(c), j.sortIndex = j.expirationTime, e(l, j); else break; j = n(c) } } function b(L) { if (p = !1, v(L), !m) if (n(l) !== null) m = !0, J(_); else { var j = n(c); j !== null && re(b, j.startTime - L) } } function _(L, j) { m = !1, p && (p = !1, y(P), P = -1), h = !0; var W = f; try { for (v(j), d = n(l); d !== null && (!(d.expirationTime > j) || L && !A());) { var Y = d.callback; if (typeof Y == "function") { d.callback = null, f = d.priorityLevel; var ae = Y(d.expirationTime <= j); j = t.unstable_now(), typeof ae == "function" ? d.callback = ae : d === n(l) && i(l), v(j) } else i(l); d = n(l) } if (d !== null) var Te = !0; else { var je = n(c); je !== null && re(b, je.startTime - j), Te = !1 } return Te } finally { d = null, f = W, h = !1 } } var k = !1, S = null, P = -1, T = 5, D = -1; function A() { return !(t.unstable_now() - D < T) } function V() { if (S !== null) { var L = t.unstable_now(); D = L; var j = !0; try { j = S(!0, L) } finally { j ? q() : (k = !1, S = null) } } else k = !1 } var q; if (typeof g == "function") q = function () { g(V) }; else if (typeof MessageChannel < "u") { var G = new MessageChannel, z = G.port2; G.port1.onmessage = V, q = function () { z.postMessage(null) } } else q = function () { x(V, 0) }; function J(L) { S = L, k || (k = !0, q()) } function re(L, j) { P = x(function () { L(t.unstable_now()) }, j) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (L) { L.callback = null }, t.unstable_continueExecution = function () { m || h || (m = !0, J(_)) }, t.unstable_forceFrameRate = function (L) { 0 > L || 125 < L ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : T = 0 < L ? Math.floor(1e3 / L) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return f }, t.unstable_getFirstCallbackNode = function () { return n(l) }, t.unstable_next = function (L) { switch (f) { case 1: case 2: case 3: var j = 3; break; default: j = f }var W = f; f = j; try { return L() } finally { f = W } }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function (L, j) { switch (L) { case 1: case 2: case 3: case 4: case 5: break; default: L = 3 }var W = f; f = L; try { return j() } finally { f = W } }, t.unstable_scheduleCallback = function (L, j, W) { var Y = t.unstable_now(); switch (typeof W == "object" && W !== null ? (W = W.delay, W = typeof W == "number" && 0 < W ? Y + W : Y) : W = Y, L) { case 1: var ae = -1; break; case 2: ae = 250; break; case 5: ae = 1073741823; break; case 4: ae = 1e4; break; default: ae = 5e3 }return ae = W + ae, L = { id: u++, callback: j, priorityLevel: L, startTime: W, expirationTime: ae, sortIndex: -1 }, W > Y ? (L.sortIndex = W, e(c, L), n(l) === null && L === n(c) && (p ? (y(P), P = -1) : p = !0, re(b, W - Y))) : (L.sortIndex = ae, e(l, L), m || h || (m = !0, J(_))), L }, t.unstable_shouldYield = A, t.unstable_wrapCallback = function (L) { var j = f; return function () { var W = f; f = j; try { return L.apply(this, arguments) } finally { f = W } } } })(Ev); (function (t) { t.exports = Ev })(C2);/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Dv = M, Ot = yd; function R(t) { for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1; n < arguments.length; n++)e += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var Ov = new Set, fo = {}; function ur(t, e) { Ur(t, e), Ur(t + "Capture", e) } function Ur(t, e) { for (fo[t] = e, t = 0; t < e.length; t++)Ov.add(e[t]) } var Fn = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), vd = Object.prototype.hasOwnProperty, M2 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Jp = {}, em = {}; function T2(t) { return vd.call(em, t) ? !0 : vd.call(Jp, t) ? !1 : M2.test(t) ? em[t] = !0 : (Jp[t] = !0, !1) } function E2(t, e, n, i) { if (n !== null && n.type === 0) return !1; switch (typeof e) { case "function": case "symbol": return !0; case "boolean": return i ? !1 : n !== null ? !n.acceptsBooleans : (t = t.toLowerCase().slice(0, 5), t !== "data-" && t !== "aria-"); default: return !1 } } function D2(t, e, n, i) { if (e === null || typeof e > "u" || E2(t, e, n, i)) return !0; if (i) return !1; if (n !== null) switch (n.type) { case 3: return !e; case 4: return e === !1; case 5: return isNaN(e); case 6: return isNaN(e) || 1 > e }return !1 } function pt(t, e, n, i, r, s, o) { this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = i, this.attributeNamespace = r, this.mustUseProperty = n, this.propertyName = t, this.type = e, this.sanitizeURL = s, this.removeEmptyString = o } var Ze = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (t) { Ze[t] = new pt(t, 0, !1, t, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (t) { var e = t[0]; Ze[e] = new pt(e, 1, !1, t[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (t) { Ze[t] = new pt(t, 2, !1, t.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (t) { Ze[t] = new pt(t, 2, !1, t, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (t) { Ze[t] = new pt(t, 3, !1, t.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (t) { Ze[t] = new pt(t, 3, !0, t, null, !1, !1) });["capture", "download"].forEach(function (t) { Ze[t] = new pt(t, 4, !1, t, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (t) { Ze[t] = new pt(t, 6, !1, t, null, !1, !1) });["rowSpan", "start"].forEach(function (t) { Ze[t] = new pt(t, 5, !1, t.toLowerCase(), null, !1, !1) }); var sh = /[\-:]([a-z])/g; function oh(t) { return t[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (t) { var e = t.replace(sh, oh); Ze[e] = new pt(e, 1, !1, t, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (t) { var e = t.replace(sh, oh); Ze[e] = new pt(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (t) { var e = t.replace(sh, oh); Ze[e] = new pt(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (t) { Ze[t] = new pt(t, 1, !1, t.toLowerCase(), null, !1, !1) }); Ze.xlinkHref = new pt("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (t) { Ze[t] = new pt(t, 1, !1, t.toLowerCase(), null, !0, !0) }); function ah(t, e, n, i) { var r = Ze.hasOwnProperty(e) ? Ze[e] : null; (r !== null ? r.type !== 0 : i || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (D2(e, n, r, i) && (n = null), i || r === null ? T2(e) && (n === null ? t.removeAttribute(e) : t.setAttribute(e, "" + n)) : r.mustUseProperty ? t[r.propertyName] = n === null ? r.type === 3 ? !1 : "" : n : (e = r.attributeName, i = r.attributeNamespace, n === null ? t.removeAttribute(e) : (r = r.type, n = r === 3 || r === 4 && n === !0 ? "" : "" + n, i ? t.setAttributeNS(i, e, n) : t.setAttribute(e, n)))) } var Bn = Dv.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, ma = Symbol.for("react.element"), wr = Symbol.for("react.portal"), br = Symbol.for("react.fragment"), lh = Symbol.for("react.strict_mode"), xd = Symbol.for("react.profiler"), Rv = Symbol.for("react.provider"), Lv = Symbol.for("react.context"), ch = Symbol.for("react.forward_ref"), wd = Symbol.for("react.suspense"), bd = Symbol.for("react.suspense_list"), uh = Symbol.for("react.memo"), Qn = Symbol.for("react.lazy"), jv = Symbol.for("react.offscreen"), tm = Symbol.iterator; function ds(t) { return t === null || typeof t != "object" ? null : (t = tm && t[tm] || t["@@iterator"], typeof t == "function" ? t : null) } var Me = Object.assign, uu; function Es(t) {
    if (uu === void 0) try { throw Error() } catch (n) { var e = n.stack.trim().match(/\n( *(at )?)/); uu = e && e[1] || "" } return `
`+ uu + t
} var du = !1; function fu(t, e) {
    if (!t || du) return ""; du = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (e) if (e = function () { throw Error() }, Object.defineProperty(e.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(e, []) } catch (c) { var i = c } Reflect.construct(t, [], e) } else { try { e.call() } catch (c) { i = c } t.call(e.prototype) } else { try { throw Error() } catch (c) { i = c } t() } } catch (c) {
        if (c && i && typeof c.stack == "string") {
            for (var r = c.stack.split(`
`), s = i.stack.split(`
`), o = r.length - 1, a = s.length - 1; 1 <= o && 0 <= a && r[o] !== s[a];)a--; for (; 1 <= o && 0 <= a; o--, a--)if (r[o] !== s[a]) {
                if (o !== 1 || a !== 1) do if (o--, a--, 0 > a || r[o] !== s[a]) {
                    var l = `
`+ r[o].replace(" at new ", " at "); return t.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", t.displayName)), l
                } while (1 <= o && 0 <= a); break
            }
        }
    } finally { du = !1, Error.prepareStackTrace = n } return (t = t ? t.displayName || t.name : "") ? Es(t) : ""
} function O2(t) { switch (t.tag) { case 5: return Es(t.type); case 16: return Es("Lazy"); case 13: return Es("Suspense"); case 19: return Es("SuspenseList"); case 0: case 2: case 15: return t = fu(t.type, !1), t; case 11: return t = fu(t.type.render, !1), t; case 1: return t = fu(t.type, !0), t; default: return "" } } function _d(t) { if (t == null) return null; if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t; switch (t) { case br: return "Fragment"; case wr: return "Portal"; case xd: return "Profiler"; case lh: return "StrictMode"; case wd: return "Suspense"; case bd: return "SuspenseList" }if (typeof t == "object") switch (t.$$typeof) { case Lv: return (t.displayName || "Context") + ".Consumer"; case Rv: return (t._context.displayName || "Context") + ".Provider"; case ch: var e = t.render; return t = t.displayName, t || (t = e.displayName || e.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t; case uh: return e = t.displayName || null, e !== null ? e : _d(t.type) || "Memo"; case Qn: e = t._payload, t = t._init; try { return _d(t(e)) } catch { } }return null } function R2(t) { var e = t.type; switch (t.tag) { case 24: return "Cache"; case 9: return (e.displayName || "Context") + ".Consumer"; case 10: return (e._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return t = e.render, t = t.displayName || t.name || "", e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return e; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return _d(e); case 8: return e === lh ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e }return null } function wi(t) { switch (typeof t) { case "boolean": case "number": case "string": case "undefined": return t; case "object": return t; default: return "" } } function Av(t) { var e = t.type; return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio") } function L2(t) { var e = Av(t) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e), i = "" + t[e]; if (!t.hasOwnProperty(e) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") { var r = n.get, s = n.set; return Object.defineProperty(t, e, { configurable: !0, get: function () { return r.call(this) }, set: function (o) { i = "" + o, s.call(this, o) } }), Object.defineProperty(t, e, { enumerable: n.enumerable }), { getValue: function () { return i }, setValue: function (o) { i = "" + o }, stopTracking: function () { t._valueTracker = null, delete t[e] } } } } function ga(t) { t._valueTracker || (t._valueTracker = L2(t)) } function Nv(t) { if (!t) return !1; var e = t._valueTracker; if (!e) return !0; var n = e.getValue(), i = ""; return t && (i = Av(t) ? t.checked ? "true" : "false" : t.value), t = i, t !== n ? (e.setValue(t), !0) : !1 } function Cl(t) { if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u") return null; try { return t.activeElement || t.body } catch { return t.body } } function Sd(t, e) { var n = e.checked; return Me({}, e, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: n ?? t._wrapperState.initialChecked }) } function nm(t, e) { var n = e.defaultValue == null ? "" : e.defaultValue, i = e.checked != null ? e.checked : e.defaultChecked; n = wi(e.value != null ? e.value : n), t._wrapperState = { initialChecked: i, initialValue: n, controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null } } function Fv(t, e) { e = e.checked, e != null && ah(t, "checked", e, !1) } function kd(t, e) { Fv(t, e); var n = wi(e.value), i = e.type; if (n != null) i === "number" ? (n === 0 && t.value === "" || t.value != n) && (t.value = "" + n) : t.value !== "" + n && (t.value = "" + n); else if (i === "submit" || i === "reset") { t.removeAttribute("value"); return } e.hasOwnProperty("value") ? Pd(t, e.type, n) : e.hasOwnProperty("defaultValue") && Pd(t, e.type, wi(e.defaultValue)), e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked) } function im(t, e, n) { if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) { var i = e.type; if (!(i !== "submit" && i !== "reset" || e.value !== void 0 && e.value !== null)) return; e = "" + t._wrapperState.initialValue, n || e === t.value || (t.value = e), t.defaultValue = e } n = t.name, n !== "" && (t.name = ""), t.defaultChecked = !!t._wrapperState.initialChecked, n !== "" && (t.name = n) } function Pd(t, e, n) { (e !== "number" || Cl(t.ownerDocument) !== t) && (n == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + n && (t.defaultValue = "" + n)) } var Ds = Array.isArray; function Fr(t, e, n, i) { if (t = t.options, e) { e = {}; for (var r = 0; r < n.length; r++)e["$" + n[r]] = !0; for (n = 0; n < t.length; n++)r = e.hasOwnProperty("$" + t[n].value), t[n].selected !== r && (t[n].selected = r), r && i && (t[n].defaultSelected = !0) } else { for (n = "" + wi(n), e = null, r = 0; r < t.length; r++) { if (t[r].value === n) { t[r].selected = !0, i && (t[r].defaultSelected = !0); return } e !== null || t[r].disabled || (e = t[r]) } e !== null && (e.selected = !0) } } function Cd(t, e) { if (e.dangerouslySetInnerHTML != null) throw Error(R(91)); return Me({}, e, { value: void 0, defaultValue: void 0, children: "" + t._wrapperState.initialValue }) } function rm(t, e) { var n = e.value; if (n == null) { if (n = e.children, e = e.defaultValue, n != null) { if (e != null) throw Error(R(92)); if (Ds(n)) { if (1 < n.length) throw Error(R(93)); n = n[0] } e = n } e == null && (e = ""), n = e } t._wrapperState = { initialValue: wi(n) } } function Iv(t, e) { var n = wi(e.value), i = wi(e.defaultValue); n != null && (n = "" + n, n !== t.value && (t.value = n), e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)), i != null && (t.defaultValue = "" + i) } function sm(t) { var e = t.textContent; e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e) } function Vv(t) { switch (t) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function Md(t, e) { return t == null || t === "http://www.w3.org/1999/xhtml" ? Vv(e) : t === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t } var ya, zv = function (t) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (e, n, i, r) { MSApp.execUnsafeLocalFunction(function () { return t(e, n, i, r) }) } : t }(function (t, e) { if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t) t.innerHTML = e; else { for (ya = ya || document.createElement("div"), ya.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = ya.firstChild; t.firstChild;)t.removeChild(t.firstChild); for (; e.firstChild;)t.appendChild(e.firstChild) } }); function ho(t, e) { if (e) { var n = t.firstChild; if (n && n === t.lastChild && n.nodeType === 3) { n.nodeValue = e; return } } t.textContent = e } var Is = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, j2 = ["Webkit", "ms", "Moz", "O"]; Object.keys(Is).forEach(function (t) { j2.forEach(function (e) { e = e + t.charAt(0).toUpperCase() + t.substring(1), Is[e] = Is[t] }) }); function Bv(t, e, n) { return e == null || typeof e == "boolean" || e === "" ? "" : n || typeof e != "number" || e === 0 || Is.hasOwnProperty(t) && Is[t] ? ("" + e).trim() : e + "px" } function Hv(t, e) { t = t.style; for (var n in e) if (e.hasOwnProperty(n)) { var i = n.indexOf("--") === 0, r = Bv(n, e[n], i); n === "float" && (n = "cssFloat"), i ? t.setProperty(n, r) : t[n] = r } } var A2 = Me({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function Td(t, e) { if (e) { if (A2[t] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(R(137, t)); if (e.dangerouslySetInnerHTML != null) { if (e.children != null) throw Error(R(60)); if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML)) throw Error(R(61)) } if (e.style != null && typeof e.style != "object") throw Error(R(62)) } } function Ed(t, e) { if (t.indexOf("-") === -1) return typeof e.is == "string"; switch (t) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var Dd = null; function dh(t) { return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t } var Od = null, Ir = null, Vr = null; function om(t) { if (t = Uo(t)) { if (typeof Od != "function") throw Error(R(280)); var e = t.stateNode; e && (e = _c(e), Od(t.stateNode, t.type, e)) } } function Wv(t) { Ir ? Vr ? Vr.push(t) : Vr = [t] : Ir = t } function $v() { if (Ir) { var t = Ir, e = Vr; if (Vr = Ir = null, om(t), e) for (t = 0; t < e.length; t++)om(e[t]) } } function Uv(t, e) { return t(e) } function Yv() { } var hu = !1; function Kv(t, e, n) { if (hu) return t(e, n); hu = !0; try { return Uv(t, e, n) } finally { hu = !1, (Ir !== null || Vr !== null) && (Yv(), $v()) } } function po(t, e) { var n = t.stateNode; if (n === null) return null; var i = _c(n); if (i === null) return null; n = i[e]; e: switch (e) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (i = !i.disabled) || (t = t.type, i = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !i; break e; default: t = !1 }if (t) return null; if (n && typeof n != "function") throw Error(R(231, e, typeof n)); return n } var Rd = !1; if (Fn) try { var fs = {}; Object.defineProperty(fs, "passive", { get: function () { Rd = !0 } }), window.addEventListener("test", fs, fs), window.removeEventListener("test", fs, fs) } catch { Rd = !1 } function N2(t, e, n, i, r, s, o, a, l) { var c = Array.prototype.slice.call(arguments, 3); try { e.apply(n, c) } catch (u) { this.onError(u) } } var Vs = !1, Ml = null, Tl = !1, Ld = null, F2 = { onError: function (t) { Vs = !0, Ml = t } }; function I2(t, e, n, i, r, s, o, a, l) { Vs = !1, Ml = null, N2.apply(F2, arguments) } function V2(t, e, n, i, r, s, o, a, l) { if (I2.apply(this, arguments), Vs) { if (Vs) { var c = Ml; Vs = !1, Ml = null } else throw Error(R(198)); Tl || (Tl = !0, Ld = c) } } function dr(t) { var e = t, n = t; if (t.alternate) for (; e.return;)e = e.return; else { t = e; do e = t, e.flags & 4098 && (n = e.return), t = e.return; while (t) } return e.tag === 3 ? n : null } function Xv(t) { if (t.tag === 13) { var e = t.memoizedState; if (e === null && (t = t.alternate, t !== null && (e = t.memoizedState)), e !== null) return e.dehydrated } return null } function am(t) { if (dr(t) !== t) throw Error(R(188)) } function z2(t) { var e = t.alternate; if (!e) { if (e = dr(t), e === null) throw Error(R(188)); return e !== t ? null : t } for (var n = t, i = e; ;) { var r = n.return; if (r === null) break; var s = r.alternate; if (s === null) { if (i = r.return, i !== null) { n = i; continue } break } if (r.child === s.child) { for (s = r.child; s;) { if (s === n) return am(r), t; if (s === i) return am(r), e; s = s.sibling } throw Error(R(188)) } if (n.return !== i.return) n = r, i = s; else { for (var o = !1, a = r.child; a;) { if (a === n) { o = !0, n = r, i = s; break } if (a === i) { o = !0, i = r, n = s; break } a = a.sibling } if (!o) { for (a = s.child; a;) { if (a === n) { o = !0, n = s, i = r; break } if (a === i) { o = !0, i = s, n = r; break } a = a.sibling } if (!o) throw Error(R(189)) } } if (n.alternate !== i) throw Error(R(190)) } if (n.tag !== 3) throw Error(R(188)); return n.stateNode.current === n ? t : e } function Gv(t) { return t = z2(t), t !== null ? Qv(t) : null } function Qv(t) { if (t.tag === 5 || t.tag === 6) return t; for (t = t.child; t !== null;) { var e = Qv(t); if (e !== null) return e; t = t.sibling } return null } var qv = Ot.unstable_scheduleCallback, lm = Ot.unstable_cancelCallback, B2 = Ot.unstable_shouldYield, H2 = Ot.unstable_requestPaint, Fe = Ot.unstable_now, W2 = Ot.unstable_getCurrentPriorityLevel, fh = Ot.unstable_ImmediatePriority, Zv = Ot.unstable_UserBlockingPriority, El = Ot.unstable_NormalPriority, $2 = Ot.unstable_LowPriority, Jv = Ot.unstable_IdlePriority, vc = null, hn = null; function U2(t) { if (hn && typeof hn.onCommitFiberRoot == "function") try { hn.onCommitFiberRoot(vc, t, void 0, (t.current.flags & 128) === 128) } catch { } } var qt = Math.clz32 ? Math.clz32 : X2, Y2 = Math.log, K2 = Math.LN2; function X2(t) { return t >>>= 0, t === 0 ? 32 : 31 - (Y2(t) / K2 | 0) | 0 } var va = 64, xa = 4194304; function Os(t) { switch (t & -t) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return t & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return t } } function Dl(t, e) { var n = t.pendingLanes; if (n === 0) return 0; var i = 0, r = t.suspendedLanes, s = t.pingedLanes, o = n & 268435455; if (o !== 0) { var a = o & ~r; a !== 0 ? i = Os(a) : (s &= o, s !== 0 && (i = Os(s))) } else o = n & ~r, o !== 0 ? i = Os(o) : s !== 0 && (i = Os(s)); if (i === 0) return 0; if (e !== 0 && e !== i && !(e & r) && (r = i & -i, s = e & -e, r >= s || r === 16 && (s & 4194240) !== 0)) return e; if (i & 4 && (i |= n & 16), e = t.entangledLanes, e !== 0) for (t = t.entanglements, e &= i; 0 < e;)n = 31 - qt(e), r = 1 << n, i |= t[n], e &= ~r; return i } function G2(t, e) { switch (t) { case 1: case 2: case 4: return e + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function Q2(t, e) { for (var n = t.suspendedLanes, i = t.pingedLanes, r = t.expirationTimes, s = t.pendingLanes; 0 < s;) { var o = 31 - qt(s), a = 1 << o, l = r[o]; l === -1 ? (!(a & n) || a & i) && (r[o] = G2(a, e)) : l <= e && (t.expiredLanes |= a), s &= ~a } } function jd(t) { return t = t.pendingLanes & -1073741825, t !== 0 ? t : t & 1073741824 ? 1073741824 : 0 } function ex() { var t = va; return va <<= 1, !(va & 4194240) && (va = 64), t } function pu(t) { for (var e = [], n = 0; 31 > n; n++)e.push(t); return e } function Wo(t, e, n) { t.pendingLanes |= e, e !== 536870912 && (t.suspendedLanes = 0, t.pingedLanes = 0), t = t.eventTimes, e = 31 - qt(e), t[e] = n } function q2(t, e) { var n = t.pendingLanes & ~e; t.pendingLanes = e, t.suspendedLanes = 0, t.pingedLanes = 0, t.expiredLanes &= e, t.mutableReadLanes &= e, t.entangledLanes &= e, e = t.entanglements; var i = t.eventTimes; for (t = t.expirationTimes; 0 < n;) { var r = 31 - qt(n), s = 1 << r; e[r] = 0, i[r] = -1, t[r] = -1, n &= ~s } } function hh(t, e) { var n = t.entangledLanes |= e; for (t = t.entanglements; n;) { var i = 31 - qt(n), r = 1 << i; r & e | t[i] & e && (t[i] |= e), n &= ~r } } var ue = 0; function tx(t) { return t &= -t, 1 < t ? 4 < t ? t & 268435455 ? 16 : 536870912 : 4 : 1 } var nx, ph, ix, rx, sx, Ad = !1, wa = [], li = null, ci = null, ui = null, mo = new Map, go = new Map, Jn = [], Z2 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function cm(t, e) { switch (t) { case "focusin": case "focusout": li = null; break; case "dragenter": case "dragleave": ci = null; break; case "mouseover": case "mouseout": ui = null; break; case "pointerover": case "pointerout": mo.delete(e.pointerId); break; case "gotpointercapture": case "lostpointercapture": go.delete(e.pointerId) } } function hs(t, e, n, i, r, s) { return t === null || t.nativeEvent !== s ? (t = { blockedOn: e, domEventName: n, eventSystemFlags: i, nativeEvent: s, targetContainers: [r] }, e !== null && (e = Uo(e), e !== null && ph(e)), t) : (t.eventSystemFlags |= i, e = t.targetContainers, r !== null && e.indexOf(r) === -1 && e.push(r), t) } function J2(t, e, n, i, r) { switch (e) { case "focusin": return li = hs(li, t, e, n, i, r), !0; case "dragenter": return ci = hs(ci, t, e, n, i, r), !0; case "mouseover": return ui = hs(ui, t, e, n, i, r), !0; case "pointerover": var s = r.pointerId; return mo.set(s, hs(mo.get(s) || null, t, e, n, i, r)), !0; case "gotpointercapture": return s = r.pointerId, go.set(s, hs(go.get(s) || null, t, e, n, i, r)), !0 }return !1 } function ox(t) { var e = $i(t.target); if (e !== null) { var n = dr(e); if (n !== null) { if (e = n.tag, e === 13) { if (e = Xv(n), e !== null) { t.blockedOn = e, sx(t.priority, function () { ix(n) }); return } } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) { t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null; return } } } t.blockedOn = null } function al(t) { if (t.blockedOn !== null) return !1; for (var e = t.targetContainers; 0 < e.length;) { var n = Nd(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent); if (n === null) { n = t.nativeEvent; var i = new n.constructor(n.type, n); Dd = i, n.target.dispatchEvent(i), Dd = null } else return e = Uo(n), e !== null && ph(e), t.blockedOn = n, !1; e.shift() } return !0 } function um(t, e, n) { al(t) && n.delete(e) } function eS() { Ad = !1, li !== null && al(li) && (li = null), ci !== null && al(ci) && (ci = null), ui !== null && al(ui) && (ui = null), mo.forEach(um), go.forEach(um) } function ps(t, e) { t.blockedOn === e && (t.blockedOn = null, Ad || (Ad = !0, Ot.unstable_scheduleCallback(Ot.unstable_NormalPriority, eS))) } function yo(t) { function e(r) { return ps(r, t) } if (0 < wa.length) { ps(wa[0], t); for (var n = 1; n < wa.length; n++) { var i = wa[n]; i.blockedOn === t && (i.blockedOn = null) } } for (li !== null && ps(li, t), ci !== null && ps(ci, t), ui !== null && ps(ui, t), mo.forEach(e), go.forEach(e), n = 0; n < Jn.length; n++)i = Jn[n], i.blockedOn === t && (i.blockedOn = null); for (; 0 < Jn.length && (n = Jn[0], n.blockedOn === null);)ox(n), n.blockedOn === null && Jn.shift() } var zr = Bn.ReactCurrentBatchConfig, Ol = !0; function tS(t, e, n, i) { var r = ue, s = zr.transition; zr.transition = null; try { ue = 1, mh(t, e, n, i) } finally { ue = r, zr.transition = s } } function nS(t, e, n, i) { var r = ue, s = zr.transition; zr.transition = null; try { ue = 4, mh(t, e, n, i) } finally { ue = r, zr.transition = s } } function mh(t, e, n, i) { if (Ol) { var r = Nd(t, e, n, i); if (r === null) ku(t, e, i, Rl, n), cm(t, i); else if (J2(r, t, e, n, i)) i.stopPropagation(); else if (cm(t, i), e & 4 && -1 < Z2.indexOf(t)) { for (; r !== null;) { var s = Uo(r); if (s !== null && nx(s), s = Nd(t, e, n, i), s === null && ku(t, e, i, Rl, n), s === r) break; r = s } r !== null && i.stopPropagation() } else ku(t, e, i, null, n) } } var Rl = null; function Nd(t, e, n, i) { if (Rl = null, t = dh(i), t = $i(t), t !== null) if (e = dr(t), e === null) t = null; else if (n = e.tag, n === 13) { if (t = Xv(e), t !== null) return t; t = null } else if (n === 3) { if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null; t = null } else e !== t && (t = null); return Rl = t, null } function ax(t) { switch (t) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (W2()) { case fh: return 1; case Zv: return 4; case El: case $2: return 16; case Jv: return 536870912; default: return 16 }default: return 16 } } var ti = null, gh = null, ll = null; function lx() { if (ll) return ll; var t, e = gh, n = e.length, i, r = "value" in ti ? ti.value : ti.textContent, s = r.length; for (t = 0; t < n && e[t] === r[t]; t++); var o = n - t; for (i = 1; i <= o && e[n - i] === r[s - i]; i++); return ll = r.slice(t, 1 < i ? 1 - i : void 0) } function cl(t) { var e = t.keyCode; return "charCode" in t ? (t = t.charCode, t === 0 && e === 13 && (t = 13)) : t = e, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0 } function ba() { return !0 } function dm() { return !1 } function jt(t) { function e(n, i, r, s, o) { this._reactName = n, this._targetInst = r, this.type = i, this.nativeEvent = s, this.target = o, this.currentTarget = null; for (var a in t) t.hasOwnProperty(a) && (n = t[a], this[a] = n ? n(s) : s[a]); return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? ba : dm, this.isPropagationStopped = dm, this } return Me(e.prototype, { preventDefault: function () { this.defaultPrevented = !0; var n = this.nativeEvent; n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = ba) }, stopPropagation: function () { var n = this.nativeEvent; n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = ba) }, persist: function () { }, isPersistent: ba }), e } var ss = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (t) { return t.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, yh = jt(ss), $o = Me({}, ss, { view: 0, detail: 0 }), iS = jt($o), mu, gu, ms, xc = Me({}, $o, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: vh, button: 0, buttons: 0, relatedTarget: function (t) { return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget }, movementX: function (t) { return "movementX" in t ? t.movementX : (t !== ms && (ms && t.type === "mousemove" ? (mu = t.screenX - ms.screenX, gu = t.screenY - ms.screenY) : gu = mu = 0, ms = t), mu) }, movementY: function (t) { return "movementY" in t ? t.movementY : gu } }), fm = jt(xc), rS = Me({}, xc, { dataTransfer: 0 }), sS = jt(rS), oS = Me({}, $o, { relatedTarget: 0 }), yu = jt(oS), aS = Me({}, ss, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), lS = jt(aS), cS = Me({}, ss, { clipboardData: function (t) { return "clipboardData" in t ? t.clipboardData : window.clipboardData } }), uS = jt(cS), dS = Me({}, ss, { data: 0 }), hm = jt(dS), fS = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, hS = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, pS = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function mS(t) { var e = this.nativeEvent; return e.getModifierState ? e.getModifierState(t) : (t = pS[t]) ? !!e[t] : !1 } function vh() { return mS } var gS = Me({}, $o, { key: function (t) { if (t.key) { var e = fS[t.key] || t.key; if (e !== "Unidentified") return e } return t.type === "keypress" ? (t = cl(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? hS[t.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: vh, charCode: function (t) { return t.type === "keypress" ? cl(t) : 0 }, keyCode: function (t) { return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0 }, which: function (t) { return t.type === "keypress" ? cl(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0 } }), yS = jt(gS), vS = Me({}, xc, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), pm = jt(vS), xS = Me({}, $o, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: vh }), wS = jt(xS), bS = Me({}, ss, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), _S = jt(bS), SS = Me({}, xc, { deltaX: function (t) { return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0 }, deltaY: function (t) { return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), kS = jt(SS), PS = [9, 13, 27, 32], xh = Fn && "CompositionEvent" in window, zs = null; Fn && "documentMode" in document && (zs = document.documentMode); var CS = Fn && "TextEvent" in window && !zs, cx = Fn && (!xh || zs && 8 < zs && 11 >= zs), mm = String.fromCharCode(32), gm = !1; function ux(t, e) { switch (t) { case "keyup": return PS.indexOf(e.keyCode) !== -1; case "keydown": return e.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function dx(t) { return t = t.detail, typeof t == "object" && "data" in t ? t.data : null } var _r = !1; function MS(t, e) { switch (t) { case "compositionend": return dx(e); case "keypress": return e.which !== 32 ? null : (gm = !0, mm); case "textInput": return t = e.data, t === mm && gm ? null : t; default: return null } } function TS(t, e) { if (_r) return t === "compositionend" || !xh && ux(t, e) ? (t = lx(), ll = gh = ti = null, _r = !1, t) : null; switch (t) { case "paste": return null; case "keypress": if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) { if (e.char && 1 < e.char.length) return e.char; if (e.which) return String.fromCharCode(e.which) } return null; case "compositionend": return cx && e.locale !== "ko" ? null : e.data; default: return null } } var ES = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function ym(t) { var e = t && t.nodeName && t.nodeName.toLowerCase(); return e === "input" ? !!ES[t.type] : e === "textarea" } function fx(t, e, n, i) { Wv(i), e = Ll(e, "onChange"), 0 < e.length && (n = new yh("onChange", "change", null, n, i), t.push({ event: n, listeners: e })) } var Bs = null, vo = null; function DS(t) { Sx(t, 0) } function wc(t) { var e = Pr(t); if (Nv(e)) return t } function OS(t, e) { if (t === "change") return e } var hx = !1; if (Fn) { var vu; if (Fn) { var xu = "oninput" in document; if (!xu) { var vm = document.createElement("div"); vm.setAttribute("oninput", "return;"), xu = typeof vm.oninput == "function" } vu = xu } else vu = !1; hx = vu && (!document.documentMode || 9 < document.documentMode) } function xm() { Bs && (Bs.detachEvent("onpropertychange", px), vo = Bs = null) } function px(t) { if (t.propertyName === "value" && wc(vo)) { var e = []; fx(e, vo, t, dh(t)), Kv(DS, e) } } function RS(t, e, n) { t === "focusin" ? (xm(), Bs = e, vo = n, Bs.attachEvent("onpropertychange", px)) : t === "focusout" && xm() } function LS(t) { if (t === "selectionchange" || t === "keyup" || t === "keydown") return wc(vo) } function jS(t, e) { if (t === "click") return wc(e) } function AS(t, e) { if (t === "input" || t === "change") return wc(e) } function NS(t, e) { return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e } var en = typeof Object.is == "function" ? Object.is : NS; function xo(t, e) { if (en(t, e)) return !0; if (typeof t != "object" || t === null || typeof e != "object" || e === null) return !1; var n = Object.keys(t), i = Object.keys(e); if (n.length !== i.length) return !1; for (i = 0; i < n.length; i++) { var r = n[i]; if (!vd.call(e, r) || !en(t[r], e[r])) return !1 } return !0 } function wm(t) { for (; t && t.firstChild;)t = t.firstChild; return t } function bm(t, e) { var n = wm(t); t = 0; for (var i; n;) { if (n.nodeType === 3) { if (i = t + n.textContent.length, t <= e && i >= e) return { node: n, offset: e - t }; t = i } e: { for (; n;) { if (n.nextSibling) { n = n.nextSibling; break e } n = n.parentNode } n = void 0 } n = wm(n) } } function mx(t, e) { return t && e ? t === e ? !0 : t && t.nodeType === 3 ? !1 : e && e.nodeType === 3 ? mx(t, e.parentNode) : "contains" in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : !1 : !1 } function gx() { for (var t = window, e = Cl(); e instanceof t.HTMLIFrameElement;) { try { var n = typeof e.contentWindow.location.href == "string" } catch { n = !1 } if (n) t = e.contentWindow; else break; e = Cl(t.document) } return e } function wh(t) { var e = t && t.nodeName && t.nodeName.toLowerCase(); return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true") } function FS(t) { var e = gx(), n = t.focusedElem, i = t.selectionRange; if (e !== n && n && n.ownerDocument && mx(n.ownerDocument.documentElement, n)) { if (i !== null && wh(n)) { if (e = i.start, t = i.end, t === void 0 && (t = e), "selectionStart" in n) n.selectionStart = e, n.selectionEnd = Math.min(t, n.value.length); else if (t = (e = n.ownerDocument || document) && e.defaultView || window, t.getSelection) { t = t.getSelection(); var r = n.textContent.length, s = Math.min(i.start, r); i = i.end === void 0 ? s : Math.min(i.end, r), !t.extend && s > i && (r = i, i = s, s = r), r = bm(n, s); var o = bm(n, i); r && o && (t.rangeCount !== 1 || t.anchorNode !== r.node || t.anchorOffset !== r.offset || t.focusNode !== o.node || t.focusOffset !== o.offset) && (e = e.createRange(), e.setStart(r.node, r.offset), t.removeAllRanges(), s > i ? (t.addRange(e), t.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset), t.addRange(e))) } } for (e = [], t = n; t = t.parentNode;)t.nodeType === 1 && e.push({ element: t, left: t.scrollLeft, top: t.scrollTop }); for (typeof n.focus == "function" && n.focus(), n = 0; n < e.length; n++)t = e[n], t.element.scrollLeft = t.left, t.element.scrollTop = t.top } } var IS = Fn && "documentMode" in document && 11 >= document.documentMode, Sr = null, Fd = null, Hs = null, Id = !1; function _m(t, e, n) { var i = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument; Id || Sr == null || Sr !== Cl(i) || (i = Sr, "selectionStart" in i && wh(i) ? i = { start: i.selectionStart, end: i.selectionEnd } : (i = (i.ownerDocument && i.ownerDocument.defaultView || window).getSelection(), i = { anchorNode: i.anchorNode, anchorOffset: i.anchorOffset, focusNode: i.focusNode, focusOffset: i.focusOffset }), Hs && xo(Hs, i) || (Hs = i, i = Ll(Fd, "onSelect"), 0 < i.length && (e = new yh("onSelect", "select", null, e, n), t.push({ event: e, listeners: i }), e.target = Sr))) } function _a(t, e) { var n = {}; return n[t.toLowerCase()] = e.toLowerCase(), n["Webkit" + t] = "webkit" + e, n["Moz" + t] = "moz" + e, n } var kr = { animationend: _a("Animation", "AnimationEnd"), animationiteration: _a("Animation", "AnimationIteration"), animationstart: _a("Animation", "AnimationStart"), transitionend: _a("Transition", "TransitionEnd") }, wu = {}, yx = {}; Fn && (yx = document.createElement("div").style, "AnimationEvent" in window || (delete kr.animationend.animation, delete kr.animationiteration.animation, delete kr.animationstart.animation), "TransitionEvent" in window || delete kr.transitionend.transition); function bc(t) { if (wu[t]) return wu[t]; if (!kr[t]) return t; var e = kr[t], n; for (n in e) if (e.hasOwnProperty(n) && n in yx) return wu[t] = e[n]; return t } var vx = bc("animationend"), xx = bc("animationiteration"), wx = bc("animationstart"), bx = bc("transitionend"), _x = new Map, Sm = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Ci(t, e) { _x.set(t, e), ur(e, [t]) } for (var bu = 0; bu < Sm.length; bu++) { var _u = Sm[bu], VS = _u.toLowerCase(), zS = _u[0].toUpperCase() + _u.slice(1); Ci(VS, "on" + zS) } Ci(vx, "onAnimationEnd"); Ci(xx, "onAnimationIteration"); Ci(wx, "onAnimationStart"); Ci("dblclick", "onDoubleClick"); Ci("focusin", "onFocus"); Ci("focusout", "onBlur"); Ci(bx, "onTransitionEnd"); Ur("onMouseEnter", ["mouseout", "mouseover"]); Ur("onMouseLeave", ["mouseout", "mouseover"]); Ur("onPointerEnter", ["pointerout", "pointerover"]); Ur("onPointerLeave", ["pointerout", "pointerover"]); ur("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); ur("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); ur("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); ur("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); ur("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); ur("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Rs = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), BS = new Set("cancel close invalid load scroll toggle".split(" ").concat(Rs)); function km(t, e, n) { var i = t.type || "unknown-event"; t.currentTarget = n, V2(i, e, void 0, t), t.currentTarget = null } function Sx(t, e) { e = (e & 4) !== 0; for (var n = 0; n < t.length; n++) { var i = t[n], r = i.event; i = i.listeners; e: { var s = void 0; if (e) for (var o = i.length - 1; 0 <= o; o--) { var a = i[o], l = a.instance, c = a.currentTarget; if (a = a.listener, l !== s && r.isPropagationStopped()) break e; km(r, a, c), s = l } else for (o = 0; o < i.length; o++) { if (a = i[o], l = a.instance, c = a.currentTarget, a = a.listener, l !== s && r.isPropagationStopped()) break e; km(r, a, c), s = l } } } if (Tl) throw t = Ld, Tl = !1, Ld = null, t } function he(t, e) { var n = e[Wd]; n === void 0 && (n = e[Wd] = new Set); var i = t + "__bubble"; n.has(i) || (kx(e, t, 2, !1), n.add(i)) } function Su(t, e, n) { var i = 0; e && (i |= 4), kx(n, t, i, e) } var Sa = "_reactListening" + Math.random().toString(36).slice(2); function wo(t) { if (!t[Sa]) { t[Sa] = !0, Ov.forEach(function (n) { n !== "selectionchange" && (BS.has(n) || Su(n, !1, t), Su(n, !0, t)) }); var e = t.nodeType === 9 ? t : t.ownerDocument; e === null || e[Sa] || (e[Sa] = !0, Su("selectionchange", !1, e)) } } function kx(t, e, n, i) { switch (ax(e)) { case 1: var r = tS; break; case 4: r = nS; break; default: r = mh }n = r.bind(null, e, n, t), r = void 0, !Rd || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (r = !0), i ? r !== void 0 ? t.addEventListener(e, n, { capture: !0, passive: r }) : t.addEventListener(e, n, !0) : r !== void 0 ? t.addEventListener(e, n, { passive: r }) : t.addEventListener(e, n, !1) } function ku(t, e, n, i, r) { var s = i; if (!(e & 1) && !(e & 2) && i !== null) e: for (; ;) { if (i === null) return; var o = i.tag; if (o === 3 || o === 4) { var a = i.stateNode.containerInfo; if (a === r || a.nodeType === 8 && a.parentNode === r) break; if (o === 4) for (o = i.return; o !== null;) { var l = o.tag; if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo, l === r || l.nodeType === 8 && l.parentNode === r)) return; o = o.return } for (; a !== null;) { if (o = $i(a), o === null) return; if (l = o.tag, l === 5 || l === 6) { i = s = o; continue e } a = a.parentNode } } i = i.return } Kv(function () { var c = s, u = dh(n), d = []; e: { var f = _x.get(t); if (f !== void 0) { var h = yh, m = t; switch (t) { case "keypress": if (cl(n) === 0) break e; case "keydown": case "keyup": h = yS; break; case "focusin": m = "focus", h = yu; break; case "focusout": m = "blur", h = yu; break; case "beforeblur": case "afterblur": h = yu; break; case "click": if (n.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": h = fm; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": h = sS; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": h = wS; break; case vx: case xx: case wx: h = lS; break; case bx: h = _S; break; case "scroll": h = iS; break; case "wheel": h = kS; break; case "copy": case "cut": case "paste": h = uS; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": h = pm }var p = (e & 4) !== 0, x = !p && t === "scroll", y = p ? f !== null ? f + "Capture" : null : f; p = []; for (var g = c, v; g !== null;) { v = g; var b = v.stateNode; if (v.tag === 5 && b !== null && (v = b, y !== null && (b = po(g, y), b != null && p.push(bo(g, b, v)))), x) break; g = g.return } 0 < p.length && (f = new h(f, m, null, n, u), d.push({ event: f, listeners: p })) } } if (!(e & 7)) { e: { if (f = t === "mouseover" || t === "pointerover", h = t === "mouseout" || t === "pointerout", f && n !== Dd && (m = n.relatedTarget || n.fromElement) && ($i(m) || m[In])) break e; if ((h || f) && (f = u.window === u ? u : (f = u.ownerDocument) ? f.defaultView || f.parentWindow : window, h ? (m = n.relatedTarget || n.toElement, h = c, m = m ? $i(m) : null, m !== null && (x = dr(m), m !== x || m.tag !== 5 && m.tag !== 6) && (m = null)) : (h = null, m = c), h !== m)) { if (p = fm, b = "onMouseLeave", y = "onMouseEnter", g = "mouse", (t === "pointerout" || t === "pointerover") && (p = pm, b = "onPointerLeave", y = "onPointerEnter", g = "pointer"), x = h == null ? f : Pr(h), v = m == null ? f : Pr(m), f = new p(b, g + "leave", h, n, u), f.target = x, f.relatedTarget = v, b = null, $i(u) === c && (p = new p(y, g + "enter", m, n, u), p.target = v, p.relatedTarget = x, b = p), x = b, h && m) t: { for (p = h, y = m, g = 0, v = p; v; v = yr(v))g++; for (v = 0, b = y; b; b = yr(b))v++; for (; 0 < g - v;)p = yr(p), g--; for (; 0 < v - g;)y = yr(y), v--; for (; g--;) { if (p === y || y !== null && p === y.alternate) break t; p = yr(p), y = yr(y) } p = null } else p = null; h !== null && Pm(d, f, h, p, !1), m !== null && x !== null && Pm(d, x, m, p, !0) } } e: { if (f = c ? Pr(c) : window, h = f.nodeName && f.nodeName.toLowerCase(), h === "select" || h === "input" && f.type === "file") var _ = OS; else if (ym(f)) if (hx) _ = AS; else { _ = LS; var k = RS } else (h = f.nodeName) && h.toLowerCase() === "input" && (f.type === "checkbox" || f.type === "radio") && (_ = jS); if (_ && (_ = _(t, c))) { fx(d, _, n, u); break e } k && k(t, f, c), t === "focusout" && (k = f._wrapperState) && k.controlled && f.type === "number" && Pd(f, "number", f.value) } switch (k = c ? Pr(c) : window, t) { case "focusin": (ym(k) || k.contentEditable === "true") && (Sr = k, Fd = c, Hs = null); break; case "focusout": Hs = Fd = Sr = null; break; case "mousedown": Id = !0; break; case "contextmenu": case "mouseup": case "dragend": Id = !1, _m(d, n, u); break; case "selectionchange": if (IS) break; case "keydown": case "keyup": _m(d, n, u) }var S; if (xh) e: { switch (t) { case "compositionstart": var P = "onCompositionStart"; break e; case "compositionend": P = "onCompositionEnd"; break e; case "compositionupdate": P = "onCompositionUpdate"; break e }P = void 0 } else _r ? ux(t, n) && (P = "onCompositionEnd") : t === "keydown" && n.keyCode === 229 && (P = "onCompositionStart"); P && (cx && n.locale !== "ko" && (_r || P !== "onCompositionStart" ? P === "onCompositionEnd" && _r && (S = lx()) : (ti = u, gh = "value" in ti ? ti.value : ti.textContent, _r = !0)), k = Ll(c, P), 0 < k.length && (P = new hm(P, t, null, n, u), d.push({ event: P, listeners: k }), S ? P.data = S : (S = dx(n), S !== null && (P.data = S)))), (S = CS ? MS(t, n) : TS(t, n)) && (c = Ll(c, "onBeforeInput"), 0 < c.length && (u = new hm("onBeforeInput", "beforeinput", null, n, u), d.push({ event: u, listeners: c }), u.data = S)) } Sx(d, e) }) } function bo(t, e, n) { return { instance: t, listener: e, currentTarget: n } } function Ll(t, e) { for (var n = e + "Capture", i = []; t !== null;) { var r = t, s = r.stateNode; r.tag === 5 && s !== null && (r = s, s = po(t, n), s != null && i.unshift(bo(t, s, r)), s = po(t, e), s != null && i.push(bo(t, s, r))), t = t.return } return i } function yr(t) { if (t === null) return null; do t = t.return; while (t && t.tag !== 5); return t || null } function Pm(t, e, n, i, r) { for (var s = e._reactName, o = []; n !== null && n !== i;) { var a = n, l = a.alternate, c = a.stateNode; if (l !== null && l === i) break; a.tag === 5 && c !== null && (a = c, r ? (l = po(n, s), l != null && o.unshift(bo(n, l, a))) : r || (l = po(n, s), l != null && o.push(bo(n, l, a)))), n = n.return } o.length !== 0 && t.push({ event: e, listeners: o }) } var HS = /\r\n?/g, WS = /\u0000|\uFFFD/g; function Cm(t) {
    return (typeof t == "string" ? t : "" + t).replace(HS, `
`).replace(WS, "")
} function ka(t, e, n) { if (e = Cm(e), Cm(t) !== e && n) throw Error(R(425)) } function jl() { } var Vd = null, zd = null; function Bd(t, e) { return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null } var Hd = typeof setTimeout == "function" ? setTimeout : void 0, $S = typeof clearTimeout == "function" ? clearTimeout : void 0, Mm = typeof Promise == "function" ? Promise : void 0, US = typeof queueMicrotask == "function" ? queueMicrotask : typeof Mm < "u" ? function (t) { return Mm.resolve(null).then(t).catch(YS) } : Hd; function YS(t) { setTimeout(function () { throw t }) } function Pu(t, e) { var n = e, i = 0; do { var r = n.nextSibling; if (t.removeChild(n), r && r.nodeType === 8) if (n = r.data, n === "/$") { if (i === 0) { t.removeChild(r), yo(e); return } i-- } else n !== "$" && n !== "$?" && n !== "$!" || i++; n = r } while (n); yo(e) } function di(t) { for (; t != null; t = t.nextSibling) { var e = t.nodeType; if (e === 1 || e === 3) break; if (e === 8) { if (e = t.data, e === "$" || e === "$!" || e === "$?") break; if (e === "/$") return null } } return t } function Tm(t) { t = t.previousSibling; for (var e = 0; t;) { if (t.nodeType === 8) { var n = t.data; if (n === "$" || n === "$!" || n === "$?") { if (e === 0) return t; e-- } else n === "/$" && e++ } t = t.previousSibling } return null } var os = Math.random().toString(36).slice(2), fn = "__reactFiber$" + os, _o = "__reactProps$" + os, In = "__reactContainer$" + os, Wd = "__reactEvents$" + os, KS = "__reactListeners$" + os, XS = "__reactHandles$" + os; function $i(t) { var e = t[fn]; if (e) return e; for (var n = t.parentNode; n;) { if (e = n[In] || n[fn]) { if (n = e.alternate, e.child !== null || n !== null && n.child !== null) for (t = Tm(t); t !== null;) { if (n = t[fn]) return n; t = Tm(t) } return e } t = n, n = t.parentNode } return null } function Uo(t) { return t = t[fn] || t[In], !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t } function Pr(t) { if (t.tag === 5 || t.tag === 6) return t.stateNode; throw Error(R(33)) } function _c(t) { return t[_o] || null } var $d = [], Cr = -1; function Mi(t) { return { current: t } } function ge(t) { 0 > Cr || (t.current = $d[Cr], $d[Cr] = null, Cr--) } function fe(t, e) { Cr++, $d[Cr] = t.current, t.current = e } var bi = {}, lt = Mi(bi), bt = Mi(!1), er = bi; function Yr(t, e) { var n = t.type.contextTypes; if (!n) return bi; var i = t.stateNode; if (i && i.__reactInternalMemoizedUnmaskedChildContext === e) return i.__reactInternalMemoizedMaskedChildContext; var r = {}, s; for (s in n) r[s] = e[s]; return i && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = e, t.__reactInternalMemoizedMaskedChildContext = r), r } function _t(t) { return t = t.childContextTypes, t != null } function Al() { ge(bt), ge(lt) } function Em(t, e, n) { if (lt.current !== bi) throw Error(R(168)); fe(lt, e), fe(bt, n) } function Px(t, e, n) { var i = t.stateNode; if (e = e.childContextTypes, typeof i.getChildContext != "function") return n; i = i.getChildContext(); for (var r in i) if (!(r in e)) throw Error(R(108, R2(t) || "Unknown", r)); return Me({}, n, i) } function Nl(t) { return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || bi, er = lt.current, fe(lt, t), fe(bt, bt.current), !0 } function Dm(t, e, n) { var i = t.stateNode; if (!i) throw Error(R(169)); n ? (t = Px(t, e, er), i.__reactInternalMemoizedMergedChildContext = t, ge(bt), ge(lt), fe(lt, t)) : ge(bt), fe(bt, n) } var Mn = null, Sc = !1, Cu = !1; function Cx(t) { Mn === null ? Mn = [t] : Mn.push(t) } function GS(t) { Sc = !0, Cx(t) } function Ti() { if (!Cu && Mn !== null) { Cu = !0; var t = 0, e = ue; try { var n = Mn; for (ue = 1; t < n.length; t++) { var i = n[t]; do i = i(!0); while (i !== null) } Mn = null, Sc = !1 } catch (r) { throw Mn !== null && (Mn = Mn.slice(t + 1)), qv(fh, Ti), r } finally { ue = e, Cu = !1 } } return null } var Mr = [], Tr = 0, Fl = null, Il = 0, Ft = [], It = 0, tr = null, En = 1, Dn = ""; function Ii(t, e) { Mr[Tr++] = Il, Mr[Tr++] = Fl, Fl = t, Il = e } function Mx(t, e, n) { Ft[It++] = En, Ft[It++] = Dn, Ft[It++] = tr, tr = t; var i = En; t = Dn; var r = 32 - qt(i) - 1; i &= ~(1 << r), n += 1; var s = 32 - qt(e) + r; if (30 < s) { var o = r - r % 5; s = (i & (1 << o) - 1).toString(32), i >>= o, r -= o, En = 1 << 32 - qt(e) + r | n << r | i, Dn = s + t } else En = 1 << s | n << r | i, Dn = t } function bh(t) { t.return !== null && (Ii(t, 1), Mx(t, 1, 0)) } function _h(t) { for (; t === Fl;)Fl = Mr[--Tr], Mr[Tr] = null, Il = Mr[--Tr], Mr[Tr] = null; for (; t === tr;)tr = Ft[--It], Ft[It] = null, Dn = Ft[--It], Ft[It] = null, En = Ft[--It], Ft[It] = null } var Dt = null, Tt = null, xe = !1, Gt = null; function Tx(t, e) { var n = Vt(5, null, null, 0); n.elementType = "DELETED", n.stateNode = e, n.return = t, e = t.deletions, e === null ? (t.deletions = [n], t.flags |= 16) : e.push(n) } function Om(t, e) { switch (t.tag) { case 5: var n = t.type; return e = e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (t.stateNode = e, Dt = t, Tt = di(e.firstChild), !0) : !1; case 6: return e = t.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (t.stateNode = e, Dt = t, Tt = null, !0) : !1; case 13: return e = e.nodeType !== 8 ? null : e, e !== null ? (n = tr !== null ? { id: En, overflow: Dn } : null, t.memoizedState = { dehydrated: e, treeContext: n, retryLane: 1073741824 }, n = Vt(18, null, null, 0), n.stateNode = e, n.return = t, t.child = n, Dt = t, Tt = null, !0) : !1; default: return !1 } } function Ud(t) { return (t.mode & 1) !== 0 && (t.flags & 128) === 0 } function Yd(t) { if (xe) { var e = Tt; if (e) { var n = e; if (!Om(t, e)) { if (Ud(t)) throw Error(R(418)); e = di(n.nextSibling); var i = Dt; e && Om(t, e) ? Tx(i, n) : (t.flags = t.flags & -4097 | 2, xe = !1, Dt = t) } } else { if (Ud(t)) throw Error(R(418)); t.flags = t.flags & -4097 | 2, xe = !1, Dt = t } } } function Rm(t) { for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13;)t = t.return; Dt = t } function Pa(t) { if (t !== Dt) return !1; if (!xe) return Rm(t), xe = !0, !1; var e; if ((e = t.tag !== 3) && !(e = t.tag !== 5) && (e = t.type, e = e !== "head" && e !== "body" && !Bd(t.type, t.memoizedProps)), e && (e = Tt)) { if (Ud(t)) throw Ex(), Error(R(418)); for (; e;)Tx(t, e), e = di(e.nextSibling) } if (Rm(t), t.tag === 13) { if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t) throw Error(R(317)); e: { for (t = t.nextSibling, e = 0; t;) { if (t.nodeType === 8) { var n = t.data; if (n === "/$") { if (e === 0) { Tt = di(t.nextSibling); break e } e-- } else n !== "$" && n !== "$!" && n !== "$?" || e++ } t = t.nextSibling } Tt = null } } else Tt = Dt ? di(t.stateNode.nextSibling) : null; return !0 } function Ex() { for (var t = Tt; t;)t = di(t.nextSibling) } function Kr() { Tt = Dt = null, xe = !1 } function Sh(t) { Gt === null ? Gt = [t] : Gt.push(t) } var QS = Bn.ReactCurrentBatchConfig; function Yt(t, e) { if (t && t.defaultProps) { e = Me({}, e), t = t.defaultProps; for (var n in t) e[n] === void 0 && (e[n] = t[n]); return e } return e } var Vl = Mi(null), zl = null, Er = null, kh = null; function Ph() { kh = Er = zl = null } function Ch(t) { var e = Vl.current; ge(Vl), t._currentValue = e } function Kd(t, e, n) { for (; t !== null;) { var i = t.alternate; if ((t.childLanes & e) !== e ? (t.childLanes |= e, i !== null && (i.childLanes |= e)) : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e), t === n) break; t = t.return } } function Br(t, e) { zl = t, kh = Er = null, t = t.dependencies, t !== null && t.firstContext !== null && (t.lanes & e && (wt = !0), t.firstContext = null) } function Bt(t) { var e = t._currentValue; if (kh !== t) if (t = { context: t, memoizedValue: e, next: null }, Er === null) { if (zl === null) throw Error(R(308)); Er = t, zl.dependencies = { lanes: 0, firstContext: t } } else Er = Er.next = t; return e } var Ui = null; function Mh(t) { Ui === null ? Ui = [t] : Ui.push(t) } function Dx(t, e, n, i) { var r = e.interleaved; return r === null ? (n.next = n, Mh(e)) : (n.next = r.next, r.next = n), e.interleaved = n, Vn(t, i) } function Vn(t, e) { t.lanes |= e; var n = t.alternate; for (n !== null && (n.lanes |= e), n = t, t = t.return; t !== null;)t.childLanes |= e, n = t.alternate, n !== null && (n.childLanes |= e), n = t, t = t.return; return n.tag === 3 ? n.stateNode : null } var qn = !1; function Th(t) { t.updateQueue = { baseState: t.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function Ox(t, e) { t = t.updateQueue, e.updateQueue === t && (e.updateQueue = { baseState: t.baseState, firstBaseUpdate: t.firstBaseUpdate, lastBaseUpdate: t.lastBaseUpdate, shared: t.shared, effects: t.effects }) } function An(t, e) { return { eventTime: t, lane: e, tag: 0, payload: null, callback: null, next: null } } function fi(t, e, n) { var i = t.updateQueue; if (i === null) return null; if (i = i.shared, oe & 2) { var r = i.pending; return r === null ? e.next = e : (e.next = r.next, r.next = e), i.pending = e, Vn(t, n) } return r = i.interleaved, r === null ? (e.next = e, Mh(i)) : (e.next = r.next, r.next = e), i.interleaved = e, Vn(t, n) } function ul(t, e, n) { if (e = e.updateQueue, e !== null && (e = e.shared, (n & 4194240) !== 0)) { var i = e.lanes; i &= t.pendingLanes, n |= i, e.lanes = n, hh(t, n) } } function Lm(t, e) { var n = t.updateQueue, i = t.alternate; if (i !== null && (i = i.updateQueue, n === i)) { var r = null, s = null; if (n = n.firstBaseUpdate, n !== null) { do { var o = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; s === null ? r = s = o : s = s.next = o, n = n.next } while (n !== null); s === null ? r = s = e : s = s.next = e } else r = s = e; n = { baseState: i.baseState, firstBaseUpdate: r, lastBaseUpdate: s, shared: i.shared, effects: i.effects }, t.updateQueue = n; return } t = n.lastBaseUpdate, t === null ? n.firstBaseUpdate = e : t.next = e, n.lastBaseUpdate = e } function Bl(t, e, n, i) { var r = t.updateQueue; qn = !1; var s = r.firstBaseUpdate, o = r.lastBaseUpdate, a = r.shared.pending; if (a !== null) { r.shared.pending = null; var l = a, c = l.next; l.next = null, o === null ? s = c : o.next = c, o = l; var u = t.alternate; u !== null && (u = u.updateQueue, a = u.lastBaseUpdate, a !== o && (a === null ? u.firstBaseUpdate = c : a.next = c, u.lastBaseUpdate = l)) } if (s !== null) { var d = r.baseState; o = 0, u = c = l = null, a = s; do { var f = a.lane, h = a.eventTime; if ((i & f) === f) { u !== null && (u = u.next = { eventTime: h, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null }); e: { var m = t, p = a; switch (f = e, h = n, p.tag) { case 1: if (m = p.payload, typeof m == "function") { d = m.call(h, d, f); break e } d = m; break e; case 3: m.flags = m.flags & -65537 | 128; case 0: if (m = p.payload, f = typeof m == "function" ? m.call(h, d, f) : m, f == null) break e; d = Me({}, d, f); break e; case 2: qn = !0 } } a.callback !== null && a.lane !== 0 && (t.flags |= 64, f = r.effects, f === null ? r.effects = [a] : f.push(a)) } else h = { eventTime: h, lane: f, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, u === null ? (c = u = h, l = d) : u = u.next = h, o |= f; if (a = a.next, a === null) { if (a = r.shared.pending, a === null) break; f = a, a = f.next, f.next = null, r.lastBaseUpdate = f, r.shared.pending = null } } while (1); if (u === null && (l = d), r.baseState = l, r.firstBaseUpdate = c, r.lastBaseUpdate = u, e = r.shared.interleaved, e !== null) { r = e; do o |= r.lane, r = r.next; while (r !== e) } else s === null && (r.shared.lanes = 0); ir |= o, t.lanes = o, t.memoizedState = d } } function jm(t, e, n) { if (t = e.effects, e.effects = null, t !== null) for (e = 0; e < t.length; e++) { var i = t[e], r = i.callback; if (r !== null) { if (i.callback = null, i = n, typeof r != "function") throw Error(R(191, r)); r.call(i) } } } var Rx = new Dv.Component().refs; function Xd(t, e, n, i) { e = t.memoizedState, n = n(i, e), n = n == null ? e : Me({}, e, n), t.memoizedState = n, t.lanes === 0 && (t.updateQueue.baseState = n) } var kc = { isMounted: function (t) { return (t = t._reactInternals) ? dr(t) === t : !1 }, enqueueSetState: function (t, e, n) { t = t._reactInternals; var i = ft(), r = pi(t), s = An(i, r); s.payload = e, n != null && (s.callback = n), e = fi(t, s, r), e !== null && (Zt(e, t, r, i), ul(e, t, r)) }, enqueueReplaceState: function (t, e, n) { t = t._reactInternals; var i = ft(), r = pi(t), s = An(i, r); s.tag = 1, s.payload = e, n != null && (s.callback = n), e = fi(t, s, r), e !== null && (Zt(e, t, r, i), ul(e, t, r)) }, enqueueForceUpdate: function (t, e) { t = t._reactInternals; var n = ft(), i = pi(t), r = An(n, i); r.tag = 2, e != null && (r.callback = e), e = fi(t, r, i), e !== null && (Zt(e, t, i, n), ul(e, t, i)) } }; function Am(t, e, n, i, r, s, o) { return t = t.stateNode, typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(i, s, o) : e.prototype && e.prototype.isPureReactComponent ? !xo(n, i) || !xo(r, s) : !0 } function Lx(t, e, n) { var i = !1, r = bi, s = e.contextType; return typeof s == "object" && s !== null ? s = Bt(s) : (r = _t(e) ? er : lt.current, i = e.contextTypes, s = (i = i != null) ? Yr(t, r) : bi), e = new e(n, s), t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = kc, t.stateNode = e, e._reactInternals = t, i && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = r, t.__reactInternalMemoizedMaskedChildContext = s), e } function Nm(t, e, n, i) { t = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(n, i), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(n, i), e.state !== t && kc.enqueueReplaceState(e, e.state, null) } function Gd(t, e, n, i) { var r = t.stateNode; r.props = n, r.state = t.memoizedState, r.refs = Rx, Th(t); var s = e.contextType; typeof s == "object" && s !== null ? r.context = Bt(s) : (s = _t(e) ? er : lt.current, r.context = Yr(t, s)), r.state = t.memoizedState, s = e.getDerivedStateFromProps, typeof s == "function" && (Xd(t, e, s, n), r.state = t.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof r.getSnapshotBeforeUpdate == "function" || typeof r.UNSAFE_componentWillMount != "function" && typeof r.componentWillMount != "function" || (e = r.state, typeof r.componentWillMount == "function" && r.componentWillMount(), typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(), e !== r.state && kc.enqueueReplaceState(r, r.state, null), Bl(t, n, r, i), r.state = t.memoizedState), typeof r.componentDidMount == "function" && (t.flags |= 4194308) } function gs(t, e, n) { if (t = n.ref, t !== null && typeof t != "function" && typeof t != "object") { if (n._owner) { if (n = n._owner, n) { if (n.tag !== 1) throw Error(R(309)); var i = n.stateNode } if (!i) throw Error(R(147, t)); var r = i, s = "" + t; return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function (o) { var a = r.refs; a === Rx && (a = r.refs = {}), o === null ? delete a[s] : a[s] = o }, e._stringRef = s, e) } if (typeof t != "string") throw Error(R(284)); if (!n._owner) throw Error(R(290, t)) } return t } function Ca(t, e) { throw t = Object.prototype.toString.call(e), Error(R(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t)) } function Fm(t) { var e = t._init; return e(t._payload) } function jx(t) { function e(y, g) { if (t) { var v = y.deletions; v === null ? (y.deletions = [g], y.flags |= 16) : v.push(g) } } function n(y, g) { if (!t) return null; for (; g !== null;)e(y, g), g = g.sibling; return null } function i(y, g) { for (y = new Map; g !== null;)g.key !== null ? y.set(g.key, g) : y.set(g.index, g), g = g.sibling; return y } function r(y, g) { return y = mi(y, g), y.index = 0, y.sibling = null, y } function s(y, g, v) { return y.index = v, t ? (v = y.alternate, v !== null ? (v = v.index, v < g ? (y.flags |= 2, g) : v) : (y.flags |= 2, g)) : (y.flags |= 1048576, g) } function o(y) { return t && y.alternate === null && (y.flags |= 2), y } function a(y, g, v, b) { return g === null || g.tag !== 6 ? (g = Lu(v, y.mode, b), g.return = y, g) : (g = r(g, v), g.return = y, g) } function l(y, g, v, b) { var _ = v.type; return _ === br ? u(y, g, v.props.children, b, v.key) : g !== null && (g.elementType === _ || typeof _ == "object" && _ !== null && _.$$typeof === Qn && Fm(_) === g.type) ? (b = r(g, v.props), b.ref = gs(y, g, v), b.return = y, b) : (b = gl(v.type, v.key, v.props, null, y.mode, b), b.ref = gs(y, g, v), b.return = y, b) } function c(y, g, v, b) { return g === null || g.tag !== 4 || g.stateNode.containerInfo !== v.containerInfo || g.stateNode.implementation !== v.implementation ? (g = ju(v, y.mode, b), g.return = y, g) : (g = r(g, v.children || []), g.return = y, g) } function u(y, g, v, b, _) { return g === null || g.tag !== 7 ? (g = Qi(v, y.mode, b, _), g.return = y, g) : (g = r(g, v), g.return = y, g) } function d(y, g, v) { if (typeof g == "string" && g !== "" || typeof g == "number") return g = Lu("" + g, y.mode, v), g.return = y, g; if (typeof g == "object" && g !== null) { switch (g.$$typeof) { case ma: return v = gl(g.type, g.key, g.props, null, y.mode, v), v.ref = gs(y, null, g), v.return = y, v; case wr: return g = ju(g, y.mode, v), g.return = y, g; case Qn: var b = g._init; return d(y, b(g._payload), v) }if (Ds(g) || ds(g)) return g = Qi(g, y.mode, v, null), g.return = y, g; Ca(y, g) } return null } function f(y, g, v, b) { var _ = g !== null ? g.key : null; if (typeof v == "string" && v !== "" || typeof v == "number") return _ !== null ? null : a(y, g, "" + v, b); if (typeof v == "object" && v !== null) { switch (v.$$typeof) { case ma: return v.key === _ ? l(y, g, v, b) : null; case wr: return v.key === _ ? c(y, g, v, b) : null; case Qn: return _ = v._init, f(y, g, _(v._payload), b) }if (Ds(v) || ds(v)) return _ !== null ? null : u(y, g, v, b, null); Ca(y, v) } return null } function h(y, g, v, b, _) { if (typeof b == "string" && b !== "" || typeof b == "number") return y = y.get(v) || null, a(g, y, "" + b, _); if (typeof b == "object" && b !== null) { switch (b.$$typeof) { case ma: return y = y.get(b.key === null ? v : b.key) || null, l(g, y, b, _); case wr: return y = y.get(b.key === null ? v : b.key) || null, c(g, y, b, _); case Qn: var k = b._init; return h(y, g, v, k(b._payload), _) }if (Ds(b) || ds(b)) return y = y.get(v) || null, u(g, y, b, _, null); Ca(g, b) } return null } function m(y, g, v, b) { for (var _ = null, k = null, S = g, P = g = 0, T = null; S !== null && P < v.length; P++) { S.index > P ? (T = S, S = null) : T = S.sibling; var D = f(y, S, v[P], b); if (D === null) { S === null && (S = T); break } t && S && D.alternate === null && e(y, S), g = s(D, g, P), k === null ? _ = D : k.sibling = D, k = D, S = T } if (P === v.length) return n(y, S), xe && Ii(y, P), _; if (S === null) { for (; P < v.length; P++)S = d(y, v[P], b), S !== null && (g = s(S, g, P), k === null ? _ = S : k.sibling = S, k = S); return xe && Ii(y, P), _ } for (S = i(y, S); P < v.length; P++)T = h(S, y, P, v[P], b), T !== null && (t && T.alternate !== null && S.delete(T.key === null ? P : T.key), g = s(T, g, P), k === null ? _ = T : k.sibling = T, k = T); return t && S.forEach(function (A) { return e(y, A) }), xe && Ii(y, P), _ } function p(y, g, v, b) { var _ = ds(v); if (typeof _ != "function") throw Error(R(150)); if (v = _.call(v), v == null) throw Error(R(151)); for (var k = _ = null, S = g, P = g = 0, T = null, D = v.next(); S !== null && !D.done; P++, D = v.next()) { S.index > P ? (T = S, S = null) : T = S.sibling; var A = f(y, S, D.value, b); if (A === null) { S === null && (S = T); break } t && S && A.alternate === null && e(y, S), g = s(A, g, P), k === null ? _ = A : k.sibling = A, k = A, S = T } if (D.done) return n(y, S), xe && Ii(y, P), _; if (S === null) { for (; !D.done; P++, D = v.next())D = d(y, D.value, b), D !== null && (g = s(D, g, P), k === null ? _ = D : k.sibling = D, k = D); return xe && Ii(y, P), _ } for (S = i(y, S); !D.done; P++, D = v.next())D = h(S, y, P, D.value, b), D !== null && (t && D.alternate !== null && S.delete(D.key === null ? P : D.key), g = s(D, g, P), k === null ? _ = D : k.sibling = D, k = D); return t && S.forEach(function (V) { return e(y, V) }), xe && Ii(y, P), _ } function x(y, g, v, b) { if (typeof v == "object" && v !== null && v.type === br && v.key === null && (v = v.props.children), typeof v == "object" && v !== null) { switch (v.$$typeof) { case ma: e: { for (var _ = v.key, k = g; k !== null;) { if (k.key === _) { if (_ = v.type, _ === br) { if (k.tag === 7) { n(y, k.sibling), g = r(k, v.props.children), g.return = y, y = g; break e } } else if (k.elementType === _ || typeof _ == "object" && _ !== null && _.$$typeof === Qn && Fm(_) === k.type) { n(y, k.sibling), g = r(k, v.props), g.ref = gs(y, k, v), g.return = y, y = g; break e } n(y, k); break } else e(y, k); k = k.sibling } v.type === br ? (g = Qi(v.props.children, y.mode, b, v.key), g.return = y, y = g) : (b = gl(v.type, v.key, v.props, null, y.mode, b), b.ref = gs(y, g, v), b.return = y, y = b) } return o(y); case wr: e: { for (k = v.key; g !== null;) { if (g.key === k) if (g.tag === 4 && g.stateNode.containerInfo === v.containerInfo && g.stateNode.implementation === v.implementation) { n(y, g.sibling), g = r(g, v.children || []), g.return = y, y = g; break e } else { n(y, g); break } else e(y, g); g = g.sibling } g = ju(v, y.mode, b), g.return = y, y = g } return o(y); case Qn: return k = v._init, x(y, g, k(v._payload), b) }if (Ds(v)) return m(y, g, v, b); if (ds(v)) return p(y, g, v, b); Ca(y, v) } return typeof v == "string" && v !== "" || typeof v == "number" ? (v = "" + v, g !== null && g.tag === 6 ? (n(y, g.sibling), g = r(g, v), g.return = y, y = g) : (n(y, g), g = Lu(v, y.mode, b), g.return = y, y = g), o(y)) : n(y, g) } return x } var Xr = jx(!0), Ax = jx(!1), Yo = {}, pn = Mi(Yo), So = Mi(Yo), ko = Mi(Yo); function Yi(t) { if (t === Yo) throw Error(R(174)); return t } function Eh(t, e) { switch (fe(ko, e), fe(So, t), fe(pn, Yo), t = e.nodeType, t) { case 9: case 11: e = (e = e.documentElement) ? e.namespaceURI : Md(null, ""); break; default: t = t === 8 ? e.parentNode : e, e = t.namespaceURI || null, t = t.tagName, e = Md(e, t) }ge(pn), fe(pn, e) } function Gr() { ge(pn), ge(So), ge(ko) } function Nx(t) { Yi(ko.current); var e = Yi(pn.current), n = Md(e, t.type); e !== n && (fe(So, t), fe(pn, n)) } function Dh(t) { So.current === t && (ge(pn), ge(So)) } var Se = Mi(0); function Hl(t) { for (var e = t; e !== null;) { if (e.tag === 13) { var n = e.memoizedState; if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return e } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) { if (e.flags & 128) return e } else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break; for (; e.sibling === null;) { if (e.return === null || e.return === t) return null; e = e.return } e.sibling.return = e.return, e = e.sibling } return null } var Mu = []; function Oh() { for (var t = 0; t < Mu.length; t++)Mu[t]._workInProgressVersionPrimary = null; Mu.length = 0 } var dl = Bn.ReactCurrentDispatcher, Tu = Bn.ReactCurrentBatchConfig, nr = 0, Ce = null, He = null, Ue = null, Wl = !1, Ws = !1, Po = 0, qS = 0; function nt() { throw Error(R(321)) } function Rh(t, e) { if (e === null) return !1; for (var n = 0; n < e.length && n < t.length; n++)if (!en(t[n], e[n])) return !1; return !0 } function Lh(t, e, n, i, r, s) { if (nr = s, Ce = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, dl.current = t === null || t.memoizedState === null ? tk : nk, t = n(i, r), Ws) { s = 0; do { if (Ws = !1, Po = 0, 25 <= s) throw Error(R(301)); s += 1, Ue = He = null, e.updateQueue = null, dl.current = ik, t = n(i, r) } while (Ws) } if (dl.current = $l, e = He !== null && He.next !== null, nr = 0, Ue = He = Ce = null, Wl = !1, e) throw Error(R(300)); return t } function jh() { var t = Po !== 0; return Po = 0, t } function an() { var t = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Ue === null ? Ce.memoizedState = Ue = t : Ue = Ue.next = t, Ue } function Ht() { if (He === null) { var t = Ce.alternate; t = t !== null ? t.memoizedState : null } else t = He.next; var e = Ue === null ? Ce.memoizedState : Ue.next; if (e !== null) Ue = e, He = t; else { if (t === null) throw Error(R(310)); He = t, t = { memoizedState: He.memoizedState, baseState: He.baseState, baseQueue: He.baseQueue, queue: He.queue, next: null }, Ue === null ? Ce.memoizedState = Ue = t : Ue = Ue.next = t } return Ue } function Co(t, e) { return typeof e == "function" ? e(t) : e } function Eu(t) { var e = Ht(), n = e.queue; if (n === null) throw Error(R(311)); n.lastRenderedReducer = t; var i = He, r = i.baseQueue, s = n.pending; if (s !== null) { if (r !== null) { var o = r.next; r.next = s.next, s.next = o } i.baseQueue = r = s, n.pending = null } if (r !== null) { s = r.next, i = i.baseState; var a = o = null, l = null, c = s; do { var u = c.lane; if ((nr & u) === u) l !== null && (l = l.next = { lane: 0, action: c.action, hasEagerState: c.hasEagerState, eagerState: c.eagerState, next: null }), i = c.hasEagerState ? c.eagerState : t(i, c.action); else { var d = { lane: u, action: c.action, hasEagerState: c.hasEagerState, eagerState: c.eagerState, next: null }; l === null ? (a = l = d, o = i) : l = l.next = d, Ce.lanes |= u, ir |= u } c = c.next } while (c !== null && c !== s); l === null ? o = i : l.next = a, en(i, e.memoizedState) || (wt = !0), e.memoizedState = i, e.baseState = o, e.baseQueue = l, n.lastRenderedState = i } if (t = n.interleaved, t !== null) { r = t; do s = r.lane, Ce.lanes |= s, ir |= s, r = r.next; while (r !== t) } else r === null && (n.lanes = 0); return [e.memoizedState, n.dispatch] } function Du(t) { var e = Ht(), n = e.queue; if (n === null) throw Error(R(311)); n.lastRenderedReducer = t; var i = n.dispatch, r = n.pending, s = e.memoizedState; if (r !== null) { n.pending = null; var o = r = r.next; do s = t(s, o.action), o = o.next; while (o !== r); en(s, e.memoizedState) || (wt = !0), e.memoizedState = s, e.baseQueue === null && (e.baseState = s), n.lastRenderedState = s } return [s, i] } function Fx() { } function Ix(t, e) { var n = Ce, i = Ht(), r = e(), s = !en(i.memoizedState, r); if (s && (i.memoizedState = r, wt = !0), i = i.queue, Ah(Bx.bind(null, n, i, t), [t]), i.getSnapshot !== e || s || Ue !== null && Ue.memoizedState.tag & 1) { if (n.flags |= 2048, Mo(9, zx.bind(null, n, i, r, e), void 0, null), Ge === null) throw Error(R(349)); nr & 30 || Vx(n, e, r) } return r } function Vx(t, e, n) { t.flags |= 16384, t = { getSnapshot: e, value: n }, e = Ce.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, Ce.updateQueue = e, e.stores = [t]) : (n = e.stores, n === null ? e.stores = [t] : n.push(t)) } function zx(t, e, n, i) { e.value = n, e.getSnapshot = i, Hx(e) && Wx(t) } function Bx(t, e, n) { return n(function () { Hx(e) && Wx(t) }) } function Hx(t) { var e = t.getSnapshot; t = t.value; try { var n = e(); return !en(t, n) } catch { return !0 } } function Wx(t) { var e = Vn(t, 1); e !== null && Zt(e, t, 1, -1) } function Im(t) { var e = an(); return typeof t == "function" && (t = t()), e.memoizedState = e.baseState = t, t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Co, lastRenderedState: t }, e.queue = t, t = t.dispatch = ek.bind(null, Ce, t), [e.memoizedState, t] } function Mo(t, e, n, i) { return t = { tag: t, create: e, destroy: n, deps: i, next: null }, e = Ce.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, Ce.updateQueue = e, e.lastEffect = t.next = t) : (n = e.lastEffect, n === null ? e.lastEffect = t.next = t : (i = n.next, n.next = t, t.next = i, e.lastEffect = t)), t } function $x() { return Ht().memoizedState } function fl(t, e, n, i) { var r = an(); Ce.flags |= t, r.memoizedState = Mo(1 | e, n, void 0, i === void 0 ? null : i) } function Pc(t, e, n, i) { var r = Ht(); i = i === void 0 ? null : i; var s = void 0; if (He !== null) { var o = He.memoizedState; if (s = o.destroy, i !== null && Rh(i, o.deps)) { r.memoizedState = Mo(e, n, s, i); return } } Ce.flags |= t, r.memoizedState = Mo(1 | e, n, s, i) } function Vm(t, e) { return fl(8390656, 8, t, e) } function Ah(t, e) { return Pc(2048, 8, t, e) } function Ux(t, e) { return Pc(4, 2, t, e) } function Yx(t, e) { return Pc(4, 4, t, e) } function Kx(t, e) { if (typeof e == "function") return t = t(), e(t), function () { e(null) }; if (e != null) return t = t(), e.current = t, function () { e.current = null } } function Xx(t, e, n) { return n = n != null ? n.concat([t]) : null, Pc(4, 4, Kx.bind(null, e, t), n) } function Nh() { } function Gx(t, e) { var n = Ht(); e = e === void 0 ? null : e; var i = n.memoizedState; return i !== null && e !== null && Rh(e, i[1]) ? i[0] : (n.memoizedState = [t, e], t) } function Qx(t, e) { var n = Ht(); e = e === void 0 ? null : e; var i = n.memoizedState; return i !== null && e !== null && Rh(e, i[1]) ? i[0] : (t = t(), n.memoizedState = [t, e], t) } function qx(t, e, n) { return nr & 21 ? (en(n, e) || (n = ex(), Ce.lanes |= n, ir |= n, t.baseState = !0), e) : (t.baseState && (t.baseState = !1, wt = !0), t.memoizedState = n) } function ZS(t, e) { var n = ue; ue = n !== 0 && 4 > n ? n : 4, t(!0); var i = Tu.transition; Tu.transition = {}; try { t(!1), e() } finally { ue = n, Tu.transition = i } } function Zx() { return Ht().memoizedState } function JS(t, e, n) { var i = pi(t); if (n = { lane: i, action: n, hasEagerState: !1, eagerState: null, next: null }, Jx(t)) e1(e, n); else if (n = Dx(t, e, n, i), n !== null) { var r = ft(); Zt(n, t, i, r), t1(n, e, i) } } function ek(t, e, n) { var i = pi(t), r = { lane: i, action: n, hasEagerState: !1, eagerState: null, next: null }; if (Jx(t)) e1(e, r); else { var s = t.alternate; if (t.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer, s !== null)) try { var o = e.lastRenderedState, a = s(o, n); if (r.hasEagerState = !0, r.eagerState = a, en(a, o)) { var l = e.interleaved; l === null ? (r.next = r, Mh(e)) : (r.next = l.next, l.next = r), e.interleaved = r; return } } catch { } finally { } n = Dx(t, e, r, i), n !== null && (r = ft(), Zt(n, t, i, r), t1(n, e, i)) } } function Jx(t) { var e = t.alternate; return t === Ce || e !== null && e === Ce } function e1(t, e) { Ws = Wl = !0; var n = t.pending; n === null ? e.next = e : (e.next = n.next, n.next = e), t.pending = e } function t1(t, e, n) { if (n & 4194240) { var i = e.lanes; i &= t.pendingLanes, n |= i, e.lanes = n, hh(t, n) } } var $l = { readContext: Bt, useCallback: nt, useContext: nt, useEffect: nt, useImperativeHandle: nt, useInsertionEffect: nt, useLayoutEffect: nt, useMemo: nt, useReducer: nt, useRef: nt, useState: nt, useDebugValue: nt, useDeferredValue: nt, useTransition: nt, useMutableSource: nt, useSyncExternalStore: nt, useId: nt, unstable_isNewReconciler: !1 }, tk = { readContext: Bt, useCallback: function (t, e) { return an().memoizedState = [t, e === void 0 ? null : e], t }, useContext: Bt, useEffect: Vm, useImperativeHandle: function (t, e, n) { return n = n != null ? n.concat([t]) : null, fl(4194308, 4, Kx.bind(null, e, t), n) }, useLayoutEffect: function (t, e) { return fl(4194308, 4, t, e) }, useInsertionEffect: function (t, e) { return fl(4, 2, t, e) }, useMemo: function (t, e) { var n = an(); return e = e === void 0 ? null : e, t = t(), n.memoizedState = [t, e], t }, useReducer: function (t, e, n) { var i = an(); return e = n !== void 0 ? n(e) : e, i.memoizedState = i.baseState = e, t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: t, lastRenderedState: e }, i.queue = t, t = t.dispatch = JS.bind(null, Ce, t), [i.memoizedState, t] }, useRef: function (t) { var e = an(); return t = { current: t }, e.memoizedState = t }, useState: Im, useDebugValue: Nh, useDeferredValue: function (t) { return an().memoizedState = t }, useTransition: function () { var t = Im(!1), e = t[0]; return t = ZS.bind(null, t[1]), an().memoizedState = t, [e, t] }, useMutableSource: function () { }, useSyncExternalStore: function (t, e, n) { var i = Ce, r = an(); if (xe) { if (n === void 0) throw Error(R(407)); n = n() } else { if (n = e(), Ge === null) throw Error(R(349)); nr & 30 || Vx(i, e, n) } r.memoizedState = n; var s = { value: n, getSnapshot: e }; return r.queue = s, Vm(Bx.bind(null, i, s, t), [t]), i.flags |= 2048, Mo(9, zx.bind(null, i, s, n, e), void 0, null), n }, useId: function () { var t = an(), e = Ge.identifierPrefix; if (xe) { var n = Dn, i = En; n = (i & ~(1 << 32 - qt(i) - 1)).toString(32) + n, e = ":" + e + "R" + n, n = Po++, 0 < n && (e += "H" + n.toString(32)), e += ":" } else n = qS++, e = ":" + e + "r" + n.toString(32) + ":"; return t.memoizedState = e }, unstable_isNewReconciler: !1 }, nk = { readContext: Bt, useCallback: Gx, useContext: Bt, useEffect: Ah, useImperativeHandle: Xx, useInsertionEffect: Ux, useLayoutEffect: Yx, useMemo: Qx, useReducer: Eu, useRef: $x, useState: function () { return Eu(Co) }, useDebugValue: Nh, useDeferredValue: function (t) { var e = Ht(); return qx(e, He.memoizedState, t) }, useTransition: function () { var t = Eu(Co)[0], e = Ht().memoizedState; return [t, e] }, useMutableSource: Fx, useSyncExternalStore: Ix, useId: Zx, unstable_isNewReconciler: !1 }, ik = { readContext: Bt, useCallback: Gx, useContext: Bt, useEffect: Ah, useImperativeHandle: Xx, useInsertionEffect: Ux, useLayoutEffect: Yx, useMemo: Qx, useReducer: Du, useRef: $x, useState: function () { return Du(Co) }, useDebugValue: Nh, useDeferredValue: function (t) { var e = Ht(); return He === null ? e.memoizedState = t : qx(e, He.memoizedState, t) }, useTransition: function () { var t = Du(Co)[0], e = Ht().memoizedState; return [t, e] }, useMutableSource: Fx, useSyncExternalStore: Ix, useId: Zx, unstable_isNewReconciler: !1 }; function Qr(t, e) {
    try { var n = "", i = e; do n += O2(i), i = i.return; while (i); var r = n } catch (s) {
        r = `
Error generating stack: `+ s.message + `
`+ s.stack
    } return { value: t, source: e, stack: r, digest: null }
} function Ou(t, e, n) { return { value: t, source: null, stack: n ?? null, digest: e ?? null } } function Qd(t, e) { try { console.error(e.value) } catch (n) { setTimeout(function () { throw n }) } } var rk = typeof WeakMap == "function" ? WeakMap : Map; function n1(t, e, n) { n = An(-1, n), n.tag = 3, n.payload = { element: null }; var i = e.value; return n.callback = function () { Yl || (Yl = !0, af = i), Qd(t, e) }, n } function i1(t, e, n) { n = An(-1, n), n.tag = 3; var i = t.type.getDerivedStateFromError; if (typeof i == "function") { var r = e.value; n.payload = function () { return i(r) }, n.callback = function () { Qd(t, e) } } var s = t.stateNode; return s !== null && typeof s.componentDidCatch == "function" && (n.callback = function () { Qd(t, e), typeof i != "function" && (hi === null ? hi = new Set([this]) : hi.add(this)); var o = e.stack; this.componentDidCatch(e.value, { componentStack: o !== null ? o : "" }) }), n } function zm(t, e, n) { var i = t.pingCache; if (i === null) { i = t.pingCache = new rk; var r = new Set; i.set(e, r) } else r = i.get(e), r === void 0 && (r = new Set, i.set(e, r)); r.has(n) || (r.add(n), t = vk.bind(null, t, e, n), e.then(t, t)) } function Bm(t) { do { var e; if ((e = t.tag === 13) && (e = t.memoizedState, e = e !== null ? e.dehydrated !== null : !0), e) return t; t = t.return } while (t !== null); return null } function Hm(t, e, n, i, r) { return t.mode & 1 ? (t.flags |= 65536, t.lanes = r, t) : (t === e ? t.flags |= 65536 : (t.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (e = An(-1, 1), e.tag = 2, fi(n, e, 1))), n.lanes |= 1), t) } var sk = Bn.ReactCurrentOwner, wt = !1; function dt(t, e, n, i) { e.child = t === null ? Ax(e, null, n, i) : Xr(e, t.child, n, i) } function Wm(t, e, n, i, r) { n = n.render; var s = e.ref; return Br(e, r), i = Lh(t, e, n, i, s, r), n = jh(), t !== null && !wt ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~r, zn(t, e, r)) : (xe && n && bh(e), e.flags |= 1, dt(t, e, i, r), e.child) } function $m(t, e, n, i, r) { if (t === null) { var s = n.type; return typeof s == "function" && !$h(s) && s.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (e.tag = 15, e.type = s, r1(t, e, s, i, r)) : (t = gl(n.type, null, i, e, e.mode, r), t.ref = e.ref, t.return = e, e.child = t) } if (s = t.child, !(t.lanes & r)) { var o = s.memoizedProps; if (n = n.compare, n = n !== null ? n : xo, n(o, i) && t.ref === e.ref) return zn(t, e, r) } return e.flags |= 1, t = mi(s, i), t.ref = e.ref, t.return = e, e.child = t } function r1(t, e, n, i, r) { if (t !== null) { var s = t.memoizedProps; if (xo(s, i) && t.ref === e.ref) if (wt = !1, e.pendingProps = i = s, (t.lanes & r) !== 0) t.flags & 131072 && (wt = !0); else return e.lanes = t.lanes, zn(t, e, r) } return qd(t, e, n, i, r) } function s1(t, e, n) { var i = e.pendingProps, r = i.children, s = t !== null ? t.memoizedState : null; if (i.mode === "hidden") if (!(e.mode & 1)) e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, fe(Or, Ct), Ct |= n; else { if (!(n & 1073741824)) return t = s !== null ? s.baseLanes | n : n, e.lanes = e.childLanes = 1073741824, e.memoizedState = { baseLanes: t, cachePool: null, transitions: null }, e.updateQueue = null, fe(Or, Ct), Ct |= t, null; e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, i = s !== null ? s.baseLanes : n, fe(Or, Ct), Ct |= i } else s !== null ? (i = s.baseLanes | n, e.memoizedState = null) : i = n, fe(Or, Ct), Ct |= i; return dt(t, e, r, n), e.child } function o1(t, e) { var n = e.ref; (t === null && n !== null || t !== null && t.ref !== n) && (e.flags |= 512, e.flags |= 2097152) } function qd(t, e, n, i, r) { var s = _t(n) ? er : lt.current; return s = Yr(e, s), Br(e, r), n = Lh(t, e, n, i, s, r), i = jh(), t !== null && !wt ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~r, zn(t, e, r)) : (xe && i && bh(e), e.flags |= 1, dt(t, e, n, r), e.child) } function Um(t, e, n, i, r) { if (_t(n)) { var s = !0; Nl(e) } else s = !1; if (Br(e, r), e.stateNode === null) hl(t, e), Lx(e, n, i), Gd(e, n, i, r), i = !0; else if (t === null) { var o = e.stateNode, a = e.memoizedProps; o.props = a; var l = o.context, c = n.contextType; typeof c == "object" && c !== null ? c = Bt(c) : (c = _t(n) ? er : lt.current, c = Yr(e, c)); var u = n.getDerivedStateFromProps, d = typeof u == "function" || typeof o.getSnapshotBeforeUpdate == "function"; d || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== i || l !== c) && Nm(e, o, i, c), qn = !1; var f = e.memoizedState; o.state = f, Bl(e, i, o, r), l = e.memoizedState, a !== i || f !== l || bt.current || qn ? (typeof u == "function" && (Xd(e, n, u, i), l = e.memoizedState), (a = qn || Am(e, n, a, i, f, l, c)) ? (d || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = i, e.memoizedState = l), o.props = i, o.state = l, o.context = c, i = a) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), i = !1) } else { o = e.stateNode, Ox(t, e), a = e.memoizedProps, c = e.type === e.elementType ? a : Yt(e.type, a), o.props = c, d = e.pendingProps, f = o.context, l = n.contextType, typeof l == "object" && l !== null ? l = Bt(l) : (l = _t(n) ? er : lt.current, l = Yr(e, l)); var h = n.getDerivedStateFromProps; (u = typeof h == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== d || f !== l) && Nm(e, o, i, l), qn = !1, f = e.memoizedState, o.state = f, Bl(e, i, o, r); var m = e.memoizedState; a !== d || f !== m || bt.current || qn ? (typeof h == "function" && (Xd(e, n, h, i), m = e.memoizedState), (c = qn || Am(e, n, c, i, f, m, l) || !1) ? (u || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(i, m, l), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(i, m, l)), typeof o.componentDidUpdate == "function" && (e.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && f === t.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && f === t.memoizedState || (e.flags |= 1024), e.memoizedProps = i, e.memoizedState = m), o.props = i, o.state = m, o.context = l, i = c) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && f === t.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && f === t.memoizedState || (e.flags |= 1024), i = !1) } return Zd(t, e, n, i, s, r) } function Zd(t, e, n, i, r, s) { o1(t, e); var o = (e.flags & 128) !== 0; if (!i && !o) return r && Dm(e, n, !1), zn(t, e, s); i = e.stateNode, sk.current = e; var a = o && typeof n.getDerivedStateFromError != "function" ? null : i.render(); return e.flags |= 1, t !== null && o ? (e.child = Xr(e, t.child, null, s), e.child = Xr(e, null, a, s)) : dt(t, e, a, s), e.memoizedState = i.state, r && Dm(e, n, !0), e.child } function a1(t) { var e = t.stateNode; e.pendingContext ? Em(t, e.pendingContext, e.pendingContext !== e.context) : e.context && Em(t, e.context, !1), Eh(t, e.containerInfo) } function Ym(t, e, n, i, r) { return Kr(), Sh(r), e.flags |= 256, dt(t, e, n, i), e.child } var Jd = { dehydrated: null, treeContext: null, retryLane: 0 }; function ef(t) { return { baseLanes: t, cachePool: null, transitions: null } } function l1(t, e, n) { var i = e.pendingProps, r = Se.current, s = !1, o = (e.flags & 128) !== 0, a; if ((a = o) || (a = t !== null && t.memoizedState === null ? !1 : (r & 2) !== 0), a ? (s = !0, e.flags &= -129) : (t === null || t.memoizedState !== null) && (r |= 1), fe(Se, r & 1), t === null) return Yd(e), t = e.memoizedState, t !== null && (t = t.dehydrated, t !== null) ? (e.mode & 1 ? t.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1, null) : (o = i.children, t = i.fallback, s ? (i = e.mode, s = e.child, o = { mode: "hidden", children: o }, !(i & 1) && s !== null ? (s.childLanes = 0, s.pendingProps = o) : s = Tc(o, i, 0, null), t = Qi(t, i, n, null), s.return = e, t.return = e, s.sibling = t, e.child = s, e.child.memoizedState = ef(n), e.memoizedState = Jd, t) : Fh(e, o)); if (r = t.memoizedState, r !== null && (a = r.dehydrated, a !== null)) return ok(t, e, o, i, a, r, n); if (s) { s = i.fallback, o = e.mode, r = t.child, a = r.sibling; var l = { mode: "hidden", children: i.children }; return !(o & 1) && e.child !== r ? (i = e.child, i.childLanes = 0, i.pendingProps = l, e.deletions = null) : (i = mi(r, l), i.subtreeFlags = r.subtreeFlags & 14680064), a !== null ? s = mi(a, s) : (s = Qi(s, o, n, null), s.flags |= 2), s.return = e, i.return = e, i.sibling = s, e.child = i, i = s, s = e.child, o = t.child.memoizedState, o = o === null ? ef(n) : { baseLanes: o.baseLanes | n, cachePool: null, transitions: o.transitions }, s.memoizedState = o, s.childLanes = t.childLanes & ~n, e.memoizedState = Jd, i } return s = t.child, t = s.sibling, i = mi(s, { mode: "visible", children: i.children }), !(e.mode & 1) && (i.lanes = n), i.return = e, i.sibling = null, t !== null && (n = e.deletions, n === null ? (e.deletions = [t], e.flags |= 16) : n.push(t)), e.child = i, e.memoizedState = null, i } function Fh(t, e) { return e = Tc({ mode: "visible", children: e }, t.mode, 0, null), e.return = t, t.child = e } function Ma(t, e, n, i) { return i !== null && Sh(i), Xr(e, t.child, null, n), t = Fh(e, e.pendingProps.children), t.flags |= 2, e.memoizedState = null, t } function ok(t, e, n, i, r, s, o) { if (n) return e.flags & 256 ? (e.flags &= -257, i = Ou(Error(R(422))), Ma(t, e, o, i)) : e.memoizedState !== null ? (e.child = t.child, e.flags |= 128, null) : (s = i.fallback, r = e.mode, i = Tc({ mode: "visible", children: i.children }, r, 0, null), s = Qi(s, r, o, null), s.flags |= 2, i.return = e, s.return = e, i.sibling = s, e.child = i, e.mode & 1 && Xr(e, t.child, null, o), e.child.memoizedState = ef(o), e.memoizedState = Jd, s); if (!(e.mode & 1)) return Ma(t, e, o, null); if (r.data === "$!") { if (i = r.nextSibling && r.nextSibling.dataset, i) var a = i.dgst; return i = a, s = Error(R(419)), i = Ou(s, i, void 0), Ma(t, e, o, i) } if (a = (o & t.childLanes) !== 0, wt || a) { if (i = Ge, i !== null) { switch (o & -o) { case 4: r = 2; break; case 16: r = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: r = 32; break; case 536870912: r = 268435456; break; default: r = 0 }r = r & (i.suspendedLanes | o) ? 0 : r, r !== 0 && r !== s.retryLane && (s.retryLane = r, Vn(t, r), Zt(i, t, r, -1)) } return Wh(), i = Ou(Error(R(421))), Ma(t, e, o, i) } return r.data === "$?" ? (e.flags |= 128, e.child = t.child, e = xk.bind(null, t), r._reactRetry = e, null) : (t = s.treeContext, Tt = di(r.nextSibling), Dt = e, xe = !0, Gt = null, t !== null && (Ft[It++] = En, Ft[It++] = Dn, Ft[It++] = tr, En = t.id, Dn = t.overflow, tr = e), e = Fh(e, i.children), e.flags |= 4096, e) } function Km(t, e, n) { t.lanes |= e; var i = t.alternate; i !== null && (i.lanes |= e), Kd(t.return, e, n) } function Ru(t, e, n, i, r) { var s = t.memoizedState; s === null ? t.memoizedState = { isBackwards: e, rendering: null, renderingStartTime: 0, last: i, tail: n, tailMode: r } : (s.isBackwards = e, s.rendering = null, s.renderingStartTime = 0, s.last = i, s.tail = n, s.tailMode = r) } function c1(t, e, n) { var i = e.pendingProps, r = i.revealOrder, s = i.tail; if (dt(t, e, i.children, n), i = Se.current, i & 2) i = i & 1 | 2, e.flags |= 128; else { if (t !== null && t.flags & 128) e: for (t = e.child; t !== null;) { if (t.tag === 13) t.memoizedState !== null && Km(t, n, e); else if (t.tag === 19) Km(t, n, e); else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break e; for (; t.sibling === null;) { if (t.return === null || t.return === e) break e; t = t.return } t.sibling.return = t.return, t = t.sibling } i &= 1 } if (fe(Se, i), !(e.mode & 1)) e.memoizedState = null; else switch (r) { case "forwards": for (n = e.child, r = null; n !== null;)t = n.alternate, t !== null && Hl(t) === null && (r = n), n = n.sibling; n = r, n === null ? (r = e.child, e.child = null) : (r = n.sibling, n.sibling = null), Ru(e, !1, r, n, s); break; case "backwards": for (n = null, r = e.child, e.child = null; r !== null;) { if (t = r.alternate, t !== null && Hl(t) === null) { e.child = r; break } t = r.sibling, r.sibling = n, n = r, r = t } Ru(e, !0, n, null, s); break; case "together": Ru(e, !1, null, null, void 0); break; default: e.memoizedState = null }return e.child } function hl(t, e) { !(e.mode & 1) && t !== null && (t.alternate = null, e.alternate = null, e.flags |= 2) } function zn(t, e, n) { if (t !== null && (e.dependencies = t.dependencies), ir |= e.lanes, !(n & e.childLanes)) return null; if (t !== null && e.child !== t.child) throw Error(R(153)); if (e.child !== null) { for (t = e.child, n = mi(t, t.pendingProps), e.child = n, n.return = e; t.sibling !== null;)t = t.sibling, n = n.sibling = mi(t, t.pendingProps), n.return = e; n.sibling = null } return e.child } function ak(t, e, n) { switch (e.tag) { case 3: a1(e), Kr(); break; case 5: Nx(e); break; case 1: _t(e.type) && Nl(e); break; case 4: Eh(e, e.stateNode.containerInfo); break; case 10: var i = e.type._context, r = e.memoizedProps.value; fe(Vl, i._currentValue), i._currentValue = r; break; case 13: if (i = e.memoizedState, i !== null) return i.dehydrated !== null ? (fe(Se, Se.current & 1), e.flags |= 128, null) : n & e.child.childLanes ? l1(t, e, n) : (fe(Se, Se.current & 1), t = zn(t, e, n), t !== null ? t.sibling : null); fe(Se, Se.current & 1); break; case 19: if (i = (n & e.childLanes) !== 0, t.flags & 128) { if (i) return c1(t, e, n); e.flags |= 128 } if (r = e.memoizedState, r !== null && (r.rendering = null, r.tail = null, r.lastEffect = null), fe(Se, Se.current), i) break; return null; case 22: case 23: return e.lanes = 0, s1(t, e, n) }return zn(t, e, n) } var u1, tf, d1, f1; u1 = function (t, e) { for (var n = e.child; n !== null;) { if (n.tag === 5 || n.tag === 6) t.appendChild(n.stateNode); else if (n.tag !== 4 && n.child !== null) { n.child.return = n, n = n.child; continue } if (n === e) break; for (; n.sibling === null;) { if (n.return === null || n.return === e) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }; tf = function () { }; d1 = function (t, e, n, i) { var r = t.memoizedProps; if (r !== i) { t = e.stateNode, Yi(pn.current); var s = null; switch (n) { case "input": r = Sd(t, r), i = Sd(t, i), s = []; break; case "select": r = Me({}, r, { value: void 0 }), i = Me({}, i, { value: void 0 }), s = []; break; case "textarea": r = Cd(t, r), i = Cd(t, i), s = []; break; default: typeof r.onClick != "function" && typeof i.onClick == "function" && (t.onclick = jl) }Td(n, i); var o; n = null; for (c in r) if (!i.hasOwnProperty(c) && r.hasOwnProperty(c) && r[c] != null) if (c === "style") { var a = r[c]; for (o in a) a.hasOwnProperty(o) && (n || (n = {}), n[o] = "") } else c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (fo.hasOwnProperty(c) ? s || (s = []) : (s = s || []).push(c, null)); for (c in i) { var l = i[c]; if (a = r != null ? r[c] : void 0, i.hasOwnProperty(c) && l !== a && (l != null || a != null)) if (c === "style") if (a) { for (o in a) !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (n || (n = {}), n[o] = ""); for (o in l) l.hasOwnProperty(o) && a[o] !== l[o] && (n || (n = {}), n[o] = l[o]) } else n || (s || (s = []), s.push(c, n)), n = l; else c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (s = s || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (s = s || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (fo.hasOwnProperty(c) ? (l != null && c === "onScroll" && he("scroll", t), s || a === l || (s = [])) : (s = s || []).push(c, l)) } n && (s = s || []).push("style", n); var c = s; (e.updateQueue = c) && (e.flags |= 4) } }; f1 = function (t, e, n, i) { n !== i && (e.flags |= 4) }; function ys(t, e) { if (!xe) switch (t.tailMode) { case "hidden": e = t.tail; for (var n = null; e !== null;)e.alternate !== null && (n = e), e = e.sibling; n === null ? t.tail = null : n.sibling = null; break; case "collapsed": n = t.tail; for (var i = null; n !== null;)n.alternate !== null && (i = n), n = n.sibling; i === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : i.sibling = null } } function it(t) { var e = t.alternate !== null && t.alternate.child === t.child, n = 0, i = 0; if (e) for (var r = t.child; r !== null;)n |= r.lanes | r.childLanes, i |= r.subtreeFlags & 14680064, i |= r.flags & 14680064, r.return = t, r = r.sibling; else for (r = t.child; r !== null;)n |= r.lanes | r.childLanes, i |= r.subtreeFlags, i |= r.flags, r.return = t, r = r.sibling; return t.subtreeFlags |= i, t.childLanes = n, e } function lk(t, e, n) { var i = e.pendingProps; switch (_h(e), e.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return it(e), null; case 1: return _t(e.type) && Al(), it(e), null; case 3: return i = e.stateNode, Gr(), ge(bt), ge(lt), Oh(), i.pendingContext && (i.context = i.pendingContext, i.pendingContext = null), (t === null || t.child === null) && (Pa(e) ? e.flags |= 4 : t === null || t.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024, Gt !== null && (uf(Gt), Gt = null))), tf(t, e), it(e), null; case 5: Dh(e); var r = Yi(ko.current); if (n = e.type, t !== null && e.stateNode != null) d1(t, e, n, i, r), t.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152); else { if (!i) { if (e.stateNode === null) throw Error(R(166)); return it(e), null } if (t = Yi(pn.current), Pa(e)) { i = e.stateNode, n = e.type; var s = e.memoizedProps; switch (i[fn] = e, i[_o] = s, t = (e.mode & 1) !== 0, n) { case "dialog": he("cancel", i), he("close", i); break; case "iframe": case "object": case "embed": he("load", i); break; case "video": case "audio": for (r = 0; r < Rs.length; r++)he(Rs[r], i); break; case "source": he("error", i); break; case "img": case "image": case "link": he("error", i), he("load", i); break; case "details": he("toggle", i); break; case "input": nm(i, s), he("invalid", i); break; case "select": i._wrapperState = { wasMultiple: !!s.multiple }, he("invalid", i); break; case "textarea": rm(i, s), he("invalid", i) }Td(n, s), r = null; for (var o in s) if (s.hasOwnProperty(o)) { var a = s[o]; o === "children" ? typeof a == "string" ? i.textContent !== a && (s.suppressHydrationWarning !== !0 && ka(i.textContent, a, t), r = ["children", a]) : typeof a == "number" && i.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && ka(i.textContent, a, t), r = ["children", "" + a]) : fo.hasOwnProperty(o) && a != null && o === "onScroll" && he("scroll", i) } switch (n) { case "input": ga(i), im(i, s, !0); break; case "textarea": ga(i), sm(i); break; case "select": case "option": break; default: typeof s.onClick == "function" && (i.onclick = jl) }i = r, e.updateQueue = i, i !== null && (e.flags |= 4) } else { o = r.nodeType === 9 ? r : r.ownerDocument, t === "http://www.w3.org/1999/xhtml" && (t = Vv(n)), t === "http://www.w3.org/1999/xhtml" ? n === "script" ? (t = o.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild)) : typeof i.is == "string" ? t = o.createElement(n, { is: i.is }) : (t = o.createElement(n), n === "select" && (o = t, i.multiple ? o.multiple = !0 : i.size && (o.size = i.size))) : t = o.createElementNS(t, n), t[fn] = e, t[_o] = i, u1(t, e, !1, !1), e.stateNode = t; e: { switch (o = Ed(n, i), n) { case "dialog": he("cancel", t), he("close", t), r = i; break; case "iframe": case "object": case "embed": he("load", t), r = i; break; case "video": case "audio": for (r = 0; r < Rs.length; r++)he(Rs[r], t); r = i; break; case "source": he("error", t), r = i; break; case "img": case "image": case "link": he("error", t), he("load", t), r = i; break; case "details": he("toggle", t), r = i; break; case "input": nm(t, i), r = Sd(t, i), he("invalid", t); break; case "option": r = i; break; case "select": t._wrapperState = { wasMultiple: !!i.multiple }, r = Me({}, i, { value: void 0 }), he("invalid", t); break; case "textarea": rm(t, i), r = Cd(t, i), he("invalid", t); break; default: r = i }Td(n, r), a = r; for (s in a) if (a.hasOwnProperty(s)) { var l = a[s]; s === "style" ? Hv(t, l) : s === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && zv(t, l)) : s === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && ho(t, l) : typeof l == "number" && ho(t, "" + l) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (fo.hasOwnProperty(s) ? l != null && s === "onScroll" && he("scroll", t) : l != null && ah(t, s, l, o)) } switch (n) { case "input": ga(t), im(t, i, !1); break; case "textarea": ga(t), sm(t); break; case "option": i.value != null && t.setAttribute("value", "" + wi(i.value)); break; case "select": t.multiple = !!i.multiple, s = i.value, s != null ? Fr(t, !!i.multiple, s, !1) : i.defaultValue != null && Fr(t, !!i.multiple, i.defaultValue, !0); break; default: typeof r.onClick == "function" && (t.onclick = jl) }switch (n) { case "button": case "input": case "select": case "textarea": i = !!i.autoFocus; break e; case "img": i = !0; break e; default: i = !1 } } i && (e.flags |= 4) } e.ref !== null && (e.flags |= 512, e.flags |= 2097152) } return it(e), null; case 6: if (t && e.stateNode != null) f1(t, e, t.memoizedProps, i); else { if (typeof i != "string" && e.stateNode === null) throw Error(R(166)); if (n = Yi(ko.current), Yi(pn.current), Pa(e)) { if (i = e.stateNode, n = e.memoizedProps, i[fn] = e, (s = i.nodeValue !== n) && (t = Dt, t !== null)) switch (t.tag) { case 3: ka(i.nodeValue, n, (t.mode & 1) !== 0); break; case 5: t.memoizedProps.suppressHydrationWarning !== !0 && ka(i.nodeValue, n, (t.mode & 1) !== 0) }s && (e.flags |= 4) } else i = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(i), i[fn] = e, e.stateNode = i } return it(e), null; case 13: if (ge(Se), i = e.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) { if (xe && Tt !== null && e.mode & 1 && !(e.flags & 128)) Ex(), Kr(), e.flags |= 98560, s = !1; else if (s = Pa(e), i !== null && i.dehydrated !== null) { if (t === null) { if (!s) throw Error(R(318)); if (s = e.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(R(317)); s[fn] = e } else Kr(), !(e.flags & 128) && (e.memoizedState = null), e.flags |= 4; it(e), s = !1 } else Gt !== null && (uf(Gt), Gt = null), s = !0; if (!s) return e.flags & 65536 ? e : null } return e.flags & 128 ? (e.lanes = n, e) : (i = i !== null, i !== (t !== null && t.memoizedState !== null) && i && (e.child.flags |= 8192, e.mode & 1 && (t === null || Se.current & 1 ? We === 0 && (We = 3) : Wh())), e.updateQueue !== null && (e.flags |= 4), it(e), null); case 4: return Gr(), tf(t, e), t === null && wo(e.stateNode.containerInfo), it(e), null; case 10: return Ch(e.type._context), it(e), null; case 17: return _t(e.type) && Al(), it(e), null; case 19: if (ge(Se), s = e.memoizedState, s === null) return it(e), null; if (i = (e.flags & 128) !== 0, o = s.rendering, o === null) if (i) ys(s, !1); else { if (We !== 0 || t !== null && t.flags & 128) for (t = e.child; t !== null;) { if (o = Hl(t), o !== null) { for (e.flags |= 128, ys(s, !1), i = o.updateQueue, i !== null && (e.updateQueue = i, e.flags |= 4), e.subtreeFlags = 0, i = n, n = e.child; n !== null;)s = n, t = i, s.flags &= 14680066, o = s.alternate, o === null ? (s.childLanes = 0, s.lanes = t, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = o.childLanes, s.lanes = o.lanes, s.child = o.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = o.memoizedProps, s.memoizedState = o.memoizedState, s.updateQueue = o.updateQueue, s.type = o.type, t = o.dependencies, s.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }), n = n.sibling; return fe(Se, Se.current & 1 | 2), e.child } t = t.sibling } s.tail !== null && Fe() > qr && (e.flags |= 128, i = !0, ys(s, !1), e.lanes = 4194304) } else { if (!i) if (t = Hl(o), t !== null) { if (e.flags |= 128, i = !0, n = t.updateQueue, n !== null && (e.updateQueue = n, e.flags |= 4), ys(s, !0), s.tail === null && s.tailMode === "hidden" && !o.alternate && !xe) return it(e), null } else 2 * Fe() - s.renderingStartTime > qr && n !== 1073741824 && (e.flags |= 128, i = !0, ys(s, !1), e.lanes = 4194304); s.isBackwards ? (o.sibling = e.child, e.child = o) : (n = s.last, n !== null ? n.sibling = o : e.child = o, s.last = o) } return s.tail !== null ? (e = s.tail, s.rendering = e, s.tail = e.sibling, s.renderingStartTime = Fe(), e.sibling = null, n = Se.current, fe(Se, i ? n & 1 | 2 : n & 1), e) : (it(e), null); case 22: case 23: return Hh(), i = e.memoizedState !== null, t !== null && t.memoizedState !== null !== i && (e.flags |= 8192), i && e.mode & 1 ? Ct & 1073741824 && (it(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : it(e), null; case 24: return null; case 25: return null }throw Error(R(156, e.tag)) } function ck(t, e) { switch (_h(e), e.tag) { case 1: return _t(e.type) && Al(), t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null; case 3: return Gr(), ge(bt), ge(lt), Oh(), t = e.flags, t & 65536 && !(t & 128) ? (e.flags = t & -65537 | 128, e) : null; case 5: return Dh(e), null; case 13: if (ge(Se), t = e.memoizedState, t !== null && t.dehydrated !== null) { if (e.alternate === null) throw Error(R(340)); Kr() } return t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null; case 19: return ge(Se), null; case 4: return Gr(), null; case 10: return Ch(e.type._context), null; case 22: case 23: return Hh(), null; case 24: return null; default: return null } } var Ta = !1, st = !1, uk = typeof WeakSet == "function" ? WeakSet : Set, N = null; function Dr(t, e) { var n = t.ref; if (n !== null) if (typeof n == "function") try { n(null) } catch (i) { De(t, e, i) } else n.current = null } function nf(t, e, n) { try { n() } catch (i) { De(t, e, i) } } var Xm = !1; function dk(t, e) { if (Vd = Ol, t = gx(), wh(t)) { if ("selectionStart" in t) var n = { start: t.selectionStart, end: t.selectionEnd }; else e: { n = (n = t.ownerDocument) && n.defaultView || window; var i = n.getSelection && n.getSelection(); if (i && i.rangeCount !== 0) { n = i.anchorNode; var r = i.anchorOffset, s = i.focusNode; i = i.focusOffset; try { n.nodeType, s.nodeType } catch { n = null; break e } var o = 0, a = -1, l = -1, c = 0, u = 0, d = t, f = null; t: for (; ;) { for (var h; d !== n || r !== 0 && d.nodeType !== 3 || (a = o + r), d !== s || i !== 0 && d.nodeType !== 3 || (l = o + i), d.nodeType === 3 && (o += d.nodeValue.length), (h = d.firstChild) !== null;)f = d, d = h; for (; ;) { if (d === t) break t; if (f === n && ++c === r && (a = o), f === s && ++u === i && (l = o), (h = d.nextSibling) !== null) break; d = f, f = d.parentNode } d = h } n = a === -1 || l === -1 ? null : { start: a, end: l } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (zd = { focusedElem: t, selectionRange: n }, Ol = !1, N = e; N !== null;)if (e = N, t = e.child, (e.subtreeFlags & 1028) !== 0 && t !== null) t.return = e, N = t; else for (; N !== null;) { e = N; try { var m = e.alternate; if (e.flags & 1024) switch (e.tag) { case 0: case 11: case 15: break; case 1: if (m !== null) { var p = m.memoizedProps, x = m.memoizedState, y = e.stateNode, g = y.getSnapshotBeforeUpdate(e.elementType === e.type ? p : Yt(e.type, p), x); y.__reactInternalSnapshotBeforeUpdate = g } break; case 3: var v = e.stateNode.containerInfo; v.nodeType === 1 ? v.textContent = "" : v.nodeType === 9 && v.documentElement && v.removeChild(v.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(R(163)) } } catch (b) { De(e, e.return, b) } if (t = e.sibling, t !== null) { t.return = e.return, N = t; break } N = e.return } return m = Xm, Xm = !1, m } function $s(t, e, n) { var i = e.updateQueue; if (i = i !== null ? i.lastEffect : null, i !== null) { var r = i = i.next; do { if ((r.tag & t) === t) { var s = r.destroy; r.destroy = void 0, s !== void 0 && nf(e, n, s) } r = r.next } while (r !== i) } } function Cc(t, e) { if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) { var n = e = e.next; do { if ((n.tag & t) === t) { var i = n.create; n.destroy = i() } n = n.next } while (n !== e) } } function rf(t) { var e = t.ref; if (e !== null) { var n = t.stateNode; switch (t.tag) { case 5: t = n; break; default: t = n }typeof e == "function" ? e(t) : e.current = t } } function h1(t) { var e = t.alternate; e !== null && (t.alternate = null, h1(e)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (e = t.stateNode, e !== null && (delete e[fn], delete e[_o], delete e[Wd], delete e[KS], delete e[XS])), t.stateNode = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null } function p1(t) { return t.tag === 5 || t.tag === 3 || t.tag === 4 } function Gm(t) { e: for (; ;) { for (; t.sibling === null;) { if (t.return === null || p1(t.return)) return null; t = t.return } for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18;) { if (t.flags & 2 || t.child === null || t.tag === 4) continue e; t.child.return = t, t = t.child } if (!(t.flags & 2)) return t.stateNode } } function sf(t, e, n) { var i = t.tag; if (i === 5 || i === 6) t = t.stateNode, e ? n.nodeType === 8 ? n.parentNode.insertBefore(t, e) : n.insertBefore(t, e) : (n.nodeType === 8 ? (e = n.parentNode, e.insertBefore(t, n)) : (e = n, e.appendChild(t)), n = n._reactRootContainer, n != null || e.onclick !== null || (e.onclick = jl)); else if (i !== 4 && (t = t.child, t !== null)) for (sf(t, e, n), t = t.sibling; t !== null;)sf(t, e, n), t = t.sibling } function of(t, e, n) { var i = t.tag; if (i === 5 || i === 6) t = t.stateNode, e ? n.insertBefore(t, e) : n.appendChild(t); else if (i !== 4 && (t = t.child, t !== null)) for (of(t, e, n), t = t.sibling; t !== null;)of(t, e, n), t = t.sibling } var Qe = null, Xt = !1; function Un(t, e, n) { for (n = n.child; n !== null;)m1(t, e, n), n = n.sibling } function m1(t, e, n) { if (hn && typeof hn.onCommitFiberUnmount == "function") try { hn.onCommitFiberUnmount(vc, n) } catch { } switch (n.tag) { case 5: st || Dr(n, e); case 6: var i = Qe, r = Xt; Qe = null, Un(t, e, n), Qe = i, Xt = r, Qe !== null && (Xt ? (t = Qe, n = n.stateNode, t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n)) : Qe.removeChild(n.stateNode)); break; case 18: Qe !== null && (Xt ? (t = Qe, n = n.stateNode, t.nodeType === 8 ? Pu(t.parentNode, n) : t.nodeType === 1 && Pu(t, n), yo(t)) : Pu(Qe, n.stateNode)); break; case 4: i = Qe, r = Xt, Qe = n.stateNode.containerInfo, Xt = !0, Un(t, e, n), Qe = i, Xt = r; break; case 0: case 11: case 14: case 15: if (!st && (i = n.updateQueue, i !== null && (i = i.lastEffect, i !== null))) { r = i = i.next; do { var s = r, o = s.destroy; s = s.tag, o !== void 0 && (s & 2 || s & 4) && nf(n, e, o), r = r.next } while (r !== i) } Un(t, e, n); break; case 1: if (!st && (Dr(n, e), i = n.stateNode, typeof i.componentWillUnmount == "function")) try { i.props = n.memoizedProps, i.state = n.memoizedState, i.componentWillUnmount() } catch (a) { De(n, e, a) } Un(t, e, n); break; case 21: Un(t, e, n); break; case 22: n.mode & 1 ? (st = (i = st) || n.memoizedState !== null, Un(t, e, n), st = i) : Un(t, e, n); break; default: Un(t, e, n) } } function Qm(t) { var e = t.updateQueue; if (e !== null) { t.updateQueue = null; var n = t.stateNode; n === null && (n = t.stateNode = new uk), e.forEach(function (i) { var r = wk.bind(null, t, i); n.has(i) || (n.add(i), i.then(r, r)) }) } } function Ut(t, e) { var n = e.deletions; if (n !== null) for (var i = 0; i < n.length; i++) { var r = n[i]; try { var s = t, o = e, a = o; e: for (; a !== null;) { switch (a.tag) { case 5: Qe = a.stateNode, Xt = !1; break e; case 3: Qe = a.stateNode.containerInfo, Xt = !0; break e; case 4: Qe = a.stateNode.containerInfo, Xt = !0; break e }a = a.return } if (Qe === null) throw Error(R(160)); m1(s, o, r), Qe = null, Xt = !1; var l = r.alternate; l !== null && (l.return = null), r.return = null } catch (c) { De(r, e, c) } } if (e.subtreeFlags & 12854) for (e = e.child; e !== null;)g1(e, t), e = e.sibling } function g1(t, e) { var n = t.alternate, i = t.flags; switch (t.tag) { case 0: case 11: case 14: case 15: if (Ut(e, t), sn(t), i & 4) { try { $s(3, t, t.return), Cc(3, t) } catch (p) { De(t, t.return, p) } try { $s(5, t, t.return) } catch (p) { De(t, t.return, p) } } break; case 1: Ut(e, t), sn(t), i & 512 && n !== null && Dr(n, n.return); break; case 5: if (Ut(e, t), sn(t), i & 512 && n !== null && Dr(n, n.return), t.flags & 32) { var r = t.stateNode; try { ho(r, "") } catch (p) { De(t, t.return, p) } } if (i & 4 && (r = t.stateNode, r != null)) { var s = t.memoizedProps, o = n !== null ? n.memoizedProps : s, a = t.type, l = t.updateQueue; if (t.updateQueue = null, l !== null) try { a === "input" && s.type === "radio" && s.name != null && Fv(r, s), Ed(a, o); var c = Ed(a, s); for (o = 0; o < l.length; o += 2) { var u = l[o], d = l[o + 1]; u === "style" ? Hv(r, d) : u === "dangerouslySetInnerHTML" ? zv(r, d) : u === "children" ? ho(r, d) : ah(r, u, d, c) } switch (a) { case "input": kd(r, s); break; case "textarea": Iv(r, s); break; case "select": var f = r._wrapperState.wasMultiple; r._wrapperState.wasMultiple = !!s.multiple; var h = s.value; h != null ? Fr(r, !!s.multiple, h, !1) : f !== !!s.multiple && (s.defaultValue != null ? Fr(r, !!s.multiple, s.defaultValue, !0) : Fr(r, !!s.multiple, s.multiple ? [] : "", !1)) }r[_o] = s } catch (p) { De(t, t.return, p) } } break; case 6: if (Ut(e, t), sn(t), i & 4) { if (t.stateNode === null) throw Error(R(162)); r = t.stateNode, s = t.memoizedProps; try { r.nodeValue = s } catch (p) { De(t, t.return, p) } } break; case 3: if (Ut(e, t), sn(t), i & 4 && n !== null && n.memoizedState.isDehydrated) try { yo(e.containerInfo) } catch (p) { De(t, t.return, p) } break; case 4: Ut(e, t), sn(t); break; case 13: Ut(e, t), sn(t), r = t.child, r.flags & 8192 && (s = r.memoizedState !== null, r.stateNode.isHidden = s, !s || r.alternate !== null && r.alternate.memoizedState !== null || (zh = Fe())), i & 4 && Qm(t); break; case 22: if (u = n !== null && n.memoizedState !== null, t.mode & 1 ? (st = (c = st) || u, Ut(e, t), st = c) : Ut(e, t), sn(t), i & 8192) { if (c = t.memoizedState !== null, (t.stateNode.isHidden = c) && !u && t.mode & 1) for (N = t, u = t.child; u !== null;) { for (d = N = u; N !== null;) { switch (f = N, h = f.child, f.tag) { case 0: case 11: case 14: case 15: $s(4, f, f.return); break; case 1: Dr(f, f.return); var m = f.stateNode; if (typeof m.componentWillUnmount == "function") { i = f, n = f.return; try { e = i, m.props = e.memoizedProps, m.state = e.memoizedState, m.componentWillUnmount() } catch (p) { De(i, n, p) } } break; case 5: Dr(f, f.return); break; case 22: if (f.memoizedState !== null) { Zm(d); continue } }h !== null ? (h.return = f, N = h) : Zm(d) } u = u.sibling } e: for (u = null, d = t; ;) { if (d.tag === 5) { if (u === null) { u = d; try { r = d.stateNode, c ? (s = r.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = d.stateNode, l = d.memoizedProps.style, o = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = Bv("display", o)) } catch (p) { De(t, t.return, p) } } } else if (d.tag === 6) { if (u === null) try { d.stateNode.nodeValue = c ? "" : d.memoizedProps } catch (p) { De(t, t.return, p) } } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === t) && d.child !== null) { d.child.return = d, d = d.child; continue } if (d === t) break e; for (; d.sibling === null;) { if (d.return === null || d.return === t) break e; u === d && (u = null), d = d.return } u === d && (u = null), d.sibling.return = d.return, d = d.sibling } } break; case 19: Ut(e, t), sn(t), i & 4 && Qm(t); break; case 21: break; default: Ut(e, t), sn(t) } } function sn(t) { var e = t.flags; if (e & 2) { try { e: { for (var n = t.return; n !== null;) { if (p1(n)) { var i = n; break e } n = n.return } throw Error(R(160)) } switch (i.tag) { case 5: var r = i.stateNode; i.flags & 32 && (ho(r, ""), i.flags &= -33); var s = Gm(t); of(t, s, r); break; case 3: case 4: var o = i.stateNode.containerInfo, a = Gm(t); sf(t, a, o); break; default: throw Error(R(161)) } } catch (l) { De(t, t.return, l) } t.flags &= -3 } e & 4096 && (t.flags &= -4097) } function fk(t, e, n) { N = t, y1(t) } function y1(t, e, n) { for (var i = (t.mode & 1) !== 0; N !== null;) { var r = N, s = r.child; if (r.tag === 22 && i) { var o = r.memoizedState !== null || Ta; if (!o) { var a = r.alternate, l = a !== null && a.memoizedState !== null || st; a = Ta; var c = st; if (Ta = o, (st = l) && !c) for (N = r; N !== null;)o = N, l = o.child, o.tag === 22 && o.memoizedState !== null ? Jm(r) : l !== null ? (l.return = o, N = l) : Jm(r); for (; s !== null;)N = s, y1(s), s = s.sibling; N = r, Ta = a, st = c } qm(t) } else r.subtreeFlags & 8772 && s !== null ? (s.return = r, N = s) : qm(t) } } function qm(t) { for (; N !== null;) { var e = N; if (e.flags & 8772) { var n = e.alternate; try { if (e.flags & 8772) switch (e.tag) { case 0: case 11: case 15: st || Cc(5, e); break; case 1: var i = e.stateNode; if (e.flags & 4 && !st) if (n === null) i.componentDidMount(); else { var r = e.elementType === e.type ? n.memoizedProps : Yt(e.type, n.memoizedProps); i.componentDidUpdate(r, n.memoizedState, i.__reactInternalSnapshotBeforeUpdate) } var s = e.updateQueue; s !== null && jm(e, s, i); break; case 3: var o = e.updateQueue; if (o !== null) { if (n = null, e.child !== null) switch (e.child.tag) { case 5: n = e.child.stateNode; break; case 1: n = e.child.stateNode }jm(e, o, n) } break; case 5: var a = e.stateNode; if (n === null && e.flags & 4) { n = a; var l = e.memoizedProps; switch (e.type) { case "button": case "input": case "select": case "textarea": l.autoFocus && n.focus(); break; case "img": l.src && (n.src = l.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (e.memoizedState === null) { var c = e.alternate; if (c !== null) { var u = c.memoizedState; if (u !== null) { var d = u.dehydrated; d !== null && yo(d) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(R(163)) }st || e.flags & 512 && rf(e) } catch (f) { De(e, e.return, f) } } if (e === t) { N = null; break } if (n = e.sibling, n !== null) { n.return = e.return, N = n; break } N = e.return } } function Zm(t) { for (; N !== null;) { var e = N; if (e === t) { N = null; break } var n = e.sibling; if (n !== null) { n.return = e.return, N = n; break } N = e.return } } function Jm(t) { for (; N !== null;) { var e = N; try { switch (e.tag) { case 0: case 11: case 15: var n = e.return; try { Cc(4, e) } catch (l) { De(e, n, l) } break; case 1: var i = e.stateNode; if (typeof i.componentDidMount == "function") { var r = e.return; try { i.componentDidMount() } catch (l) { De(e, r, l) } } var s = e.return; try { rf(e) } catch (l) { De(e, s, l) } break; case 5: var o = e.return; try { rf(e) } catch (l) { De(e, o, l) } } } catch (l) { De(e, e.return, l) } if (e === t) { N = null; break } var a = e.sibling; if (a !== null) { a.return = e.return, N = a; break } N = e.return } } var hk = Math.ceil, Ul = Bn.ReactCurrentDispatcher, Ih = Bn.ReactCurrentOwner, zt = Bn.ReactCurrentBatchConfig, oe = 0, Ge = null, Ve = null, qe = 0, Ct = 0, Or = Mi(0), We = 0, To = null, ir = 0, Mc = 0, Vh = 0, Us = null, vt = null, zh = 0, qr = 1 / 0, Pn = null, Yl = !1, af = null, hi = null, Ea = !1, ni = null, Kl = 0, Ys = 0, lf = null, pl = -1, ml = 0; function ft() { return oe & 6 ? Fe() : pl !== -1 ? pl : pl = Fe() } function pi(t) { return t.mode & 1 ? oe & 2 && qe !== 0 ? qe & -qe : QS.transition !== null ? (ml === 0 && (ml = ex()), ml) : (t = ue, t !== 0 || (t = window.event, t = t === void 0 ? 16 : ax(t.type)), t) : 1 } function Zt(t, e, n, i) { if (50 < Ys) throw Ys = 0, lf = null, Error(R(185)); Wo(t, n, i), (!(oe & 2) || t !== Ge) && (t === Ge && (!(oe & 2) && (Mc |= n), We === 4 && ei(t, qe)), St(t, i), n === 1 && oe === 0 && !(e.mode & 1) && (qr = Fe() + 500, Sc && Ti())) } function St(t, e) { var n = t.callbackNode; Q2(t, e); var i = Dl(t, t === Ge ? qe : 0); if (i === 0) n !== null && lm(n), t.callbackNode = null, t.callbackPriority = 0; else if (e = i & -i, t.callbackPriority !== e) { if (n != null && lm(n), e === 1) t.tag === 0 ? GS(eg.bind(null, t)) : Cx(eg.bind(null, t)), US(function () { !(oe & 6) && Ti() }), n = null; else { switch (tx(i)) { case 1: n = fh; break; case 4: n = Zv; break; case 16: n = El; break; case 536870912: n = Jv; break; default: n = El }n = P1(n, v1.bind(null, t)) } t.callbackPriority = e, t.callbackNode = n } } function v1(t, e) { if (pl = -1, ml = 0, oe & 6) throw Error(R(327)); var n = t.callbackNode; if (Hr() && t.callbackNode !== n) return null; var i = Dl(t, t === Ge ? qe : 0); if (i === 0) return null; if (i & 30 || i & t.expiredLanes || e) e = Xl(t, i); else { e = i; var r = oe; oe |= 2; var s = w1(); (Ge !== t || qe !== e) && (Pn = null, qr = Fe() + 500, Gi(t, e)); do try { gk(); break } catch (a) { x1(t, a) } while (1); Ph(), Ul.current = s, oe = r, Ve !== null ? e = 0 : (Ge = null, qe = 0, e = We) } if (e !== 0) { if (e === 2 && (r = jd(t), r !== 0 && (i = r, e = cf(t, r))), e === 1) throw n = To, Gi(t, 0), ei(t, i), St(t, Fe()), n; if (e === 6) ei(t, i); else { if (r = t.current.alternate, !(i & 30) && !pk(r) && (e = Xl(t, i), e === 2 && (s = jd(t), s !== 0 && (i = s, e = cf(t, s))), e === 1)) throw n = To, Gi(t, 0), ei(t, i), St(t, Fe()), n; switch (t.finishedWork = r, t.finishedLanes = i, e) { case 0: case 1: throw Error(R(345)); case 2: Vi(t, vt, Pn); break; case 3: if (ei(t, i), (i & 130023424) === i && (e = zh + 500 - Fe(), 10 < e)) { if (Dl(t, 0) !== 0) break; if (r = t.suspendedLanes, (r & i) !== i) { ft(), t.pingedLanes |= t.suspendedLanes & r; break } t.timeoutHandle = Hd(Vi.bind(null, t, vt, Pn), e); break } Vi(t, vt, Pn); break; case 4: if (ei(t, i), (i & 4194240) === i) break; for (e = t.eventTimes, r = -1; 0 < i;) { var o = 31 - qt(i); s = 1 << o, o = e[o], o > r && (r = o), i &= ~s } if (i = r, i = Fe() - i, i = (120 > i ? 120 : 480 > i ? 480 : 1080 > i ? 1080 : 1920 > i ? 1920 : 3e3 > i ? 3e3 : 4320 > i ? 4320 : 1960 * hk(i / 1960)) - i, 10 < i) { t.timeoutHandle = Hd(Vi.bind(null, t, vt, Pn), i); break } Vi(t, vt, Pn); break; case 5: Vi(t, vt, Pn); break; default: throw Error(R(329)) } } } return St(t, Fe()), t.callbackNode === n ? v1.bind(null, t) : null } function cf(t, e) { var n = Us; return t.current.memoizedState.isDehydrated && (Gi(t, e).flags |= 256), t = Xl(t, e), t !== 2 && (e = vt, vt = n, e !== null && uf(e)), t } function uf(t) { vt === null ? vt = t : vt.push.apply(vt, t) } function pk(t) { for (var e = t; ;) { if (e.flags & 16384) { var n = e.updateQueue; if (n !== null && (n = n.stores, n !== null)) for (var i = 0; i < n.length; i++) { var r = n[i], s = r.getSnapshot; r = r.value; try { if (!en(s(), r)) return !1 } catch { return !1 } } } if (n = e.child, e.subtreeFlags & 16384 && n !== null) n.return = e, e = n; else { if (e === t) break; for (; e.sibling === null;) { if (e.return === null || e.return === t) return !0; e = e.return } e.sibling.return = e.return, e = e.sibling } } return !0 } function ei(t, e) { for (e &= ~Vh, e &= ~Mc, t.suspendedLanes |= e, t.pingedLanes &= ~e, t = t.expirationTimes; 0 < e;) { var n = 31 - qt(e), i = 1 << n; t[n] = -1, e &= ~i } } function eg(t) { if (oe & 6) throw Error(R(327)); Hr(); var e = Dl(t, 0); if (!(e & 1)) return St(t, Fe()), null; var n = Xl(t, e); if (t.tag !== 0 && n === 2) { var i = jd(t); i !== 0 && (e = i, n = cf(t, i)) } if (n === 1) throw n = To, Gi(t, 0), ei(t, e), St(t, Fe()), n; if (n === 6) throw Error(R(345)); return t.finishedWork = t.current.alternate, t.finishedLanes = e, Vi(t, vt, Pn), St(t, Fe()), null } function Bh(t, e) { var n = oe; oe |= 1; try { return t(e) } finally { oe = n, oe === 0 && (qr = Fe() + 500, Sc && Ti()) } } function rr(t) { ni !== null && ni.tag === 0 && !(oe & 6) && Hr(); var e = oe; oe |= 1; var n = zt.transition, i = ue; try { if (zt.transition = null, ue = 1, t) return t() } finally { ue = i, zt.transition = n, oe = e, !(oe & 6) && Ti() } } function Hh() { Ct = Or.current, ge(Or) } function Gi(t, e) { t.finishedWork = null, t.finishedLanes = 0; var n = t.timeoutHandle; if (n !== -1 && (t.timeoutHandle = -1, $S(n)), Ve !== null) for (n = Ve.return; n !== null;) { var i = n; switch (_h(i), i.tag) { case 1: i = i.type.childContextTypes, i != null && Al(); break; case 3: Gr(), ge(bt), ge(lt), Oh(); break; case 5: Dh(i); break; case 4: Gr(); break; case 13: ge(Se); break; case 19: ge(Se); break; case 10: Ch(i.type._context); break; case 22: case 23: Hh() }n = n.return } if (Ge = t, Ve = t = mi(t.current, null), qe = Ct = e, We = 0, To = null, Vh = Mc = ir = 0, vt = Us = null, Ui !== null) { for (e = 0; e < Ui.length; e++)if (n = Ui[e], i = n.interleaved, i !== null) { n.interleaved = null; var r = i.next, s = n.pending; if (s !== null) { var o = s.next; s.next = r, i.next = o } n.pending = i } Ui = null } return t } function x1(t, e) { do { var n = Ve; try { if (Ph(), dl.current = $l, Wl) { for (var i = Ce.memoizedState; i !== null;) { var r = i.queue; r !== null && (r.pending = null), i = i.next } Wl = !1 } if (nr = 0, Ue = He = Ce = null, Ws = !1, Po = 0, Ih.current = null, n === null || n.return === null) { We = 1, To = e, Ve = null; break } e: { var s = t, o = n.return, a = n, l = e; if (e = qe, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") { var c = l, u = a, d = u.tag; if (!(u.mode & 1) && (d === 0 || d === 11 || d === 15)) { var f = u.alternate; f ? (u.updateQueue = f.updateQueue, u.memoizedState = f.memoizedState, u.lanes = f.lanes) : (u.updateQueue = null, u.memoizedState = null) } var h = Bm(o); if (h !== null) { h.flags &= -257, Hm(h, o, a, s, e), h.mode & 1 && zm(s, c, e), e = h, l = c; var m = e.updateQueue; if (m === null) { var p = new Set; p.add(l), e.updateQueue = p } else m.add(l); break e } else { if (!(e & 1)) { zm(s, c, e), Wh(); break e } l = Error(R(426)) } } else if (xe && a.mode & 1) { var x = Bm(o); if (x !== null) { !(x.flags & 65536) && (x.flags |= 256), Hm(x, o, a, s, e), Sh(Qr(l, a)); break e } } s = l = Qr(l, a), We !== 4 && (We = 2), Us === null ? Us = [s] : Us.push(s), s = o; do { switch (s.tag) { case 3: s.flags |= 65536, e &= -e, s.lanes |= e; var y = n1(s, l, e); Lm(s, y); break e; case 1: a = l; var g = s.type, v = s.stateNode; if (!(s.flags & 128) && (typeof g.getDerivedStateFromError == "function" || v !== null && typeof v.componentDidCatch == "function" && (hi === null || !hi.has(v)))) { s.flags |= 65536, e &= -e, s.lanes |= e; var b = i1(s, a, e); Lm(s, b); break e } }s = s.return } while (s !== null) } _1(n) } catch (_) { e = _, Ve === n && n !== null && (Ve = n = n.return); continue } break } while (1) } function w1() { var t = Ul.current; return Ul.current = $l, t === null ? $l : t } function Wh() { (We === 0 || We === 3 || We === 2) && (We = 4), Ge === null || !(ir & 268435455) && !(Mc & 268435455) || ei(Ge, qe) } function Xl(t, e) { var n = oe; oe |= 2; var i = w1(); (Ge !== t || qe !== e) && (Pn = null, Gi(t, e)); do try { mk(); break } catch (r) { x1(t, r) } while (1); if (Ph(), oe = n, Ul.current = i, Ve !== null) throw Error(R(261)); return Ge = null, qe = 0, We } function mk() { for (; Ve !== null;)b1(Ve) } function gk() { for (; Ve !== null && !B2();)b1(Ve) } function b1(t) { var e = k1(t.alternate, t, Ct); t.memoizedProps = t.pendingProps, e === null ? _1(t) : Ve = e, Ih.current = null } function _1(t) { var e = t; do { var n = e.alternate; if (t = e.return, e.flags & 32768) { if (n = ck(n, e), n !== null) { n.flags &= 32767, Ve = n; return } if (t !== null) t.flags |= 32768, t.subtreeFlags = 0, t.deletions = null; else { We = 6, Ve = null; return } } else if (n = lk(n, e, Ct), n !== null) { Ve = n; return } if (e = e.sibling, e !== null) { Ve = e; return } Ve = e = t } while (e !== null); We === 0 && (We = 5) } function Vi(t, e, n) { var i = ue, r = zt.transition; try { zt.transition = null, ue = 1, yk(t, e, n, i) } finally { zt.transition = r, ue = i } return null } function yk(t, e, n, i) { do Hr(); while (ni !== null); if (oe & 6) throw Error(R(327)); n = t.finishedWork; var r = t.finishedLanes; if (n === null) return null; if (t.finishedWork = null, t.finishedLanes = 0, n === t.current) throw Error(R(177)); t.callbackNode = null, t.callbackPriority = 0; var s = n.lanes | n.childLanes; if (q2(t, s), t === Ge && (Ve = Ge = null, qe = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || Ea || (Ea = !0, P1(El, function () { return Hr(), null })), s = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || s) { s = zt.transition, zt.transition = null; var o = ue; ue = 1; var a = oe; oe |= 4, Ih.current = null, dk(t, n), g1(n, t), FS(zd), Ol = !!Vd, zd = Vd = null, t.current = n, fk(n), H2(), oe = a, ue = o, zt.transition = s } else t.current = n; if (Ea && (Ea = !1, ni = t, Kl = r), s = t.pendingLanes, s === 0 && (hi = null), U2(n.stateNode), St(t, Fe()), e !== null) for (i = t.onRecoverableError, n = 0; n < e.length; n++)r = e[n], i(r.value, { componentStack: r.stack, digest: r.digest }); if (Yl) throw Yl = !1, t = af, af = null, t; return Kl & 1 && t.tag !== 0 && Hr(), s = t.pendingLanes, s & 1 ? t === lf ? Ys++ : (Ys = 0, lf = t) : Ys = 0, Ti(), null } function Hr() { if (ni !== null) { var t = tx(Kl), e = zt.transition, n = ue; try { if (zt.transition = null, ue = 16 > t ? 16 : t, ni === null) var i = !1; else { if (t = ni, ni = null, Kl = 0, oe & 6) throw Error(R(331)); var r = oe; for (oe |= 4, N = t.current; N !== null;) { var s = N, o = s.child; if (N.flags & 16) { var a = s.deletions; if (a !== null) { for (var l = 0; l < a.length; l++) { var c = a[l]; for (N = c; N !== null;) { var u = N; switch (u.tag) { case 0: case 11: case 15: $s(8, u, s) }var d = u.child; if (d !== null) d.return = u, N = d; else for (; N !== null;) { u = N; var f = u.sibling, h = u.return; if (h1(u), u === c) { N = null; break } if (f !== null) { f.return = h, N = f; break } N = h } } } var m = s.alternate; if (m !== null) { var p = m.child; if (p !== null) { m.child = null; do { var x = p.sibling; p.sibling = null, p = x } while (p !== null) } } N = s } } if (s.subtreeFlags & 2064 && o !== null) o.return = s, N = o; else e: for (; N !== null;) { if (s = N, s.flags & 2048) switch (s.tag) { case 0: case 11: case 15: $s(9, s, s.return) }var y = s.sibling; if (y !== null) { y.return = s.return, N = y; break e } N = s.return } } var g = t.current; for (N = g; N !== null;) { o = N; var v = o.child; if (o.subtreeFlags & 2064 && v !== null) v.return = o, N = v; else e: for (o = g; N !== null;) { if (a = N, a.flags & 2048) try { switch (a.tag) { case 0: case 11: case 15: Cc(9, a) } } catch (_) { De(a, a.return, _) } if (a === o) { N = null; break e } var b = a.sibling; if (b !== null) { b.return = a.return, N = b; break e } N = a.return } } if (oe = r, Ti(), hn && typeof hn.onPostCommitFiberRoot == "function") try { hn.onPostCommitFiberRoot(vc, t) } catch { } i = !0 } return i } finally { ue = n, zt.transition = e } } return !1 } function tg(t, e, n) { e = Qr(n, e), e = n1(t, e, 1), t = fi(t, e, 1), e = ft(), t !== null && (Wo(t, 1, e), St(t, e)) } function De(t, e, n) { if (t.tag === 3) tg(t, t, n); else for (; e !== null;) { if (e.tag === 3) { tg(e, t, n); break } else if (e.tag === 1) { var i = e.stateNode; if (typeof e.type.getDerivedStateFromError == "function" || typeof i.componentDidCatch == "function" && (hi === null || !hi.has(i))) { t = Qr(n, t), t = i1(e, t, 1), e = fi(e, t, 1), t = ft(), e !== null && (Wo(e, 1, t), St(e, t)); break } } e = e.return } } function vk(t, e, n) { var i = t.pingCache; i !== null && i.delete(e), e = ft(), t.pingedLanes |= t.suspendedLanes & n, Ge === t && (qe & n) === n && (We === 4 || We === 3 && (qe & 130023424) === qe && 500 > Fe() - zh ? Gi(t, 0) : Vh |= n), St(t, e) } function S1(t, e) { e === 0 && (t.mode & 1 ? (e = xa, xa <<= 1, !(xa & 130023424) && (xa = 4194304)) : e = 1); var n = ft(); t = Vn(t, e), t !== null && (Wo(t, e, n), St(t, n)) } function xk(t) { var e = t.memoizedState, n = 0; e !== null && (n = e.retryLane), S1(t, n) } function wk(t, e) { var n = 0; switch (t.tag) { case 13: var i = t.stateNode, r = t.memoizedState; r !== null && (n = r.retryLane); break; case 19: i = t.stateNode; break; default: throw Error(R(314)) }i !== null && i.delete(e), S1(t, n) } var k1; k1 = function (t, e, n) { if (t !== null) if (t.memoizedProps !== e.pendingProps || bt.current) wt = !0; else { if (!(t.lanes & n) && !(e.flags & 128)) return wt = !1, ak(t, e, n); wt = !!(t.flags & 131072) } else wt = !1, xe && e.flags & 1048576 && Mx(e, Il, e.index); switch (e.lanes = 0, e.tag) { case 2: var i = e.type; hl(t, e), t = e.pendingProps; var r = Yr(e, lt.current); Br(e, n), r = Lh(null, e, i, t, r, n); var s = jh(); return e.flags |= 1, typeof r == "object" && r !== null && typeof r.render == "function" && r.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, _t(i) ? (s = !0, Nl(e)) : s = !1, e.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null, Th(e), r.updater = kc, e.stateNode = r, r._reactInternals = e, Gd(e, i, t, n), e = Zd(null, e, i, !0, s, n)) : (e.tag = 0, xe && s && bh(e), dt(null, e, r, n), e = e.child), e; case 16: i = e.elementType; e: { switch (hl(t, e), t = e.pendingProps, r = i._init, i = r(i._payload), e.type = i, r = e.tag = _k(i), t = Yt(i, t), r) { case 0: e = qd(null, e, i, t, n); break e; case 1: e = Um(null, e, i, t, n); break e; case 11: e = Wm(null, e, i, t, n); break e; case 14: e = $m(null, e, i, Yt(i.type, t), n); break e }throw Error(R(306, i, "")) } return e; case 0: return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : Yt(i, r), qd(t, e, i, r, n); case 1: return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : Yt(i, r), Um(t, e, i, r, n); case 3: e: { if (a1(e), t === null) throw Error(R(387)); i = e.pendingProps, s = e.memoizedState, r = s.element, Ox(t, e), Bl(e, i, null, n); var o = e.memoizedState; if (i = o.element, s.isDehydrated) if (s = { element: i, isDehydrated: !1, cache: o.cache, pendingSuspenseBoundaries: o.pendingSuspenseBoundaries, transitions: o.transitions }, e.updateQueue.baseState = s, e.memoizedState = s, e.flags & 256) { r = Qr(Error(R(423)), e), e = Ym(t, e, i, n, r); break e } else if (i !== r) { r = Qr(Error(R(424)), e), e = Ym(t, e, i, n, r); break e } else for (Tt = di(e.stateNode.containerInfo.firstChild), Dt = e, xe = !0, Gt = null, n = Ax(e, null, i, n), e.child = n; n;)n.flags = n.flags & -3 | 4096, n = n.sibling; else { if (Kr(), i === r) { e = zn(t, e, n); break e } dt(t, e, i, n) } e = e.child } return e; case 5: return Nx(e), t === null && Yd(e), i = e.type, r = e.pendingProps, s = t !== null ? t.memoizedProps : null, o = r.children, Bd(i, r) ? o = null : s !== null && Bd(i, s) && (e.flags |= 32), o1(t, e), dt(t, e, o, n), e.child; case 6: return t === null && Yd(e), null; case 13: return l1(t, e, n); case 4: return Eh(e, e.stateNode.containerInfo), i = e.pendingProps, t === null ? e.child = Xr(e, null, i, n) : dt(t, e, i, n), e.child; case 11: return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : Yt(i, r), Wm(t, e, i, r, n); case 7: return dt(t, e, e.pendingProps, n), e.child; case 8: return dt(t, e, e.pendingProps.children, n), e.child; case 12: return dt(t, e, e.pendingProps.children, n), e.child; case 10: e: { if (i = e.type._context, r = e.pendingProps, s = e.memoizedProps, o = r.value, fe(Vl, i._currentValue), i._currentValue = o, s !== null) if (en(s.value, o)) { if (s.children === r.children && !bt.current) { e = zn(t, e, n); break e } } else for (s = e.child, s !== null && (s.return = e); s !== null;) { var a = s.dependencies; if (a !== null) { o = s.child; for (var l = a.firstContext; l !== null;) { if (l.context === i) { if (s.tag === 1) { l = An(-1, n & -n), l.tag = 2; var c = s.updateQueue; if (c !== null) { c = c.shared; var u = c.pending; u === null ? l.next = l : (l.next = u.next, u.next = l), c.pending = l } } s.lanes |= n, l = s.alternate, l !== null && (l.lanes |= n), Kd(s.return, n, e), a.lanes |= n; break } l = l.next } } else if (s.tag === 10) o = s.type === e.type ? null : s.child; else if (s.tag === 18) { if (o = s.return, o === null) throw Error(R(341)); o.lanes |= n, a = o.alternate, a !== null && (a.lanes |= n), Kd(o, n, e), o = s.sibling } else o = s.child; if (o !== null) o.return = s; else for (o = s; o !== null;) { if (o === e) { o = null; break } if (s = o.sibling, s !== null) { s.return = o.return, o = s; break } o = o.return } s = o } dt(t, e, r.children, n), e = e.child } return e; case 9: return r = e.type, i = e.pendingProps.children, Br(e, n), r = Bt(r), i = i(r), e.flags |= 1, dt(t, e, i, n), e.child; case 14: return i = e.type, r = Yt(i, e.pendingProps), r = Yt(i.type, r), $m(t, e, i, r, n); case 15: return r1(t, e, e.type, e.pendingProps, n); case 17: return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : Yt(i, r), hl(t, e), e.tag = 1, _t(i) ? (t = !0, Nl(e)) : t = !1, Br(e, n), Lx(e, i, r), Gd(e, i, r, n), Zd(null, e, i, !0, t, n); case 19: return c1(t, e, n); case 22: return s1(t, e, n) }throw Error(R(156, e.tag)) }; function P1(t, e) { return qv(t, e) } function bk(t, e, n, i) { this.tag = t, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = i, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Vt(t, e, n, i) { return new bk(t, e, n, i) } function $h(t) { return t = t.prototype, !(!t || !t.isReactComponent) } function _k(t) { if (typeof t == "function") return $h(t) ? 1 : 0; if (t != null) { if (t = t.$$typeof, t === ch) return 11; if (t === uh) return 14 } return 2 } function mi(t, e) { var n = t.alternate; return n === null ? (n = Vt(t.tag, e, t.key, t.mode), n.elementType = t.elementType, n.type = t.type, n.stateNode = t.stateNode, n.alternate = t, t.alternate = n) : (n.pendingProps = e, n.type = t.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = t.flags & 14680064, n.childLanes = t.childLanes, n.lanes = t.lanes, n.child = t.child, n.memoizedProps = t.memoizedProps, n.memoizedState = t.memoizedState, n.updateQueue = t.updateQueue, e = t.dependencies, n.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }, n.sibling = t.sibling, n.index = t.index, n.ref = t.ref, n } function gl(t, e, n, i, r, s) { var o = 2; if (i = t, typeof t == "function") $h(t) && (o = 1); else if (typeof t == "string") o = 5; else e: switch (t) { case br: return Qi(n.children, r, s, e); case lh: o = 8, r |= 8; break; case xd: return t = Vt(12, n, e, r | 2), t.elementType = xd, t.lanes = s, t; case wd: return t = Vt(13, n, e, r), t.elementType = wd, t.lanes = s, t; case bd: return t = Vt(19, n, e, r), t.elementType = bd, t.lanes = s, t; case jv: return Tc(n, r, s, e); default: if (typeof t == "object" && t !== null) switch (t.$$typeof) { case Rv: o = 10; break e; case Lv: o = 9; break e; case ch: o = 11; break e; case uh: o = 14; break e; case Qn: o = 16, i = null; break e }throw Error(R(130, t == null ? t : typeof t, "")) }return e = Vt(o, n, e, r), e.elementType = t, e.type = i, e.lanes = s, e } function Qi(t, e, n, i) { return t = Vt(7, t, i, e), t.lanes = n, t } function Tc(t, e, n, i) { return t = Vt(22, t, i, e), t.elementType = jv, t.lanes = n, t.stateNode = { isHidden: !1 }, t } function Lu(t, e, n) { return t = Vt(6, t, null, e), t.lanes = n, t } function ju(t, e, n) { return e = Vt(4, t.children !== null ? t.children : [], t.key, e), e.lanes = n, e.stateNode = { containerInfo: t.containerInfo, pendingChildren: null, implementation: t.implementation }, e } function Sk(t, e, n, i, r) { this.tag = e, this.containerInfo = t, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = pu(0), this.expirationTimes = pu(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = pu(0), this.identifierPrefix = i, this.onRecoverableError = r, this.mutableSourceEagerHydrationData = null } function Uh(t, e, n, i, r, s, o, a, l) { return t = new Sk(t, e, n, a, l), e === 1 ? (e = 1, s === !0 && (e |= 8)) : e = 0, s = Vt(3, null, null, e), t.current = s, s.stateNode = t, s.memoizedState = { element: i, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Th(s), t } function kk(t, e, n) { var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: wr, key: i == null ? null : "" + i, children: t, containerInfo: e, implementation: n } } function C1(t) { if (!t) return bi; t = t._reactInternals; e: { if (dr(t) !== t || t.tag !== 1) throw Error(R(170)); var e = t; do { switch (e.tag) { case 3: e = e.stateNode.context; break e; case 1: if (_t(e.type)) { e = e.stateNode.__reactInternalMemoizedMergedChildContext; break e } }e = e.return } while (e !== null); throw Error(R(171)) } if (t.tag === 1) { var n = t.type; if (_t(n)) return Px(t, n, e) } return e } function M1(t, e, n, i, r, s, o, a, l) { return t = Uh(n, i, !0, t, r, s, o, a, l), t.context = C1(null), n = t.current, i = ft(), r = pi(n), s = An(i, r), s.callback = e ?? null, fi(n, s, r), t.current.lanes = r, Wo(t, r, i), St(t, i), t } function Ec(t, e, n, i) { var r = e.current, s = ft(), o = pi(r); return n = C1(n), e.context === null ? e.context = n : e.pendingContext = n, e = An(s, o), e.payload = { element: t }, i = i === void 0 ? null : i, i !== null && (e.callback = i), t = fi(r, e, o), t !== null && (Zt(t, r, o, s), ul(t, r, o)), o } function Gl(t) { if (t = t.current, !t.child) return null; switch (t.child.tag) { case 5: return t.child.stateNode; default: return t.child.stateNode } } function ng(t, e) { if (t = t.memoizedState, t !== null && t.dehydrated !== null) { var n = t.retryLane; t.retryLane = n !== 0 && n < e ? n : e } } function Yh(t, e) { ng(t, e), (t = t.alternate) && ng(t, e) } function Pk() { return null } var T1 = typeof reportError == "function" ? reportError : function (t) { console.error(t) }; function Kh(t) { this._internalRoot = t } Dc.prototype.render = Kh.prototype.render = function (t) { var e = this._internalRoot; if (e === null) throw Error(R(409)); Ec(t, e, null, null) }; Dc.prototype.unmount = Kh.prototype.unmount = function () { var t = this._internalRoot; if (t !== null) { this._internalRoot = null; var e = t.containerInfo; rr(function () { Ec(null, t, null, null) }), e[In] = null } }; function Dc(t) { this._internalRoot = t } Dc.prototype.unstable_scheduleHydration = function (t) { if (t) { var e = rx(); t = { blockedOn: null, target: t, priority: e }; for (var n = 0; n < Jn.length && e !== 0 && e < Jn[n].priority; n++); Jn.splice(n, 0, t), n === 0 && ox(t) } }; function Xh(t) { return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11) } function Oc(t) { return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable ")) } function ig() { } function Ck(t, e, n, i, r) { if (r) { if (typeof i == "function") { var s = i; i = function () { var c = Gl(o); s.call(c) } } var o = M1(e, i, t, 0, null, !1, !1, "", ig); return t._reactRootContainer = o, t[In] = o.current, wo(t.nodeType === 8 ? t.parentNode : t), rr(), o } for (; r = t.lastChild;)t.removeChild(r); if (typeof i == "function") { var a = i; i = function () { var c = Gl(l); a.call(c) } } var l = Uh(t, 0, !1, null, null, !1, !1, "", ig); return t._reactRootContainer = l, t[In] = l.current, wo(t.nodeType === 8 ? t.parentNode : t), rr(function () { Ec(e, l, n, i) }), l } function Rc(t, e, n, i, r) { var s = n._reactRootContainer; if (s) { var o = s; if (typeof r == "function") { var a = r; r = function () { var l = Gl(o); a.call(l) } } Ec(e, o, t, r) } else o = Ck(n, e, t, r, i); return Gl(o) } nx = function (t) { switch (t.tag) { case 3: var e = t.stateNode; if (e.current.memoizedState.isDehydrated) { var n = Os(e.pendingLanes); n !== 0 && (hh(e, n | 1), St(e, Fe()), !(oe & 6) && (qr = Fe() + 500, Ti())) } break; case 13: rr(function () { var i = Vn(t, 1); if (i !== null) { var r = ft(); Zt(i, t, 1, r) } }), Yh(t, 1) } }; ph = function (t) { if (t.tag === 13) { var e = Vn(t, 134217728); if (e !== null) { var n = ft(); Zt(e, t, 134217728, n) } Yh(t, 134217728) } }; ix = function (t) { if (t.tag === 13) { var e = pi(t), n = Vn(t, e); if (n !== null) { var i = ft(); Zt(n, t, e, i) } Yh(t, e) } }; rx = function () { return ue }; sx = function (t, e) { var n = ue; try { return ue = t, e() } finally { ue = n } }; Od = function (t, e, n) { switch (e) { case "input": if (kd(t, n), e = n.name, n.type === "radio" && e != null) { for (n = t; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < n.length; e++) { var i = n[e]; if (i !== t && i.form === t.form) { var r = _c(i); if (!r) throw Error(R(90)); Nv(i), kd(i, r) } } } break; case "textarea": Iv(t, n); break; case "select": e = n.value, e != null && Fr(t, !!n.multiple, e, !1) } }; Uv = Bh; Yv = rr; var Mk = { usingClientEntryPoint: !1, Events: [Uo, Pr, _c, Wv, $v, Bh] }, vs = { findFiberByHostInstance: $i, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, Tk = { bundleType: vs.bundleType, version: vs.version, rendererPackageName: vs.rendererPackageName, rendererConfig: vs.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Bn.ReactCurrentDispatcher, findHostInstanceByFiber: function (t) { return t = Gv(t), t === null ? null : t.stateNode }, findFiberByHostInstance: vs.findFiberByHostInstance || Pk, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var Da = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!Da.isDisabled && Da.supportsFiber) try { vc = Da.inject(Tk), hn = Da } catch { } } Lt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Mk; Lt.createPortal = function (t, e) { var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!Xh(e)) throw Error(R(200)); return kk(t, e, null, n) }; Lt.createRoot = function (t, e) { if (!Xh(t)) throw Error(R(299)); var n = !1, i = "", r = T1; return e != null && (e.unstable_strictMode === !0 && (n = !0), e.identifierPrefix !== void 0 && (i = e.identifierPrefix), e.onRecoverableError !== void 0 && (r = e.onRecoverableError)), e = Uh(t, 1, !1, null, null, n, !1, i, r), t[In] = e.current, wo(t.nodeType === 8 ? t.parentNode : t), new Kh(e) }; Lt.findDOMNode = function (t) { if (t == null) return null; if (t.nodeType === 1) return t; var e = t._reactInternals; if (e === void 0) throw typeof t.render == "function" ? Error(R(188)) : (t = Object.keys(t).join(","), Error(R(268, t))); return t = Gv(e), t = t === null ? null : t.stateNode, t }; Lt.flushSync = function (t) { return rr(t) }; Lt.hydrate = function (t, e, n) { if (!Oc(e)) throw Error(R(200)); return Rc(null, t, e, !0, n) }; Lt.hydrateRoot = function (t, e, n) { if (!Xh(t)) throw Error(R(405)); var i = n != null && n.hydratedSources || null, r = !1, s = "", o = T1; if (n != null && (n.unstable_strictMode === !0 && (r = !0), n.identifierPrefix !== void 0 && (s = n.identifierPrefix), n.onRecoverableError !== void 0 && (o = n.onRecoverableError)), e = M1(e, null, t, 1, n ?? null, r, !1, s, o), t[In] = e.current, wo(t), i) for (t = 0; t < i.length; t++)n = i[t], r = n._getVersion, r = r(n._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [n, r] : e.mutableSourceEagerHydrationData.push(n, r); return new Dc(e) }; Lt.render = function (t, e, n) { if (!Oc(e)) throw Error(R(200)); return Rc(null, t, e, !1, n) }; Lt.unmountComponentAtNode = function (t) { if (!Oc(t)) throw Error(R(40)); return t._reactRootContainer ? (rr(function () { Rc(null, null, t, !1, function () { t._reactRootContainer = null, t[In] = null }) }), !0) : !1 }; Lt.unstable_batchedUpdates = Bh; Lt.unstable_renderSubtreeIntoContainer = function (t, e, n, i) { if (!Oc(n)) throw Error(R(200)); if (t == null || t._reactInternals === void 0) throw Error(R(38)); return Rc(t, e, n, !1, i) }; Lt.version = "18.2.0-next-9e3b772b8-20220608"; (function (t) { function e() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e) } catch (n) { console.error(n) } } e(), t.exports = Lt })(P2); var rg = Pl; gd.createRoot = rg.createRoot, gd.hydrateRoot = rg.hydrateRoot;/**
 * @remix-run/router v1.4.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function se() { return se = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]) } return t }, se.apply(this, arguments) } var Ne; (function (t) { t.Pop = "POP", t.Push = "PUSH", t.Replace = "REPLACE" })(Ne || (Ne = {})); const sg = "popstate"; function Ek(t) { t === void 0 && (t = {}); function e(i, r) { let { pathname: s, search: o, hash: a } = i.location; return Eo("", { pathname: s, search: o, hash: a }, r.state && r.state.usr || null, r.state && r.state.key || "default") } function n(i, r) { return typeof r == "string" ? r : sr(r) } return Ok(e, n, null, t) } function ee(t, e) { if (t === !1 || t === null || typeof t > "u") throw new Error(e) } function Zr(t, e) { if (!t) { typeof console < "u" && console.warn(e); try { throw new Error(e) } catch { } } } function Dk() { return Math.random().toString(36).substr(2, 8) } function og(t, e) { return { usr: t.state, key: t.key, idx: e } } function Eo(t, e, n, i) { return n === void 0 && (n = null), se({ pathname: typeof t == "string" ? t : t.pathname, search: "", hash: "" }, typeof e == "string" ? Hn(e) : e, { state: n, key: e && e.key || i || Dk() }) } function sr(t) { let { pathname: e = "/", search: n = "", hash: i = "" } = t; return n && n !== "?" && (e += n.charAt(0) === "?" ? n : "?" + n), i && i !== "#" && (e += i.charAt(0) === "#" ? i : "#" + i), e } function Hn(t) { let e = {}; if (t) { let n = t.indexOf("#"); n >= 0 && (e.hash = t.substr(n), t = t.substr(0, n)); let i = t.indexOf("?"); i >= 0 && (e.search = t.substr(i), t = t.substr(0, i)), t && (e.pathname = t) } return e } function Ok(t, e, n, i) { i === void 0 && (i = {}); let { window: r = document.defaultView, v5Compat: s = !1 } = i, o = r.history, a = Ne.Pop, l = null, c = u(); c == null && (c = 0, o.replaceState(se({}, o.state, { idx: c }), "")); function u() { return (o.state || { idx: null }).idx } function d() { a = Ne.Pop; let x = u(), y = x == null ? null : x - c; c = x, l && l({ action: a, location: p.location, delta: y }) } function f(x, y) { a = Ne.Push; let g = Eo(p.location, x, y); n && n(g, x), c = u() + 1; let v = og(g, c), b = p.createHref(g); try { o.pushState(v, "", b) } catch { r.location.assign(b) } s && l && l({ action: a, location: p.location, delta: 1 }) } function h(x, y) { a = Ne.Replace; let g = Eo(p.location, x, y); n && n(g, x), c = u(); let v = og(g, c), b = p.createHref(g); o.replaceState(v, "", b), s && l && l({ action: a, location: p.location, delta: 0 }) } function m(x) { let y = r.location.origin !== "null" ? r.location.origin : r.location.href, g = typeof x == "string" ? x : sr(x); return ee(y, "No window.location.(origin|href) available to create URL for href: " + g), new URL(g, y) } let p = { get action() { return a }, get location() { return t(r, o) }, listen(x) { if (l) throw new Error("A history only accepts one active listener"); return r.addEventListener(sg, d), l = x, () => { r.removeEventListener(sg, d), l = null } }, createHref(x) { return e(r, x) }, createURL: m, encodeLocation(x) { let y = m(x); return { pathname: y.pathname, search: y.search, hash: y.hash } }, push: f, replace: h, go(x) { return o.go(x) } }; return p } var Be; (function (t) { t.data = "data", t.deferred = "deferred", t.redirect = "redirect", t.error = "error" })(Be || (Be = {})); const Rk = new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]); function Lk(t) { return t.index === !0 } function E1(t, e, n, i) { return n === void 0 && (n = []), i === void 0 && (i = {}), t.map((r, s) => { let o = [...n, s], a = typeof r.id == "string" ? r.id : o.join("-"); if (ee(r.index !== !0 || !r.children, "Cannot specify children on an index route"), ee(!i[a], 'Found a route id collision on id "' + a + `".  Route id's must be globally unique within Data Router usages`), Lk(r)) { let l = se({}, r, { hasErrorBoundary: e(r), id: a }); return i[a] = l, l } else { let l = se({}, r, { id: a, hasErrorBoundary: e(r), children: void 0 }); return i[a] = l, r.children && (l.children = E1(r.children, e, o, i)), l } }) } function Rr(t, e, n) { n === void 0 && (n = "/"); let i = typeof e == "string" ? Hn(e) : e, r = Lc(i.pathname || "/", n); if (r == null) return null; let s = D1(t); jk(s); let o = null; for (let a = 0; o == null && a < s.length; ++a)o = Wk(s[a], Yk(r)); return o } function D1(t, e, n, i) { e === void 0 && (e = []), n === void 0 && (n = []), i === void 0 && (i = ""); let r = (s, o, a) => { let l = { relativePath: a === void 0 ? s.path || "" : a, caseSensitive: s.caseSensitive === !0, childrenIndex: o, route: s }; l.relativePath.startsWith("/") && (ee(l.relativePath.startsWith(i), 'Absolute route path "' + l.relativePath + '" nested under path ' + ('"' + i + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), l.relativePath = l.relativePath.slice(i.length)); let c = qi([i, l.relativePath]), u = n.concat(l); s.children && s.children.length > 0 && (ee(s.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + c + '".')), D1(s.children, e, u, c)), !(s.path == null && !s.index) && e.push({ path: c, score: Bk(c, s.index), routesMeta: u }) }; return t.forEach((s, o) => { var a; if (s.path === "" || !((a = s.path) != null && a.includes("?"))) r(s, o); else for (let l of O1(s.path)) r(s, o, l) }), e } function O1(t) { let e = t.split("/"); if (e.length === 0) return []; let [n, ...i] = e, r = n.endsWith("?"), s = n.replace(/\?$/, ""); if (i.length === 0) return r ? [s, ""] : [s]; let o = O1(i.join("/")), a = []; return a.push(...o.map(l => l === "" ? s : [s, l].join("/"))), r && a.push(...o), a.map(l => t.startsWith("/") && l === "" ? "/" : l) } function jk(t) { t.sort((e, n) => e.score !== n.score ? n.score - e.score : Hk(e.routesMeta.map(i => i.childrenIndex), n.routesMeta.map(i => i.childrenIndex))) } const Ak = /^:\w+$/, Nk = 3, Fk = 2, Ik = 1, Vk = 10, zk = -2, ag = t => t === "*"; function Bk(t, e) { let n = t.split("/"), i = n.length; return n.some(ag) && (i += zk), e && (i += Fk), n.filter(r => !ag(r)).reduce((r, s) => r + (Ak.test(s) ? Nk : s === "" ? Ik : Vk), i) } function Hk(t, e) { return t.length === e.length && t.slice(0, -1).every((i, r) => i === e[r]) ? t[t.length - 1] - e[e.length - 1] : 0 } function Wk(t, e) { let { routesMeta: n } = t, i = {}, r = "/", s = []; for (let o = 0; o < n.length; ++o) { let a = n[o], l = o === n.length - 1, c = r === "/" ? e : e.slice(r.length) || "/", u = $k({ path: a.relativePath, caseSensitive: a.caseSensitive, end: l }, c); if (!u) return null; Object.assign(i, u.params); let d = a.route; s.push({ params: i, pathname: qi([r, u.pathname]), pathnameBase: qk(qi([r, u.pathnameBase])), route: d }), u.pathnameBase !== "/" && (r = qi([r, u.pathnameBase])) } return s } function $k(t, e) { typeof t == "string" && (t = { path: t, caseSensitive: !1, end: !0 }); let [n, i] = Uk(t.path, t.caseSensitive, t.end), r = e.match(n); if (!r) return null; let s = r[0], o = s.replace(/(.)\/+$/, "$1"), a = r.slice(1); return { params: i.reduce((c, u, d) => { if (u === "*") { let f = a[d] || ""; o = s.slice(0, s.length - f.length).replace(/(.)\/+$/, "$1") } return c[u] = Kk(a[d] || "", u), c }, {}), pathname: s, pathnameBase: o, pattern: t } } function Uk(t, e, n) { e === void 0 && (e = !1), n === void 0 && (n = !0), Zr(t === "*" || !t.endsWith("*") || t.endsWith("/*"), 'Route path "' + t + '" will be treated as if it were ' + ('"' + t.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + t.replace(/\*$/, "/*") + '".')); let i = [], r = "^" + t.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, (o, a) => (i.push(a), "/([^\\/]+)")); return t.endsWith("*") ? (i.push("*"), r += t === "*" || t === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? r += "\\/*$" : t !== "" && t !== "/" && (r += "(?:(?=\\/|$))"), [new RegExp(r, e ? void 0 : "i"), i] } function Yk(t) { try { return decodeURI(t) } catch (e) { return Zr(!1, 'The URL path "' + t + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + e + ").")), t } } function Kk(t, e) { try { return decodeURIComponent(t) } catch (n) { return Zr(!1, 'The value for the URL param "' + e + '" will not be decoded because' + (' the string "' + t + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + n + ").")), t } } function Lc(t, e) { if (e === "/") return t; if (!t.toLowerCase().startsWith(e.toLowerCase())) return null; let n = e.endsWith("/") ? e.length - 1 : e.length, i = t.charAt(n); return i && i !== "/" ? null : t.slice(n) || "/" } function Xk(t, e) { e === void 0 && (e = "/"); let { pathname: n, search: i = "", hash: r = "" } = typeof t == "string" ? Hn(t) : t; return { pathname: n ? n.startsWith("/") ? n : Gk(n, e) : e, search: Zk(i), hash: Jk(r) } } function Gk(t, e) { let n = e.replace(/\/+$/, "").split("/"); return t.split("/").forEach(r => { r === ".." ? n.length > 1 && n.pop() : r !== "." && n.push(r) }), n.length > 1 ? n.join("/") : "/" } function Au(t, e, n, i) { return "Cannot include a '" + t + "' character in a manually specified " + ("`to." + e + "` field [" + JSON.stringify(i) + "].  Please separate it out to the ") + ("`to." + n + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.' } function R1(t) { return t.filter((e, n) => n === 0 || e.route.path && e.route.path.length > 0) } function Qk(t, e, n, i) { i === void 0 && (i = !1); let r; typeof t == "string" ? r = Hn(t) : (r = se({}, t), ee(!r.pathname || !r.pathname.includes("?"), Au("?", "pathname", "search", r)), ee(!r.pathname || !r.pathname.includes("#"), Au("#", "pathname", "hash", r)), ee(!r.search || !r.search.includes("#"), Au("#", "search", "hash", r))); let s = t === "" || r.pathname === "", o = s ? "/" : r.pathname, a; if (i || o == null) a = n; else { let d = e.length - 1; if (o.startsWith("..")) { let f = o.split("/"); for (; f[0] === "..";)f.shift(), d -= 1; r.pathname = f.join("/") } a = d >= 0 ? e[d] : "/" } let l = Xk(r, a), c = o && o !== "/" && o.endsWith("/"), u = (s || o === ".") && n.endsWith("/"); return !l.pathname.endsWith("/") && (c || u) && (l.pathname += "/"), l } const qi = t => t.join("/").replace(/\/\/+/g, "/"), qk = t => t.replace(/\/+$/, "").replace(/^\/*/, "/"), Zk = t => !t || t === "?" ? "" : t.startsWith("?") ? t : "?" + t, Jk = t => !t || t === "#" ? "" : t.startsWith("#") ? t : "#" + t; class lg extends Error { } class eP { constructor(e, n) { this.pendingKeysSet = new Set, this.subscribers = new Set, this.deferredKeys = [], ee(e && typeof e == "object" && !Array.isArray(e), "defer() only accepts plain objects"); let i; this.abortPromise = new Promise((s, o) => i = o), this.controller = new AbortController; let r = () => i(new lg("Deferred data aborted")); this.unlistenAbortSignal = () => this.controller.signal.removeEventListener("abort", r), this.controller.signal.addEventListener("abort", r), this.data = Object.entries(e).reduce((s, o) => { let [a, l] = o; return Object.assign(s, { [a]: this.trackPromise(a, l) }) }, {}), this.done && this.unlistenAbortSignal(), this.init = n } trackPromise(e, n) { if (!(n instanceof Promise)) return n; this.deferredKeys.push(e), this.pendingKeysSet.add(e); let i = Promise.race([n, this.abortPromise]).then(r => this.onSettle(i, e, null, r), r => this.onSettle(i, e, r)); return i.catch(() => { }), Object.defineProperty(i, "_tracked", { get: () => !0 }), i } onSettle(e, n, i, r) { return this.controller.signal.aborted && i instanceof lg ? (this.unlistenAbortSignal(), Object.defineProperty(e, "_error", { get: () => i }), Promise.reject(i)) : (this.pendingKeysSet.delete(n), this.done && this.unlistenAbortSignal(), i ? (Object.defineProperty(e, "_error", { get: () => i }), this.emit(!1, n), Promise.reject(i)) : (Object.defineProperty(e, "_data", { get: () => r }), this.emit(!1, n), r)) } emit(e, n) { this.subscribers.forEach(i => i(e, n)) } subscribe(e) { return this.subscribers.add(e), () => this.subscribers.delete(e) } cancel() { this.controller.abort(), this.pendingKeysSet.forEach((e, n) => this.pendingKeysSet.delete(n)), this.emit(!0) } async resolveData(e) { let n = !1; if (!this.done) { let i = () => this.cancel(); e.addEventListener("abort", i), n = await new Promise(r => { this.subscribe(s => { e.removeEventListener("abort", i), (s || this.done) && r(s) }) }) } return n } get done() { return this.pendingKeysSet.size === 0 } get unwrappedData() { return ee(this.data !== null && this.done, "Can only unwrap data on initialized and settled deferreds"), Object.entries(this.data).reduce((e, n) => { let [i, r] = n; return Object.assign(e, { [i]: nP(r) }) }, {}) } get pendingKeys() { return Array.from(this.pendingKeysSet) } } function tP(t) { return t instanceof Promise && t._tracked === !0 } function nP(t) { if (!tP(t)) return t; if (t._error) throw t._error; return t._data } class Gh { constructor(e, n, i, r) { r === void 0 && (r = !1), this.status = e, this.statusText = n || "", this.internal = r, i instanceof Error ? (this.data = i.toString(), this.error = i) : this.data = i } } function L1(t) { return t != null && typeof t.status == "number" && typeof t.statusText == "string" && typeof t.internal == "boolean" && "data" in t } const j1 = ["post", "put", "patch", "delete"], iP = new Set(j1), rP = ["get", ...j1], sP = new Set(rP), oP = new Set([301, 302, 303, 307, 308]), aP = new Set([307, 308]), Nu = { state: "idle", location: void 0, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0 }, lP = { state: "idle", data: void 0, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0 }, cg = { state: "unblocked", proceed: void 0, reset: void 0, location: void 0 }, A1 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, N1 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", cP = !N1, uP = t => !!t.hasErrorBoundary; function dP(t) { ee(t.routes.length > 0, "You must provide a non-empty routes array to createRouter"); let e = t.detectErrorBoundary || uP, n = {}, i = E1(t.routes, e, void 0, n), r, s = null, o = new Set, a = null, l = null, c = null, u = t.hydrationData != null, d = Rr(i, t.history.location, t.basename), f = null; if (d == null) { let C = ln(404, { pathname: t.history.location.pathname }), { matches: E, route: O } = mg(i); d = E, f = { [O.id]: C } } let h = !d.some(C => C.route.lazy) && (!d.some(C => C.route.loader) || t.hydrationData != null), m, p = { historyAction: t.history.action, location: t.history.location, matches: d, initialized: h, navigation: Nu, restoreScrollPosition: t.hydrationData != null ? !1 : null, preventScrollReset: !1, revalidation: "idle", loaderData: t.hydrationData && t.hydrationData.loaderData || {}, actionData: t.hydrationData && t.hydrationData.actionData || null, errors: t.hydrationData && t.hydrationData.errors || f, fetchers: new Map, blockers: new Map }, x = Ne.Pop, y = !1, g, v = !1, b = !1, _ = [], k = [], S = new Map, P = 0, T = -1, D = new Map, A = new Set, V = new Map, q = new Map, G = new Map, z = !1; function J() { if (s = t.history.listen(O => { let { action: I, location: B, delta: K } = O; if (z) { z = !1; return } Zr(G.size === 0 || K != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL."); let $ = Kp({ currentLocation: p.location, nextLocation: B, historyAction: I }); if ($ && K != null) { z = !0, t.history.go(K * -1), ca($, { state: "blocked", location: B, proceed() { ca($, { state: "proceeding", proceed: void 0, reset: void 0, location: B }), t.history.go(K) }, reset() { cs($), j({ blockers: new Map(m.state.blockers) }) } }); return } return Te(I, B) }), p.initialized) return m; let C = p.matches.filter(O => O.route.lazy); if (C.length === 0) return Te(Ne.Pop, p.location), m; let E = C.map(O => df(O.route, e, n)); return Promise.all(E).then(() => { !p.matches.some(I => I.route.loader) || t.hydrationData != null ? j({ initialized: !0 }) : Te(Ne.Pop, p.location) }), m } function re() { s && s(), o.clear(), g && g.abort(), p.fetchers.forEach((C, E) => ru(E)), p.blockers.forEach((C, E) => cs(E)) } function L(C) { return o.add(C), () => o.delete(C) } function j(C) { p = se({}, p, C), o.forEach(E => E(p)) } function W(C, E) { var O, I; let B = p.actionData != null && p.navigation.formMethod != null && Cn(p.navigation.formMethod) && p.navigation.state === "loading" && ((O = C.state) == null ? void 0 : O._isRedirect) !== !0, K; E.actionData ? Object.keys(E.actionData).length > 0 ? K = E.actionData : K = null : B ? K = p.actionData : K = null; let $ = E.loaderData ? pg(p.loaderData, E.loaderData, E.matches || [], E.errors) : p.loaderData; for (let [H] of G) cs(H); let Z = y === !0 || p.navigation.formMethod != null && Cn(p.navigation.formMethod) && ((I = C.state) == null ? void 0 : I._isRedirect) !== !0; r && (i = r, r = void 0), j(se({}, E, { actionData: K, loaderData: $, historyAction: x, location: C, initialized: !0, navigation: Nu, revalidation: "idle", restoreScrollPosition: Xp(C, E.matches || p.matches), preventScrollReset: Z, blockers: new Map(p.blockers) })), v || x === Ne.Pop || (x === Ne.Push ? t.history.push(C, C.state) : x === Ne.Replace && t.history.replace(C, C.state)), x = Ne.Pop, y = !1, v = !1, b = !1, _ = [], k = [] } async function Y(C, E) { if (typeof C == "number") { t.history.go(C); return } let { path: O, submission: I, error: B } = ug(C, E), K = p.location, $ = Eo(p.location, O, E && E.state); $ = se({}, $, t.history.encodeLocation($)); let Z = E && E.replace != null ? E.replace : void 0, H = Ne.Push; Z === !0 ? H = Ne.Replace : Z === !1 || I != null && Cn(I.formMethod) && I.formAction === p.location.pathname + p.location.search && (H = Ne.Replace); let et = E && "preventScrollReset" in E ? E.preventScrollReset === !0 : void 0, le = Kp({ currentLocation: K, nextLocation: $, historyAction: H }); if (le) { ca(le, { state: "blocked", location: $, proceed() { ca(le, { state: "proceeding", proceed: void 0, reset: void 0, location: $ }), Y(C, E) }, reset() { cs(le), j({ blockers: new Map(p.blockers) }) } }); return } return await Te(H, $, { submission: I, pendingError: B, preventScrollReset: et, replace: E && E.replace }) } function ae() { if (nu(), j({ revalidation: "loading" }), p.navigation.state !== "submitting") { if (p.navigation.state === "idle") { Te(p.historyAction, p.location, { startUninterruptedRevalidation: !0 }); return } Te(x || p.historyAction, p.navigation.location, { overrideNavigation: p.navigation }) } } async function Te(C, E, O) { g && g.abort(), g = null, x = C, v = (O && O.startUninterruptedRevalidation) === !0, Y_(p.location, p.matches), y = (O && O.preventScrollReset) === !0; let I = r || i, B = O && O.overrideNavigation, K = Rr(I, E, t.basename); if (!K) { let Ae = ln(404, { pathname: E.pathname }), { matches: nn, route: $t } = mg(I); su(), W(E, { matches: nn, loaderData: {}, errors: { [$t.id]: Ae } }); return } if (gP(p.location, E) && !(O && O.submission && Cn(O.submission.formMethod))) { W(E, { matches: K }); return } g = new AbortController; let $ = ws(t.history, E, g.signal, O && O.submission), Z, H; if (O && O.pendingError) H = { [Lr(K).route.id]: O.pendingError }; else if (O && O.submission && Cn(O.submission.formMethod)) { let Ae = await je($, E, O.submission, K, { replace: O.replace }); if (Ae.shortCircuited) return; Z = Ae.pendingActionData, H = Ae.pendingActionError, B = se({ state: "loading", location: E }, O.submission), $ = new Request($.url, { signal: $.signal }) } let { shortCircuited: et, loaderData: le, errors: ct } = await mt($, E, K, B, O && O.submission, O && O.replace, Z, H); et || (g = null, W(E, se({ matches: K }, Z ? { actionData: Z } : {}, { loaderData: le, errors: ct }))) } async function je(C, E, O, I, B) { nu(); let K = se({ state: "submitting", location: E }, O); j({ navigation: K }); let $, Z = ff(I, E); if (!Z.route.action && !Z.route.lazy) $ = { type: Be.error, error: ln(405, { method: C.method, pathname: E.pathname, routeId: Z.route.id }) }; else if ($ = await xs("action", C, Z, I, n, e, m.basename), C.signal.aborted) return { shortCircuited: !0 }; if (Wr($)) { let H; return B && B.replace != null ? H = B.replace : H = $.location === p.location.pathname + p.location.search, await $n(p, $, { submission: O, replace: H }), { shortCircuited: !0 } } if (Ks($)) { let H = Lr(I, Z.route.id); return (B && B.replace) !== !0 && (x = Ne.Push), { pendingActionData: {}, pendingActionError: { [H.route.id]: $.error } } } if (Ki($)) throw ln(400, { type: "defer-action" }); return { pendingActionData: { [Z.route.id]: $.data } } } async function mt(C, E, O, I, B, K, $, Z) { let H = I; H || (H = se({ state: "loading", location: E, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0 }, B)); let et = B || (H.formMethod && H.formAction && H.formData && H.formEncType ? { formMethod: H.formMethod, formAction: H.formAction, formData: H.formData, formEncType: H.formEncType } : void 0), le = r || i, [ct, Ae] = dg(t.history, p, O, et, E, b, _, k, V, le, t.basename, $, Z); if (su(tt => !(O && O.some(rn => rn.route.id === tt)) || ct && ct.some(rn => rn.route.id === tt)), ct.length === 0 && Ae.length === 0) return W(E, se({ matches: O, loaderData: {}, errors: Z || null }, $ ? { actionData: $ } : {})), { shortCircuited: !0 }; if (!v) { Ae.forEach(rn => { let Oi = p.fetchers.get(rn.key), fa = { state: "loading", data: Oi && Oi.data, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, " _hasFetcherDoneAnything ": !0 }; p.fetchers.set(rn.key, fa) }); let tt = $ || p.actionData; j(se({ navigation: H }, tt ? Object.keys(tt).length === 0 ? { actionData: null } : { actionData: tt } : {}, Ae.length > 0 ? { fetchers: new Map(p.fetchers) } : {})) } T = ++P, Ae.forEach(tt => S.set(tt.key, g)); let { results: nn, loaderResults: $t, fetcherResults: us } = await ls(p.matches, O, ct, Ae, C); if (C.signal.aborted) return { shortCircuited: !0 }; Ae.forEach(tt => S.delete(tt.key)); let ua = gg(nn); if (ua) return await $n(p, ua, { replace: K }), { shortCircuited: !0 }; let { loaderData: da, errors: gr } = hg(p, O, ct, $t, Z, Ae, us, q); q.forEach((tt, rn) => { tt.subscribe(Oi => { (Oi || tt.done) && q.delete(rn) }) }), W_(); let ou = Yp(T); return se({ loaderData: da, errors: gr }, ou || Ae.length > 0 ? { fetchers: new Map(p.fetchers) } : {}) } function $e(C) { return p.fetchers.get(C) || lP } function tn(C, E, O, I) { if (cP) throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback."); S.has(C) && la(C); let K = Rr(r || i, O, t.basename); if (!K) { iu(C, E, ln(404, { pathname: O })); return } let { path: $, submission: Z } = ug(O, I, !0), H = ff(K, $); if (y = (I && I.preventScrollReset) === !0, Z && Cn(Z.formMethod)) { mr(C, E, $, H, K, Z); return } V.set(C, { routeId: E, path: $ }), wn(C, E, $, H, K, Z) } async function mr(C, E, O, I, B, K) { if (nu(), V.delete(C), !I.route.action && !I.route.lazy) { let bn = ln(405, { method: K.formMethod, pathname: O, routeId: E }); iu(C, E, bn); return } let $ = p.fetchers.get(C), Z = se({ state: "submitting" }, K, { data: $ && $.data, " _hasFetcherDoneAnything ": !0 }); p.fetchers.set(C, Z), j({ fetchers: new Map(p.fetchers) }); let H = new AbortController, et = ws(t.history, O, H.signal, K); S.set(C, H); let le = await xs("action", et, I, B, n, e, m.basename); if (et.signal.aborted) { S.get(C) === H && S.delete(C); return } if (Wr(le)) { S.delete(C), A.add(C); let bn = se({ state: "loading" }, K, { data: void 0, " _hasFetcherDoneAnything ": !0 }); return p.fetchers.set(C, bn), j({ fetchers: new Map(p.fetchers) }), $n(p, le, { isFetchActionRedirect: !0 }) } if (Ks(le)) { iu(C, E, le.error); return } if (Ki(le)) throw ln(400, { type: "defer-action" }); let ct = p.navigation.location || p.location, Ae = ws(t.history, ct, H.signal), nn = r || i, $t = p.navigation.state !== "idle" ? Rr(nn, p.navigation.location, t.basename) : p.matches; ee($t, "Didn't find any matches after fetcher action"); let us = ++P; D.set(C, us); let ua = se({ state: "loading", data: le.data }, K, { " _hasFetcherDoneAnything ": !0 }); p.fetchers.set(C, ua); let [da, gr] = dg(t.history, p, $t, K, ct, b, _, k, V, nn, t.basename, { [I.route.id]: le.data }, void 0); gr.filter(bn => bn.key !== C).forEach(bn => { let lu = bn.key, Gp = p.fetchers.get(lu), Q_ = { state: "loading", data: Gp && Gp.data, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, " _hasFetcherDoneAnything ": !0 }; p.fetchers.set(lu, Q_), S.set(lu, H) }), j({ fetchers: new Map(p.fetchers) }); let { results: ou, loaderResults: tt, fetcherResults: rn } = await ls(p.matches, $t, da, gr, Ae); if (H.signal.aborted) return; D.delete(C), S.delete(C), gr.forEach(bn => S.delete(bn.key)); let Oi = gg(ou); if (Oi) return $n(p, Oi); let { loaderData: fa, errors: au } = hg(p, p.matches, da, tt, void 0, gr, rn, q), X_ = { state: "idle", data: le.data, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, " _hasFetcherDoneAnything ": !0 }; p.fetchers.set(C, X_); let G_ = Yp(us); p.navigation.state === "loading" && us > T ? (ee(x, "Expected pending action"), g && g.abort(), W(p.navigation.location, { matches: $t, loaderData: fa, errors: au, fetchers: new Map(p.fetchers) })) : (j(se({ errors: au, loaderData: pg(p.loaderData, fa, $t, au) }, G_ ? { fetchers: new Map(p.fetchers) } : {})), b = !1) } async function wn(C, E, O, I, B, K) { let $ = p.fetchers.get(C), Z = se({ state: "loading", formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0 }, K, { data: $ && $.data, " _hasFetcherDoneAnything ": !0 }); p.fetchers.set(C, Z), j({ fetchers: new Map(p.fetchers) }); let H = new AbortController, et = ws(t.history, O, H.signal); S.set(C, H); let le = await xs("loader", et, I, B, n, e, m.basename); if (Ki(le) && (le = await z1(le, et.signal, !0) || le), S.get(C) === H && S.delete(C), et.signal.aborted) return; if (Wr(le)) { await $n(p, le); return } if (Ks(le)) { let Ae = Lr(p.matches, E); p.fetchers.delete(C), j({ fetchers: new Map(p.fetchers), errors: { [Ae.route.id]: le.error } }); return } ee(!Ki(le), "Unhandled fetcher deferred data"); let ct = { state: "idle", data: le.data, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, " _hasFetcherDoneAnything ": !0 }; p.fetchers.set(C, ct), j({ fetchers: new Map(p.fetchers) }) } async function $n(C, E, O) { var I; let { submission: B, replace: K, isFetchActionRedirect: $ } = O === void 0 ? {} : O; E.revalidate && (b = !0); let Z = Eo(C.location, E.location, se({ _isRedirect: !0 }, $ ? { _isFetchActionRedirect: !0 } : {})); if (ee(Z, "Expected a location on the redirect navigation"), A1.test(E.location) && N1 && typeof ((I = window) == null ? void 0 : I.location) < "u") { let nn = t.history.createURL(E.location), $t = Lc(nn.pathname, t.basename || "/") == null; if (window.location.origin !== nn.origin || $t) { K ? window.location.replace(E.location) : window.location.assign(E.location); return } } g = null; let H = K === !0 ? Ne.Replace : Ne.Push, { formMethod: et, formAction: le, formEncType: ct, formData: Ae } = C.navigation; !B && et && le && Ae && ct && (B = { formMethod: et, formAction: le, formEncType: ct, formData: Ae }), aP.has(E.status) && B && Cn(B.formMethod) ? await Te(H, Z, { submission: se({}, B, { formAction: E.location }), preventScrollReset: y }) : await Te(H, Z, { overrideNavigation: { state: "loading", location: Z, formMethod: B ? B.formMethod : void 0, formAction: B ? B.formAction : void 0, formEncType: B ? B.formEncType : void 0, formData: B ? B.formData : void 0 }, preventScrollReset: y }) } async function ls(C, E, O, I, B) { let K = await Promise.all([...O.map(H => xs("loader", B, H, E, n, e, m.basename)), ...I.map(H => H.matches && H.match ? xs("loader", ws(t.history, H.path, B.signal), H.match, H.matches, n, e, m.basename) : { type: Be.error, error: ln(404, { pathname: H.path }) })]), $ = K.slice(0, O.length), Z = K.slice(O.length); return await Promise.all([yg(C, O, $, B.signal, !1, p.loaderData), yg(C, I.map(H => H.match), Z, B.signal, !0)]), { results: K, loaderResults: $, fetcherResults: Z } } function nu() { b = !0, _.push(...su()), V.forEach((C, E) => { S.has(E) && (k.push(E), la(E)) }) } function iu(C, E, O) { let I = Lr(p.matches, E); ru(C), j({ errors: { [I.route.id]: O }, fetchers: new Map(p.fetchers) }) } function ru(C) { S.has(C) && la(C), V.delete(C), D.delete(C), A.delete(C), p.fetchers.delete(C) } function la(C) { let E = S.get(C); ee(E, "Expected fetch controller: " + C), E.abort(), S.delete(C) } function Up(C) { for (let E of C) { let I = { state: "idle", data: $e(E).data, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, " _hasFetcherDoneAnything ": !0 }; p.fetchers.set(E, I) } } function W_() { let C = []; for (let E of A) { let O = p.fetchers.get(E); ee(O, "Expected fetcher: " + E), O.state === "loading" && (A.delete(E), C.push(E)) } Up(C) } function Yp(C) { let E = []; for (let [O, I] of D) if (I < C) { let B = p.fetchers.get(O); ee(B, "Expected fetcher: " + O), B.state === "loading" && (la(O), D.delete(O), E.push(O)) } return Up(E), E.length > 0 } function $_(C, E) { let O = p.blockers.get(C) || cg; return G.get(C) !== E && G.set(C, E), O } function cs(C) { p.blockers.delete(C), G.delete(C) } function ca(C, E) { let O = p.blockers.get(C) || cg; ee(O.state === "unblocked" && E.state === "blocked" || O.state === "blocked" && E.state === "blocked" || O.state === "blocked" && E.state === "proceeding" || O.state === "blocked" && E.state === "unblocked" || O.state === "proceeding" && E.state === "unblocked", "Invalid blocker state transition: " + O.state + " -> " + E.state), p.blockers.set(C, E), j({ blockers: new Map(p.blockers) }) } function Kp(C) { let { currentLocation: E, nextLocation: O, historyAction: I } = C; if (G.size === 0) return; G.size > 1 && Zr(!1, "A router only supports one blocker at a time"); let B = Array.from(G.entries()), [K, $] = B[B.length - 1], Z = p.blockers.get(K); if (!(Z && Z.state === "proceeding") && $({ currentLocation: E, nextLocation: O, historyAction: I })) return K } function su(C) { let E = []; return q.forEach((O, I) => { (!C || C(I)) && (O.cancel(), E.push(I), q.delete(I)) }), E } function U_(C, E, O) { if (a = C, c = E, l = O || (I => I.key), !u && p.navigation === Nu) { u = !0; let I = Xp(p.location, p.matches); I != null && j({ restoreScrollPosition: I }) } return () => { a = null, c = null, l = null } } function Y_(C, E) { if (a && l && c) { let O = E.map(B => vg(B, p.loaderData)), I = l(C, O) || C.key; a[I] = c() } } function Xp(C, E) { if (a && l && c) { let O = E.map(K => vg(K, p.loaderData)), I = l(C, O) || C.key, B = a[I]; if (typeof B == "number") return B } return null } function K_(C) { r = C } return m = { get basename() { return t.basename }, get state() { return p }, get routes() { return i }, initialize: J, subscribe: L, enableScrollRestoration: U_, navigate: Y, fetch: tn, revalidate: ae, createHref: C => t.history.createHref(C), encodeLocation: C => t.history.encodeLocation(C), getFetcher: $e, deleteFetcher: ru, dispose: re, getBlocker: $_, deleteBlocker: cs, _internalFetchControllers: S, _internalActiveDeferreds: q, _internalSetRoutes: K_ }, m } function fP(t) { return t != null && "formData" in t } function ug(t, e, n) { n === void 0 && (n = !1); let i = typeof t == "string" ? t : sr(t); if (!e || !fP(e)) return { path: i }; if (e.formMethod && !vP(e.formMethod)) return { path: i, error: ln(405, { method: e.formMethod }) }; let r; if (e.formData && (r = { formMethod: e.formMethod || "get", formAction: V1(i), formEncType: e && e.formEncType || "application/x-www-form-urlencoded", formData: e.formData }, Cn(r.formMethod))) return { path: i, submission: r }; let s = Hn(i), o = I1(e.formData); return n && s.search && B1(s.search) && o.append("index", ""), s.search = "?" + o, { path: sr(s), submission: r } } function hP(t, e) { let n = t; if (e) { let i = t.findIndex(r => r.route.id === e); i >= 0 && (n = t.slice(0, i)) } return n } function dg(t, e, n, i, r, s, o, a, l, c, u, d, f) { let h = f ? Object.values(f)[0] : d ? Object.values(d)[0] : void 0, m = t.createURL(e.location), p = t.createURL(r), x = s || m.toString() === p.toString() || m.search !== p.search, y = f ? Object.keys(f)[0] : void 0, v = hP(n, y).filter((_, k) => { if (_.route.lazy) return !0; if (_.route.loader == null) return !1; if (pP(e.loaderData, e.matches[k], _) || o.some(T => T === _.route.id)) return !0; let S = e.matches[k], P = _; return fg(_, se({ currentUrl: m, currentParams: S.params, nextUrl: p, nextParams: P.params }, i, { actionResult: h, defaultShouldRevalidate: x || F1(S, P) })) }), b = []; return l.forEach((_, k) => { if (!n.some(D => D.route.id === _.routeId)) return; let S = Rr(c, _.path, u); if (!S) { b.push(se({ key: k }, _, { matches: null, match: null })); return } let P = ff(S, _.path); if (a.includes(k)) { b.push(se({ key: k, matches: S, match: P }, _)); return } fg(P, se({ currentUrl: m, currentParams: e.matches[e.matches.length - 1].params, nextUrl: p, nextParams: n[n.length - 1].params }, i, { actionResult: h, defaultShouldRevalidate: x })) && b.push(se({ key: k, matches: S, match: P }, _)) }), [v, b] } function pP(t, e, n) { let i = !e || n.route.id !== e.route.id, r = t[n.route.id] === void 0; return i || r } function F1(t, e) { let n = t.route.path; return t.pathname !== e.pathname || n != null && n.endsWith("*") && t.params["*"] !== e.params["*"] } function fg(t, e) { if (t.route.shouldRevalidate) { let n = t.route.shouldRevalidate(e); if (typeof n == "boolean") return n } return e.defaultShouldRevalidate } async function df(t, e, n) { if (!t.lazy) return; let i = await t.lazy(); if (!t.lazy) return; let r = n[t.id]; ee(r, "No route found in manifest"); let s = {}; for (let o in i) { let l = r[o] !== void 0 && o !== "hasErrorBoundary"; Zr(!l, 'Route "' + r.id + '" has a static property "' + o + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + o + '" will be ignored.')), !l && !Rk.has(o) && (s[o] = i[o]) } Object.assign(r, s), Object.assign(r, { hasErrorBoundary: e(se({}, r)), lazy: void 0 }) } async function xs(t, e, n, i, r, s, o, a, l, c) { o === void 0 && (o = "/"), a === void 0 && (a = !1), l === void 0 && (l = !1); let u, d, f, h = x => { let y, g = new Promise((v, b) => y = b); return f = () => y(), e.signal.addEventListener("abort", f), Promise.race([x({ request: e, params: n.params, context: c }), g]) }; try { let x = n.route[t]; if (n.route.lazy) if (x) d = (await Promise.all([h(x), df(n.route, s, r)]))[0]; else if (await df(n.route, s, r), x = n.route[t], x) d = await h(x); else { if (t === "action") throw ln(405, { method: e.method, pathname: new URL(e.url).pathname, routeId: n.route.id }); return { type: Be.data, data: void 0 } } else ee(x, "Could not find the " + t + ' to run on the "' + n.route.id + '" route'), d = await h(x); ee(d !== void 0, "You defined " + (t === "action" ? "an action" : "a loader") + " for route " + ('"' + n.route.id + "\" but didn't return anything from your `" + t + "` ") + "function. Please return a value or `null`.") } catch (x) { u = Be.error, d = x } finally { f && e.signal.removeEventListener("abort", f) } if (yP(d)) { let x = d.status; if (oP.has(x)) { let v = d.headers.get("Location"); if (ee(v, "Redirects returned/thrown from loaders/actions must have a Location header"), A1.test(v)) { if (!a) { let b = new URL(e.url), _ = v.startsWith("//") ? new URL(b.protocol + v) : new URL(v), k = Lc(_.pathname, o) != null; _.origin === b.origin && k && (v = _.pathname + _.search + _.hash) } } else { let b = i.slice(0, i.indexOf(n) + 1), _ = R1(b).map(S => S.pathnameBase), k = Qk(v, _, new URL(e.url).pathname); if (ee(sr(k), "Unable to resolve redirect location: " + v), o) { let S = k.pathname; k.pathname = S === "/" ? o : qi([o, S]) } v = sr(k) } if (a) throw d.headers.set("Location", v), d; return { type: Be.redirect, status: x, location: v, revalidate: d.headers.get("X-Remix-Revalidate") !== null } } if (l) throw { type: u || Be.data, response: d }; let y, g = d.headers.get("Content-Type"); return g && /\bapplication\/json\b/.test(g) ? y = await d.json() : y = await d.text(), u === Be.error ? { type: u, error: new Gh(x, d.statusText, y), headers: d.headers } : { type: Be.data, data: y, statusCode: d.status, headers: d.headers } } if (u === Be.error) return { type: u, error: d }; if (d instanceof eP) { var m, p; return { type: Be.deferred, deferredData: d, statusCode: (m = d.init) == null ? void 0 : m.status, headers: ((p = d.init) == null ? void 0 : p.headers) && new Headers(d.init.headers) } } return { type: Be.data, data: d } } function ws(t, e, n, i) { let r = t.createURL(V1(e)).toString(), s = { signal: n }; if (i && Cn(i.formMethod)) { let { formMethod: o, formEncType: a, formData: l } = i; s.method = o.toUpperCase(), s.body = a === "application/x-www-form-urlencoded" ? I1(l) : l } return new Request(r, s) } function I1(t) { let e = new URLSearchParams; for (let [n, i] of t.entries()) e.append(n, i instanceof File ? i.name : i); return e } function mP(t, e, n, i, r) { let s = {}, o = null, a, l = !1, c = {}; return n.forEach((u, d) => { let f = e[d].route.id; if (ee(!Wr(u), "Cannot handle redirect results in processLoaderData"), Ks(u)) { let h = Lr(t, f), m = u.error; i && (m = Object.values(i)[0], i = void 0), o = o || {}, o[h.route.id] == null && (o[h.route.id] = m), s[f] = void 0, l || (l = !0, a = L1(u.error) ? u.error.status : 500), u.headers && (c[f] = u.headers) } else Ki(u) ? (r.set(f, u.deferredData), s[f] = u.deferredData.data) : s[f] = u.data, u.statusCode != null && u.statusCode !== 200 && !l && (a = u.statusCode), u.headers && (c[f] = u.headers) }), i && (o = i, s[Object.keys(i)[0]] = void 0), { loaderData: s, errors: o, statusCode: a || 200, loaderHeaders: c } } function hg(t, e, n, i, r, s, o, a) { let { loaderData: l, errors: c } = mP(e, n, i, r, a); for (let u = 0; u < s.length; u++) { let { key: d, match: f } = s[u]; ee(o !== void 0 && o[u] !== void 0, "Did not find corresponding fetcher result"); let h = o[u]; if (Ks(h)) { let m = Lr(t.matches, f == null ? void 0 : f.route.id); c && c[m.route.id] || (c = se({}, c, { [m.route.id]: h.error })), t.fetchers.delete(d) } else if (Wr(h)) ee(!1, "Unhandled fetcher revalidation redirect"); else if (Ki(h)) ee(!1, "Unhandled fetcher deferred data"); else { let m = { state: "idle", data: h.data, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, " _hasFetcherDoneAnything ": !0 }; t.fetchers.set(d, m) } } return { loaderData: l, errors: c } } function pg(t, e, n, i) { let r = se({}, e); for (let s of n) { let o = s.route.id; if (e.hasOwnProperty(o) ? e[o] !== void 0 && (r[o] = e[o]) : t[o] !== void 0 && s.route.loader && (r[o] = t[o]), i && i.hasOwnProperty(o)) break } return r } function Lr(t, e) { return (e ? t.slice(0, t.findIndex(i => i.route.id === e) + 1) : [...t]).reverse().find(i => i.route.hasErrorBoundary === !0) || t[0] } function mg(t) { let e = t.find(n => n.index || !n.path || n.path === "/") || { id: "__shim-error-route__" }; return { matches: [{ params: {}, pathname: "", pathnameBase: "", route: e }], route: e } } function ln(t, e) { let { pathname: n, routeId: i, method: r, type: s } = e === void 0 ? {} : e, o = "Unknown Server Error", a = "Unknown @remix-run/router error"; return t === 400 ? (o = "Bad Request", r && n && i ? a = "You made a " + r + ' request to "' + n + '" but ' + ('did not provide a `loader` for route "' + i + '", ') + "so there is no way to handle the request." : s === "defer-action" && (a = "defer() is not supported in actions")) : t === 403 ? (o = "Forbidden", a = 'Route "' + i + '" does not match URL "' + n + '"') : t === 404 ? (o = "Not Found", a = 'No route matches URL "' + n + '"') : t === 405 && (o = "Method Not Allowed", r && n && i ? a = "You made a " + r.toUpperCase() + ' request to "' + n + '" but ' + ('did not provide an `action` for route "' + i + '", ') + "so there is no way to handle the request." : r && (a = 'Invalid request method "' + r.toUpperCase() + '"')), new Gh(t || 500, o, new Error(a), !0) } function gg(t) { for (let e = t.length - 1; e >= 0; e--) { let n = t[e]; if (Wr(n)) return n } } function V1(t) { let e = typeof t == "string" ? Hn(t) : t; return sr(se({}, e, { hash: "" })) } function gP(t, e) { return t.pathname === e.pathname && t.search === e.search && t.hash !== e.hash } function Ki(t) { return t.type === Be.deferred } function Ks(t) { return t.type === Be.error } function Wr(t) { return (t && t.type) === Be.redirect } function yP(t) { return t != null && typeof t.status == "number" && typeof t.statusText == "string" && typeof t.headers == "object" && typeof t.body < "u" } function vP(t) { return sP.has(t) } function Cn(t) { return iP.has(t) } async function yg(t, e, n, i, r, s) { for (let o = 0; o < n.length; o++) { let a = n[o], l = e[o]; if (!l) continue; let c = t.find(d => d.route.id === l.route.id), u = c != null && !F1(c, l) && (s && s[l.route.id]) !== void 0; Ki(a) && (r || u) && await z1(a, i, r).then(d => { d && (n[o] = d || n[o]) }) } } async function z1(t, e, n) { if (n === void 0 && (n = !1), !await t.deferredData.resolveData(e)) { if (n) try { return { type: Be.data, data: t.deferredData.unwrappedData } } catch (r) { return { type: Be.error, error: r } } return { type: Be.data, data: t.deferredData.data } } } function B1(t) { return new URLSearchParams(t).getAll("index").some(e => e === "") } function vg(t, e) { let { route: n, pathname: i, params: r } = t; return { id: n.id, pathname: i, params: r, data: e[n.id], handle: n.handle } } function ff(t, e) { let n = typeof e == "string" ? Hn(e).search : e.search; if (t[t.length - 1].route.index && B1(n || "")) return t[t.length - 1]; let i = R1(t); return i[i.length - 1] }/**
 * React Router v6.9.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function xP(t, e) { return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e } const wP = typeof Object.is == "function" ? Object.is : xP, { useState: bP, useEffect: _P, useLayoutEffect: SP, useDebugValue: kP } = md; function PP(t, e, n) { const i = e(), [{ inst: r }, s] = bP({ inst: { value: i, getSnapshot: e } }); return SP(() => { r.value = i, r.getSnapshot = e, Fu(r) && s({ inst: r }) }, [t, i, e]), _P(() => (Fu(r) && s({ inst: r }), t(() => { Fu(r) && s({ inst: r }) })), [t]), kP(i), i } function Fu(t) { const e = t.getSnapshot, n = t.value; try { const i = e(); return !wP(n, i) } catch { return !0 } } function CP(t, e, n) { return e() } const MP = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", TP = !MP, EP = TP ? CP : PP, DP = "useSyncExternalStore" in md ? (t => t.useSyncExternalStore)(md) : EP, Qh = M.createContext(null), qh = M.createContext(null), H1 = M.createContext(null), jc = M.createContext(null), Ac = M.createContext({ outlet: null, matches: [] }), W1 = M.createContext(null); function hf() { return hf = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]) } return t }, hf.apply(this, arguments) } function Zh() { return M.useContext(jc) != null } function OP() { return Zh() || ee(!1), M.useContext(jc).location } function RP(t, e) { Zh() || ee(!1); let { navigator: n } = M.useContext(H1), i = M.useContext(qh), { matches: r } = M.useContext(Ac), s = r[r.length - 1], o = s ? s.params : {}; s && s.pathname; let a = s ? s.pathnameBase : "/"; s && s.route; let l = OP(), c; if (e) { var u; let p = typeof e == "string" ? Hn(e) : e; a === "/" || (u = p.pathname) != null && u.startsWith(a) || ee(!1), c = p } else c = l; let d = c.pathname || "/", f = a === "/" ? d : d.slice(a.length) || "/", h = Rr(t, { pathname: f }), m = NP(h && h.map(p => Object.assign({}, p, { params: Object.assign({}, o, p.params), pathname: qi([a, n.encodeLocation ? n.encodeLocation(p.pathname).pathname : p.pathname]), pathnameBase: p.pathnameBase === "/" ? a : qi([a, n.encodeLocation ? n.encodeLocation(p.pathnameBase).pathname : p.pathnameBase]) })), r, i || void 0); return e && m ? M.createElement(jc.Provider, { value: { location: hf({ pathname: "/", search: "", hash: "", state: null, key: "default" }, c), navigationType: Ne.Pop } }, m) : m } function LP() { let t = $1(), e = L1(t) ? t.status + " " + t.statusText : t instanceof Error ? t.message : JSON.stringify(t), n = t instanceof Error ? t.stack : null, r = { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" }, s = null; return M.createElement(M.Fragment, null, M.createElement("h2", null, "Unexpected Application Error!"), M.createElement("h3", { style: { fontStyle: "italic" } }, e), n ? M.createElement("pre", { style: r }, n) : null, s) } class jP extends M.Component { constructor(e) { super(e), this.state = { location: e.location, error: e.error } } static getDerivedStateFromError(e) { return { error: e } } static getDerivedStateFromProps(e, n) { return n.location !== e.location ? { error: e.error, location: e.location } : { error: e.error || n.error, location: n.location } } componentDidCatch(e, n) { console.error("React Router caught the following error during render", e, n) } render() { return this.state.error ? M.createElement(Ac.Provider, { value: this.props.routeContext }, M.createElement(W1.Provider, { value: this.state.error, children: this.props.component })) : this.props.children } } function AP(t) { let { routeContext: e, match: n, children: i } = t, r = M.useContext(Qh); return r && r.static && r.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (r.staticContext._deepestRenderedBoundaryId = n.route.id), M.createElement(Ac.Provider, { value: e }, i) } function NP(t, e, n) { if (e === void 0 && (e = []), t == null) if (n != null && n.errors) t = n.matches; else return null; let i = t, r = n == null ? void 0 : n.errors; if (r != null) { let s = i.findIndex(o => o.route.id && (r == null ? void 0 : r[o.route.id])); s >= 0 || ee(!1), i = i.slice(0, Math.min(i.length, s + 1)) } return i.reduceRight((s, o, a) => { let l = o.route.id ? r == null ? void 0 : r[o.route.id] : null, c = null; n && (o.route.ErrorBoundary ? c = M.createElement(o.route.ErrorBoundary, null) : o.route.errorElement ? c = o.route.errorElement : c = M.createElement(LP, null)); let u = e.concat(i.slice(0, a + 1)), d = () => { let f = s; return l ? f = c : o.route.Component ? f = M.createElement(o.route.Component, null) : o.route.element && (f = o.route.element), M.createElement(AP, { match: o, routeContext: { outlet: s, matches: u }, children: f }) }; return n && (o.route.ErrorBoundary || o.route.errorElement || a === 0) ? M.createElement(jP, { location: n.location, component: c, error: l, children: d(), routeContext: { outlet: null, matches: u } }) : d() }, null) } var xg; (function (t) { t.UseBlocker = "useBlocker", t.UseRevalidator = "useRevalidator" })(xg || (xg = {})); var Ql; (function (t) { t.UseBlocker = "useBlocker", t.UseLoaderData = "useLoaderData", t.UseActionData = "useActionData", t.UseRouteError = "useRouteError", t.UseNavigation = "useNavigation", t.UseRouteLoaderData = "useRouteLoaderData", t.UseMatches = "useMatches", t.UseRevalidator = "useRevalidator" })(Ql || (Ql = {})); function FP(t) { let e = M.useContext(qh); return e || ee(!1), e } function IP(t) { let e = M.useContext(Ac); return e || ee(!1), e } function VP(t) { let e = IP(), n = e.matches[e.matches.length - 1]; return n.route.id || ee(!1), n.route.id } function $1() { var t; let e = M.useContext(W1), n = FP(Ql.UseRouteError), i = VP(Ql.UseRouteError); return e || ((t = n.errors) == null ? void 0 : t[i]) } function zP(t) { let { fallbackElement: e, router: n } = t, i = M.useCallback(() => n.state, [n]), r = DP(n.subscribe, i, i), s = M.useMemo(() => ({ createHref: n.createHref, encodeLocation: n.encodeLocation, go: l => n.navigate(l), push: (l, c, u) => n.navigate(l, { state: c, preventScrollReset: u == null ? void 0 : u.preventScrollReset }), replace: (l, c, u) => n.navigate(l, { replace: !0, state: c, preventScrollReset: u == null ? void 0 : u.preventScrollReset }) }), [n]), o = n.basename || "/", a = M.useMemo(() => ({ router: n, navigator: s, static: !1, basename: o }), [n, s, o]); return M.createElement(M.Fragment, null, M.createElement(Qh.Provider, { value: a }, M.createElement(qh.Provider, { value: r }, M.createElement(HP, { basename: n.basename, location: n.state.location, navigationType: n.state.historyAction, navigator: s }, n.state.initialized ? M.createElement(WP, null) : e))), null) } function BP(t) { ee(!1) } function HP(t) { let { basename: e = "/", children: n = null, location: i, navigationType: r = Ne.Pop, navigator: s, static: o = !1 } = t; Zh() && ee(!1); let a = e.replace(/^\/*/, "/"), l = M.useMemo(() => ({ basename: a, navigator: s, static: o }), [a, s, o]); typeof i == "string" && (i = Hn(i)); let { pathname: c = "/", search: u = "", hash: d = "", state: f = null, key: h = "default" } = i, m = M.useMemo(() => { let p = Lc(c, a); return p == null ? null : { location: { pathname: p, search: u, hash: d, state: f, key: h }, navigationType: r } }, [a, c, u, d, f, h, r]); return m == null ? null : M.createElement(H1.Provider, { value: l }, M.createElement(jc.Provider, { children: n, value: m })) } function WP(t) { let { children: e, location: n } = t, i = M.useContext(Qh), r = i && !e ? i.router.routes : pf(e); return RP(r, n) } var wg; (function (t) { t[t.pending = 0] = "pending", t[t.success = 1] = "success", t[t.error = 2] = "error" })(wg || (wg = {})); new Promise(() => { }); function pf(t, e) { e === void 0 && (e = []); let n = []; return M.Children.forEach(t, (i, r) => { if (!M.isValidElement(i)) return; if (i.type === M.Fragment) { n.push.apply(n, pf(i.props.children, e)); return } i.type !== BP && ee(!1), !i.props.index || !i.props.children || ee(!1); let s = [...e, r], o = { id: i.props.id || s.join("-"), caseSensitive: i.props.caseSensitive, element: i.props.element, Component: i.props.Component, index: i.props.index, path: i.props.path, loader: i.props.loader, action: i.props.action, errorElement: i.props.errorElement, ErrorBoundary: i.props.ErrorBoundary, hasErrorBoundary: i.props.ErrorBoundary != null || i.props.errorElement != null, shouldRevalidate: i.props.shouldRevalidate, handle: i.props.handle, lazy: i.props.lazy }; i.props.children && (o.children = pf(i.props.children, s)), n.push(o) }), n } function $P(t) { return !!t.ErrorBoundary || !!t.errorElement }/**
 * React Router DOM v6.9.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function mf() { return mf = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]) } return t }, mf.apply(this, arguments) } function UP(t, e) { return dP({ basename: e == null ? void 0 : e.basename, history: Ek({ window: e == null ? void 0 : e.window }), hydrationData: (e == null ? void 0 : e.hydrationData) || YP(), routes: t, detectErrorBoundary: $P }).initialize() } function YP() { var t; let e = (t = window) == null ? void 0 : t.__staticRouterHydrationData; return e && e.errors && (e = mf({}, e, { errors: KP(e.errors) })), e } function KP(t) { if (!t) return null; let e = Object.entries(t), n = {}; for (let [i, r] of e) if (r && r.__type === "RouteErrorResponse") n[i] = new Gh(r.status, r.statusText, r.data, r.internal === !0); else if (r && r.__type === "Error") { let s = new Error(r.message); s.stack = "", n[i] = s } else n[i] = r; return n } var bg; (function (t) { t.UseScrollRestoration = "useScrollRestoration", t.UseSubmitImpl = "useSubmitImpl", t.UseFetcher = "useFetcher" })(bg || (bg = {})); var _g; (function (t) { t.UseFetchers = "useFetchers", t.UseScrollRestoration = "useScrollRestoration" })(_g || (_g = {})); var Ee = {}, Jh = {}, Ko = {}, Xo = {}, U1 = "Expected a function", Sg = 0 / 0, XP = "[object Symbol]", GP = /^\s+|\s+$/g, QP = /^[-+]0x[0-9a-f]+$/i, qP = /^0b[01]+$/i, ZP = /^0o[0-7]+$/i, JP = parseInt, eC = typeof ha == "object" && ha && ha.Object === Object && ha, tC = typeof self == "object" && self && self.Object === Object && self, nC = eC || tC || Function("return this")(), iC = Object.prototype, rC = iC.toString, sC = Math.max, oC = Math.min, Iu = function () { return nC.Date.now() }; function aC(t, e, n) { var i, r, s, o, a, l, c = 0, u = !1, d = !1, f = !0; if (typeof t != "function") throw new TypeError(U1); e = kg(e) || 0, ql(n) && (u = !!n.leading, d = "maxWait" in n, s = d ? sC(kg(n.maxWait) || 0, e) : s, f = "trailing" in n ? !!n.trailing : f); function h(k) { var S = i, P = r; return i = r = void 0, c = k, o = t.apply(P, S), o } function m(k) { return c = k, a = setTimeout(y, e), u ? h(k) : o } function p(k) { var S = k - l, P = k - c, T = e - S; return d ? oC(T, s - P) : T } function x(k) { var S = k - l, P = k - c; return l === void 0 || S >= e || S < 0 || d && P >= s } function y() { var k = Iu(); if (x(k)) return g(k); a = setTimeout(y, p(k)) } function g(k) { return a = void 0, f && i ? h(k) : (i = r = void 0, o) } function v() { a !== void 0 && clearTimeout(a), c = 0, i = l = r = a = void 0 } function b() { return a === void 0 ? o : g(Iu()) } function _() { var k = Iu(), S = x(k); if (i = arguments, r = this, l = k, S) { if (a === void 0) return m(l); if (d) return a = setTimeout(y, e), h(l) } return a === void 0 && (a = setTimeout(y, e)), o } return _.cancel = v, _.flush = b, _ } function lC(t, e, n) { var i = !0, r = !0; if (typeof t != "function") throw new TypeError(U1); return ql(n) && (i = "leading" in n ? !!n.leading : i, r = "trailing" in n ? !!n.trailing : r), aC(t, e, { leading: i, maxWait: e, trailing: r }) } function ql(t) { var e = typeof t; return !!t && (e == "object" || e == "function") } function cC(t) { return !!t && typeof t == "object" } function uC(t) { return typeof t == "symbol" || cC(t) && rC.call(t) == XP } function kg(t) { if (typeof t == "number") return t; if (uC(t)) return Sg; if (ql(t)) { var e = typeof t.valueOf == "function" ? t.valueOf() : t; t = ql(e) ? e + "" : e } if (typeof t != "string") return t === 0 ? t : +t; t = t.replace(GP, ""); var n = qP.test(t); return n || ZP.test(t) ? JP(t.slice(2), n ? 2 : 8) : QP.test(t) ? Sg : +t } var dC = lC, Go = {}; Object.defineProperty(Go, "__esModule", { value: !0 }); Go.addPassiveEventListener = function (e, n, i) { var r = function () { var s = !1; try { var o = Object.defineProperty({}, "passive", { get: function () { s = !0 } }); window.addEventListener("test", null, o) } catch { } return s }(); e.addEventListener(n, i, r ? { passive: !0 } : !1) }; Go.removePassiveEventListener = function (e, n, i) { e.removeEventListener(n, i) }; Object.defineProperty(Xo, "__esModule", { value: !0 }); var fC = dC, hC = mC(fC), pC = Go; function mC(t) { return t && t.__esModule ? t : { default: t } } var gC = function (e) { var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66; return (0, hC.default)(e, n) }, be = { spyCallbacks: [], spySetState: [], scrollSpyContainers: [], mount: function (e, n) { if (e) { var i = gC(function (r) { be.scrollHandler(e) }, n); be.scrollSpyContainers.push(e), (0, pC.addPassiveEventListener)(e, "scroll", i) } }, isMounted: function (e) { return be.scrollSpyContainers.indexOf(e) !== -1 }, currentPositionX: function (e) { if (e === document) { var n = window.pageYOffset !== void 0, i = (document.compatMode || "") === "CSS1Compat"; return n ? window.pageXOffset : i ? document.documentElement.scrollLeft : document.body.scrollLeft } else return e.scrollLeft }, currentPositionY: function (e) { if (e === document) { var n = window.pageXOffset !== void 0, i = (document.compatMode || "") === "CSS1Compat"; return n ? window.pageYOffset : i ? document.documentElement.scrollTop : document.body.scrollTop } else return e.scrollTop }, scrollHandler: function (e) { var n = be.scrollSpyContainers[be.scrollSpyContainers.indexOf(e)].spyCallbacks || []; n.forEach(function (i) { return i(be.currentPositionX(e), be.currentPositionY(e)) }) }, addStateHandler: function (e) { be.spySetState.push(e) }, addSpyHandler: function (e, n) { var i = be.scrollSpyContainers[be.scrollSpyContainers.indexOf(n)]; i.spyCallbacks || (i.spyCallbacks = []), i.spyCallbacks.push(e), e(be.currentPositionX(n), be.currentPositionY(n)) }, updateStates: function () { be.spySetState.forEach(function (e) { return e() }) }, unmount: function (e, n) { be.scrollSpyContainers.forEach(function (i) { return i.spyCallbacks && i.spyCallbacks.length && i.spyCallbacks.indexOf(n) > -1 && i.spyCallbacks.splice(i.spyCallbacks.indexOf(n), 1) }), be.spySetState && be.spySetState.length && be.spySetState.indexOf(e) > -1 && be.spySetState.splice(be.spySetState.indexOf(e), 1), document.removeEventListener("scroll", be.scrollHandler) }, update: function () { return be.scrollSpyContainers.forEach(function (e) { return be.scrollHandler(e) }) } }; Xo.default = be; var as = {}, Qo = {}; Object.defineProperty(Qo, "__esModule", { value: !0 }); var yC = function (e, n) { var i = e.indexOf("#") === 0 ? e.substring(1) : e, r = i ? "#" + i : "", s = window && window.location, o = r ? s.pathname + s.search + r : s.pathname + s.search; n ? history.pushState(history.state, "", o) : history.replaceState(history.state, "", o) }, vC = function () { return window.location.hash.replace(/^#/, "") }, xC = function (e) { return function (n) { return e.contains ? e != n && e.contains(n) : !!(e.compareDocumentPosition(n) & 16) } }, wC = function (e) { return getComputedStyle(e).position !== "static" }, Vu = function (e, n) { for (var i = e.offsetTop, r = e.offsetParent; r && !n(r);)i += r.offsetTop, r = r.offsetParent; return { offsetTop: i, offsetParent: r } }, bC = function (e, n, i) { if (i) return e === document ? n.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? n.offsetLeft : n.offsetLeft - e.offsetLeft; if (e === document) return n.getBoundingClientRect().top + (window.scrollY || window.pageYOffset); if (wC(e)) { if (n.offsetParent !== e) { var r = function (u) { return u === e || u === document }, s = Vu(n, r), o = s.offsetTop, a = s.offsetParent; if (a !== e) throw new Error("Seems containerElement is not an ancestor of the Element"); return o } return n.offsetTop } if (n.offsetParent === e.offsetParent) return n.offsetTop - e.offsetTop; var l = function (u) { return u === document }; return Vu(n, l).offsetTop - Vu(e, l).offsetTop }; Qo.default = { updateHash: yC, getHash: vC, filterElementInContainer: xC, scrollOffset: bC }; var Nc = {}, ep = {}; Object.defineProperty(ep, "__esModule", { value: !0 }); ep.default = { defaultEasing: function (e) { return e < .5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2 }, linear: function (e) { return e }, easeInQuad: function (e) { return e * e }, easeOutQuad: function (e) { return e * (2 - e) }, easeInOutQuad: function (e) { return e < .5 ? 2 * e * e : -1 + (4 - 2 * e) * e }, easeInCubic: function (e) { return e * e * e }, easeOutCubic: function (e) { return --e * e * e + 1 }, easeInOutCubic: function (e) { return e < .5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1 }, easeInQuart: function (e) { return e * e * e * e }, easeOutQuart: function (e) { return 1 - --e * e * e * e }, easeInOutQuart: function (e) { return e < .5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e }, easeInQuint: function (e) { return e * e * e * e * e }, easeOutQuint: function (e) { return 1 + --e * e * e * e * e }, easeInOutQuint: function (e) { return e < .5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e } }; var tp = {}; Object.defineProperty(tp, "__esModule", { value: !0 }); var _C = Go, SC = ["mousedown", "mousewheel", "touchmove", "keydown"]; tp.default = { subscribe: function (e) { return typeof document < "u" && SC.forEach(function (n) { return (0, _C.addPassiveEventListener)(document, n, e) }) } }; var qo = {}; Object.defineProperty(qo, "__esModule", { value: !0 }); var gf = { registered: {}, scrollEvent: { register: function (e, n) { gf.registered[e] = n }, remove: function (e) { gf.registered[e] = null } } }; qo.default = gf; Object.defineProperty(Nc, "__esModule", { value: !0 }); var kC = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]) } return t }, PC = Qo; Fc(PC); var CC = ep, Pg = Fc(CC), MC = tp, TC = Fc(MC), EC = qo, dn = Fc(EC); function Fc(t) { return t && t.__esModule ? t : { default: t } } var Y1 = function (e) { return Pg.default[e.smooth] || Pg.default.defaultEasing }, DC = function (e) { return typeof e == "function" ? e : function () { return e } }, OC = function () { if (typeof window < "u") return window.requestAnimationFrame || window.webkitRequestAnimationFrame }, yf = function () { return OC() || function (t, e, n) { window.setTimeout(t, n || 1e3 / 60, new Date().getTime()) } }(), K1 = function () { return { currentPosition: 0, startPosition: 0, targetPosition: 0, progress: 0, duration: 0, cancel: !1, target: null, containerElement: null, to: null, start: null, delta: null, percent: null, delayTimeout: null } }, X1 = function (e) { var n = e.data.containerElement; if (n && n !== document && n !== document.body) return n.scrollLeft; var i = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat"; return i ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft }, G1 = function (e) { var n = e.data.containerElement; if (n && n !== document && n !== document.body) return n.scrollTop; var i = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat"; return i ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop }, RC = function (e) { var n = e.data.containerElement; if (n && n !== document && n !== document.body) return n.scrollWidth - n.offsetWidth; var i = document.body, r = document.documentElement; return Math.max(i.scrollWidth, i.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth) }, LC = function (e) { var n = e.data.containerElement; if (n && n !== document && n !== document.body) return n.scrollHeight - n.offsetHeight; var i = document.body, r = document.documentElement; return Math.max(i.scrollHeight, i.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight) }, jC = function t(e, n, i) { var r = n.data; if (!n.ignoreCancelEvents && r.cancel) { dn.default.registered.end && dn.default.registered.end(r.to, r.target, r.currentPositionY); return } if (r.delta = Math.round(r.targetPosition - r.startPosition), r.start === null && (r.start = i), r.progress = i - r.start, r.percent = r.progress >= r.duration ? 1 : e(r.progress / r.duration), r.currentPosition = r.startPosition + Math.ceil(r.delta * r.percent), r.containerElement && r.containerElement !== document && r.containerElement !== document.body ? n.horizontal ? r.containerElement.scrollLeft = r.currentPosition : r.containerElement.scrollTop = r.currentPosition : n.horizontal ? window.scrollTo(r.currentPosition, 0) : window.scrollTo(0, r.currentPosition), r.percent < 1) { var s = t.bind(null, e, n); yf.call(window, s); return } dn.default.registered.end && dn.default.registered.end(r.to, r.target, r.currentPosition) }, np = function (e) { e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null }, Zo = function (e, n, i, r) { if (n.data = n.data || K1(), window.clearTimeout(n.data.delayTimeout), TC.default.subscribe(function () { n.data.cancel = !0 }), np(n), n.data.start = null, n.data.cancel = !1, n.data.startPosition = n.horizontal ? X1(n) : G1(n), n.data.targetPosition = n.absolute ? e : e + n.data.startPosition, n.data.startPosition === n.data.targetPosition) { dn.default.registered.end && dn.default.registered.end(n.data.to, n.data.target, n.data.currentPosition); return } n.data.delta = Math.round(n.data.targetPosition - n.data.startPosition), n.data.duration = DC(n.duration)(n.data.delta), n.data.duration = isNaN(parseFloat(n.data.duration)) ? 1e3 : parseFloat(n.data.duration), n.data.to = i, n.data.target = r; var s = Y1(n), o = jC.bind(null, s, n); if (n && n.delay > 0) { n.data.delayTimeout = window.setTimeout(function () { dn.default.registered.begin && dn.default.registered.begin(n.data.to, n.data.target), yf.call(window, o) }, n.delay); return } dn.default.registered.begin && dn.default.registered.begin(n.data.to, n.data.target), yf.call(window, o) }, Ic = function (e) { return e = kC({}, e), e.data = e.data || K1(), e.absolute = !0, e }, AC = function (e) { Zo(0, Ic(e)) }, NC = function (e, n) { Zo(e, Ic(n)) }, FC = function (e) { e = Ic(e), np(e), Zo(e.horizontal ? RC(e) : LC(e), e) }, IC = function (e, n) { n = Ic(n), np(n); var i = n.horizontal ? X1(n) : G1(n); Zo(e + i, n) }; Nc.default = { animateTopScroll: Zo, getAnimationType: Y1, scrollToTop: AC, scrollToBottom: FC, scrollTo: NC, scrollMore: IC }; Object.defineProperty(as, "__esModule", { value: !0 }); var VC = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]) } return t }, zC = Qo, BC = ip(zC), HC = Nc, WC = ip(HC), $C = qo, Oa = ip($C); function ip(t) { return t && t.__esModule ? t : { default: t } } var Ra = {}, Cg = void 0; as.default = { unmount: function () { Ra = {} }, register: function (e, n) { Ra[e] = n }, unregister: function (e) { delete Ra[e] }, get: function (e) { return Ra[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0] }, setActiveLink: function (e) { return Cg = e }, getActiveLink: function () { return Cg }, scrollTo: function (e, n) { var i = this.get(e); if (!i) { console.warn("target Element not found"); return } n = VC({}, n, { absolute: !1 }); var r = n.containerId, s = n.container, o = void 0; r ? o = document.getElementById(r) : s && s.nodeType ? o = s : o = document, n.absolute = !0; var a = n.horizontal, l = BC.default.scrollOffset(o, i, a) + (n.offset || 0); if (!n.smooth) { Oa.default.registered.begin && Oa.default.registered.begin(e, i), o === document ? n.horizontal ? window.scrollTo(l, 0) : window.scrollTo(0, l) : o.scrollTop = l, Oa.default.registered.end && Oa.default.registered.end(e, i); return } WC.default.animateTopScroll(l, n, e, i) } }; var Jr = {}, UC = { get exports() { return Jr }, set exports(t) { Jr = t } }, YC = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED", KC = YC, XC = KC; function Q1() { } function q1() { } q1.resetWarningCache = Q1; var GC = function () { function t(i, r, s, o, a, l) { if (l !== XC) { var c = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"); throw c.name = "Invariant Violation", c } } t.isRequired = t; function e() { return t } var n = { array: t, bigint: t, bool: t, func: t, number: t, object: t, string: t, symbol: t, any: t, arrayOf: e, element: t, elementType: t, instanceOf: e, node: t, objectOf: e, oneOf: e, oneOfType: e, shape: e, exact: e, checkPropTypes: q1, resetWarningCache: Q1 }; return n.PropTypes = n, n }; UC.exports = GC(); var Vc = {}; Object.defineProperty(Vc, "__esModule", { value: !0 }); var QC = Qo, zu = qC(QC); function qC(t) { return t && t.__esModule ? t : { default: t } } var ZC = { mountFlag: !1, initialized: !1, scroller: null, containers: {}, mount: function (e) { this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0 }, mapContainer: function (e, n) { this.containers[e] = n }, isMounted: function () { return this.mountFlag }, isInitialized: function () { return this.initialized }, initStateFromHash: function () { var e = this, n = this.getHash(); n ? window.setTimeout(function () { e.scrollTo(n, !0), e.initialized = !0 }, 10) : this.initialized = !0 }, scrollTo: function (e, n) { var i = this.scroller, r = i.get(e); if (r && (n || e !== i.getActiveLink())) { var s = this.containers[e] || document; i.scrollTo(e, { container: s }) } }, getHash: function () { return zu.default.getHash() }, changeHash: function (e, n) { this.isInitialized() && zu.default.getHash() !== e && zu.default.updateHash(e, n) }, handleHashChange: function () { this.scrollTo(this.getHash()) }, unmount: function () { this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange) } }; Vc.default = ZC; Object.defineProperty(Ko, "__esModule", { value: !0 }); var La = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]) } return t }, JC = function () { function t(e, n) { for (var i = 0; i < n.length; i++) { var r = n[i]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), eM = M, Mg = Jo(eM), tM = Xo, ja = Jo(tM), nM = as, iM = Jo(nM), rM = Jr, ve = Jo(rM), sM = Vc, Yn = Jo(sM); function Jo(t) { return t && t.__esModule ? t : { default: t } } function oM(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function aM(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e && (typeof e == "object" || typeof e == "function") ? e : t } function lM(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) } var Tg = { to: ve.default.string.isRequired, containerId: ve.default.string, container: ve.default.object, activeClass: ve.default.string, activeStyle: ve.default.object, spy: ve.default.bool, horizontal: ve.default.bool, smooth: ve.default.oneOfType([ve.default.bool, ve.default.string]), offset: ve.default.number, delay: ve.default.number, isDynamic: ve.default.bool, onClick: ve.default.func, duration: ve.default.oneOfType([ve.default.number, ve.default.func]), absolute: ve.default.bool, onSetActive: ve.default.func, onSetInactive: ve.default.func, ignoreCancelEvents: ve.default.bool, hashSpy: ve.default.bool, saveHashHistory: ve.default.bool, spyThrottle: ve.default.number }; Ko.default = function (t, e) { var n = e || iM.default, i = function (s) { lM(o, s); function o(a) { oM(this, o); var l = aM(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this, a)); return r.call(l), l.state = { active: !1 }, l } return JC(o, [{ key: "getScrollSpyContainer", value: function () { var l = this.props.containerId, c = this.props.container; return l && !c ? document.getElementById(l) : c && c.nodeType ? c : document } }, { key: "componentDidMount", value: function () { if (this.props.spy || this.props.hashSpy) { var l = this.getScrollSpyContainer(); ja.default.isMounted(l) || ja.default.mount(l, this.props.spyThrottle), this.props.hashSpy && (Yn.default.isMounted() || Yn.default.mount(n), Yn.default.mapContainer(this.props.to, l)), ja.default.addSpyHandler(this.spyHandler, l), this.setState({ container: l }) } } }, { key: "componentWillUnmount", value: function () { ja.default.unmount(this.stateHandler, this.spyHandler) } }, { key: "render", value: function () { var l = ""; this.state && this.state.active ? l = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : l = this.props.className; var c = {}; this.state && this.state.active ? c = La({}, this.props.style, this.props.activeStyle) : c = La({}, this.props.style); var u = La({}, this.props); for (var d in Tg) u.hasOwnProperty(d) && delete u[d]; return u.className = l, u.style = c, u.onClick = this.handleClick, Mg.default.createElement(t, u) } }]), o }(Mg.default.PureComponent), r = function () { var o = this; this.scrollTo = function (a, l) { n.scrollTo(a, La({}, o.state, l)) }, this.handleClick = function (a) { o.props.onClick && o.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), o.scrollTo(o.props.to, o.props) }, this.spyHandler = function (a, l) { var c = o.getScrollSpyContainer(); if (!(Yn.default.isMounted() && !Yn.default.isInitialized())) { var u = o.props.horizontal, d = o.props.to, f = null, h = void 0, m = void 0; if (u) { var p = 0, x = 0, y = 0; if (c.getBoundingClientRect) { var g = c.getBoundingClientRect(); y = g.left } if (!f || o.props.isDynamic) { if (f = n.get(d), !f) return; var v = f.getBoundingClientRect(); p = v.left - y + a, x = p + v.width } var b = a - o.props.offset; h = b >= Math.floor(p) && b < Math.floor(x), m = b < Math.floor(p) || b >= Math.floor(x) } else { var _ = 0, k = 0, S = 0; if (c.getBoundingClientRect) { var P = c.getBoundingClientRect(); S = P.top } if (!f || o.props.isDynamic) { if (f = n.get(d), !f) return; var T = f.getBoundingClientRect(); _ = T.top - S + l, k = _ + T.height } var D = l - o.props.offset; h = D >= Math.floor(_) && D < Math.floor(k), m = D < Math.floor(_) || D >= Math.floor(k) } var A = n.getActiveLink(); if (m) { if (d === A && n.setActiveLink(void 0), o.props.hashSpy && Yn.default.getHash() === d) { var V = o.props.saveHashHistory, q = V === void 0 ? !1 : V; Yn.default.changeHash("", q) } o.props.spy && o.state.active && (o.setState({ active: !1 }), o.props.onSetInactive && o.props.onSetInactive(d, f)) } if (h && (A !== d || o.state.active === !1)) { n.setActiveLink(d); var G = o.props.saveHashHistory, z = G === void 0 ? !1 : G; o.props.hashSpy && Yn.default.changeHash(d, z), o.props.spy && (o.setState({ active: !0 }), o.props.onSetActive && o.props.onSetActive(d, f)) } } } }; return i.propTypes = Tg, i.defaultProps = { offset: 0 }, i }; Object.defineProperty(Jh, "__esModule", { value: !0 }); var cM = M, Eg = Z1(cM), uM = Ko, dM = Z1(uM); function Z1(t) { return t && t.__esModule ? t : { default: t } } function fM(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function Dg(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e && (typeof e == "object" || typeof e == "function") ? e : t } function hM(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) } var pM = function (t) { hM(e, t); function e() { var n, i, r, s; fM(this, e); for (var o = arguments.length, a = Array(o), l = 0; l < o; l++)a[l] = arguments[l]; return s = (i = (r = Dg(this, (n = e.__proto__ || Object.getPrototypeOf(e)).call.apply(n, [this].concat(a))), r), r.render = function () { return Eg.default.createElement("a", r.props, r.props.children) }, i), Dg(r, s) } return e }(Eg.default.Component); Jh.default = (0, dM.default)(pM); var rp = {}; Object.defineProperty(rp, "__esModule", { value: !0 }); var mM = function () { function t(e, n) { for (var i = 0; i < n.length; i++) { var r = n[i]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), gM = M, Og = J1(gM), yM = Ko, vM = J1(yM); function J1(t) { return t && t.__esModule ? t : { default: t } } function xM(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function wM(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e && (typeof e == "object" || typeof e == "function") ? e : t } function bM(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) } var _M = function (t) { bM(e, t); function e() { return xM(this, e), wM(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)) } return mM(e, [{ key: "render", value: function () { return Og.default.createElement("input", this.props, this.props.children) } }]), e }(Og.default.Component); rp.default = (0, vM.default)(_M); var sp = {}, zc = {}; Object.defineProperty(zc, "__esModule", { value: !0 }); var SM = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]) } return t }, kM = function () { function t(e, n) { for (var i = 0; i < n.length; i++) { var r = n[i]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), PM = M, Rg = Bc(PM), CM = Pl; Bc(CM); var MM = as, Lg = Bc(MM), TM = Jr, jg = Bc(TM); function Bc(t) { return t && t.__esModule ? t : { default: t } } function EM(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function DM(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e && (typeof e == "object" || typeof e == "function") ? e : t } function OM(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) } zc.default = function (t) { var e = function (n) { OM(i, n); function i(r) { EM(this, i); var s = DM(this, (i.__proto__ || Object.getPrototypeOf(i)).call(this, r)); return s.childBindings = { domNode: null }, s } return kM(i, [{ key: "componentDidMount", value: function () { if (typeof window > "u") return !1; this.registerElems(this.props.name) } }, { key: "componentDidUpdate", value: function (s) { this.props.name !== s.name && this.registerElems(this.props.name) } }, { key: "componentWillUnmount", value: function () { if (typeof window > "u") return !1; Lg.default.unregister(this.props.name) } }, { key: "registerElems", value: function (s) { Lg.default.register(s, this.childBindings.domNode) } }, { key: "render", value: function () { return Rg.default.createElement(t, SM({}, this.props, { parentBindings: this.childBindings })) } }]), i }(Rg.default.Component); return e.propTypes = { name: jg.default.string, id: jg.default.string }, e }; Object.defineProperty(sp, "__esModule", { value: !0 }); var Ag = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]) } return t }, RM = function () { function t(e, n) { for (var i = 0; i < n.length; i++) { var r = n[i]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), LM = M, Ng = op(LM), jM = zc, AM = op(jM), NM = Jr, Fg = op(NM); function op(t) { return t && t.__esModule ? t : { default: t } } function FM(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function IM(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e && (typeof e == "object" || typeof e == "function") ? e : t } function VM(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) } var ew = function (t) { VM(e, t); function e() { return FM(this, e), IM(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)) } return RM(e, [{ key: "render", value: function () { var i = this, r = Ag({}, this.props); return r.parentBindings && delete r.parentBindings, Ng.default.createElement("div", Ag({}, r, { ref: function (o) { i.props.parentBindings.domNode = o } }), this.props.children) } }]), e }(Ng.default.Component); ew.propTypes = { name: Fg.default.string, id: Fg.default.string }; sp.default = (0, AM.default)(ew); var Bu = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]) } return t }, Ig = function () { function t(e, n) { for (var i = 0; i < n.length; i++) { var r = n[i]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(); function Vg(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function zg(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e && (typeof e == "object" || typeof e == "function") ? e : t } function Bg(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) } var Aa = M, Ri = Xo, Hu = as, _e = Jr, Kn = Vc, Hg = { to: _e.string.isRequired, containerId: _e.string, container: _e.object, activeClass: _e.string, spy: _e.bool, smooth: _e.oneOfType([_e.bool, _e.string]), offset: _e.number, delay: _e.number, isDynamic: _e.bool, onClick: _e.func, duration: _e.oneOfType([_e.number, _e.func]), absolute: _e.bool, onSetActive: _e.func, onSetInactive: _e.func, ignoreCancelEvents: _e.bool, hashSpy: _e.bool, spyThrottle: _e.number }, zM = { Scroll: function (e, n) { console.warn("Helpers.Scroll is deprecated since v1.7.0"); var i = n || Hu, r = function (o) { Bg(a, o); function a(l) { Vg(this, a); var c = zg(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, l)); return s.call(c), c.state = { active: !1 }, c } return Ig(a, [{ key: "getScrollSpyContainer", value: function () { var c = this.props.containerId, u = this.props.container; return c ? document.getElementById(c) : u && u.nodeType ? u : document } }, { key: "componentDidMount", value: function () { if (this.props.spy || this.props.hashSpy) { var c = this.getScrollSpyContainer(); Ri.isMounted(c) || Ri.mount(c, this.props.spyThrottle), this.props.hashSpy && (Kn.isMounted() || Kn.mount(i), Kn.mapContainer(this.props.to, c)), this.props.spy && Ri.addStateHandler(this.stateHandler), Ri.addSpyHandler(this.spyHandler, c), this.setState({ container: c }) } } }, { key: "componentWillUnmount", value: function () { Ri.unmount(this.stateHandler, this.spyHandler) } }, { key: "render", value: function () { var c = ""; this.state && this.state.active ? c = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : c = this.props.className; var u = Bu({}, this.props); for (var d in Hg) u.hasOwnProperty(d) && delete u[d]; return u.className = c, u.onClick = this.handleClick, Aa.createElement(e, u) } }]), a }(Aa.Component), s = function () { var a = this; this.scrollTo = function (l, c) { i.scrollTo(l, Bu({}, a.state, c)) }, this.handleClick = function (l) { a.props.onClick && a.props.onClick(l), l.stopPropagation && l.stopPropagation(), l.preventDefault && l.preventDefault(), a.scrollTo(a.props.to, a.props) }, this.stateHandler = function () { i.getActiveLink() !== a.props.to && (a.state !== null && a.state.active && a.props.onSetInactive && a.props.onSetInactive(), a.setState({ active: !1 })) }, this.spyHandler = function (l) { var c = a.getScrollSpyContainer(); if (!(Kn.isMounted() && !Kn.isInitialized())) { var u = a.props.to, d = null, f = 0, h = 0, m = 0; if (c.getBoundingClientRect) { var p = c.getBoundingClientRect(); m = p.top } if (!d || a.props.isDynamic) { if (d = i.get(u), !d) return; var x = d.getBoundingClientRect(); f = x.top - m + l, h = f + x.height } var y = l - a.props.offset, g = y >= Math.floor(f) && y < Math.floor(h), v = y < Math.floor(f) || y >= Math.floor(h), b = i.getActiveLink(); if (v) return u === b && i.setActiveLink(void 0), a.props.hashSpy && Kn.getHash() === u && Kn.changeHash(), a.props.spy && a.state.active && (a.setState({ active: !1 }), a.props.onSetInactive && a.props.onSetInactive()), Ri.updateStates(); if (g && b !== u) return i.setActiveLink(u), a.props.hashSpy && Kn.changeHash(u), a.props.spy && (a.setState({ active: !0 }), a.props.onSetActive && a.props.onSetActive(u)), Ri.updateStates() } } }; return r.propTypes = Hg, r.defaultProps = { offset: 0 }, r }, Element: function (e) { console.warn("Helpers.Element is deprecated since v1.7.0"); var n = function (i) { Bg(r, i); function r(s) { Vg(this, r); var o = zg(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, s)); return o.childBindings = { domNode: null }, o } return Ig(r, [{ key: "componentDidMount", value: function () { if (typeof window > "u") return !1; this.registerElems(this.props.name) } }, { key: "componentDidUpdate", value: function (o) { this.props.name !== o.name && this.registerElems(this.props.name) } }, { key: "componentWillUnmount", value: function () { if (typeof window > "u") return !1; Hu.unregister(this.props.name) } }, { key: "registerElems", value: function (o) { Hu.register(o, this.childBindings.domNode) } }, { key: "render", value: function () { return Aa.createElement(e, Bu({}, this.props, { parentBindings: this.childBindings })) } }]), r }(Aa.Component); return n.propTypes = { name: _e.string, id: _e.string }, n } }, BM = zM; Object.defineProperty(Ee, "__esModule", { value: !0 }); Ee.Helpers = Ee.ScrollElement = Ee.ScrollLink = Ee.animateScroll = Ee.scrollSpy = Ee.Events = Ee.scroller = Ee.Element = Ee.Button = vf = Ee.Link = void 0; var HM = Jh, tw = vn(HM), WM = rp, nw = vn(WM), $M = sp, iw = vn($M), UM = as, rw = vn(UM), YM = qo, sw = vn(YM), KM = Xo, ow = vn(KM), XM = Nc, aw = vn(XM), GM = Ko, lw = vn(GM), QM = zc, cw = vn(QM), qM = BM, uw = vn(qM); function vn(t) { return t && t.__esModule ? t : { default: t } } var vf = Ee.Link = tw.default; Ee.Button = nw.default; Ee.Element = iw.default; Ee.scroller = rw.default; Ee.Events = sw.default; Ee.scrollSpy = ow.default; Ee.animateScroll = aw.default; Ee.ScrollLink = lw.default; Ee.ScrollElement = cw.default; Ee.Helpers = uw.default; Ee.default = { Link: tw.default, Button: nw.default, Element: iw.default, scroller: rw.default, Events: sw.default, scrollSpy: ow.default, animateScroll: aw.default, ScrollLink: lw.default, ScrollElement: cw.default, Helpers: uw.default }; const Wg = ["Home", "Utility", "Versions", "Tokenomics", "Audit", "Roadmap", "Team", "About"], ZM = () => w.jsx("header", { className: "bg-primary lg:bg-transparent lg:fixed lg:bg-opacity-80 w-full flex justify-center z-50 lg:h-24", children: w.jsx("div", { className: "screen-optz w-full flex ", children: w.jsxs("div", { className: "navbar lg:mt-8  ", children: [w.jsx("div", { className: "navbar-start w-2/12 relative ", children: w.jsx("img", { className: "h-38 w-15 lg:w-43 lg:h-40 lg:absolute lg:-bottom-24 ", src: "/logo.gif" }) }), w.jsx("div", { className: "navbar-center bg-primary rounded-full w-8/12 hidden lg:flex text-texter justify-center", children: w.jsx("ul", { className: "menu menu-horizontal px-1 py-2 w-full flex justify-around", children: Wg.map((t, e) => w.jsx(vf, { activeClass: "link-active", isDynamic: !0, offset: -70, spy: !0, smooth: !0, duration: 400, to: `${t.toLowerCase()}`, className: "uppercase py-2 font-bold  text-accent font-sans cursor-pointer text-sm tracking-widest border-b-2 border-transparent hover:border-accent transition-colors duration-[600ms]", children: t }, e)) }) }), w.jsxs("div", { className: "lg:flex navbar-end w-10/12 lg:w-2/12 text-texter justify-end ", children: [w.jsxs("div", { className: "lg:hidden dropdown", children: [w.jsx("label", { tabIndex: 0, className: "btn btn-ghost btn-circle text-accent", children: w.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-8 w-8", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: w.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M4 6h16M4 12h16M4 18h7" }) }) }), w.jsxs("ul", { tabIndex: 0, className: "menu menu-compact dropdown-content top-10 -left-[10rem] mt-3 p-4 shadow bg-primary rounded-lg w-52", children: [Wg.map((t, e) => t === "Roadmap" ? w.jsx("a", { href: `#${t.toLowerCase()}`, className: "uppercase py-4 font-bold  text-accent font-sans cursor-pointer text-md tracking-widest border-b-2 border-transparent hover:border-accent transition-colors duration-[600ms]", children: t }) : w.jsx(vf, { spy: !0, offset: -70, duration: 5e3, activeClass: " border-accent", smooth: !0, to: `${t.toLowerCase()}`, className: "uppercase py-4 font-bold  text-accent font-sans cursor-pointer text-md tracking-widest border-b-2 border-transparent hover:border-accent transition-colors duration-[600ms]", children: t }, e)), w.jsx("button", { className: "btn btn-secondary  hover:bg-secondary-content text-accent w-40 rounded-full", children: w.jsx("a", { href: "https://t.me/ttfbotbot", target: "_blank", children: "Try TTF Bot" }) })] })] }), w.jsx("button", { className: "hidden lg:flex btn hover:bg-secondary btn-primary text-accent w-40 rounded-full", children: w.jsx("a", { href: "https://t.me/ttfbotbot", target: "_blank", children: "Try TTF Bot" }) })] })] }) }) }); var dw = { color: void 0, size: void 0, className: void 0, style: void 0, attr: void 0 }, $g = Et.createContext && Et.createContext(dw), gi = globalThis && globalThis.__assign || function () { return gi = Object.assign || function (t) { for (var e, n = 1, i = arguments.length; n < i; n++) { e = arguments[n]; for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]) } return t }, gi.apply(this, arguments) }, JM = globalThis && globalThis.__rest || function (t, e) { var n = {}; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && e.indexOf(i) < 0 && (n[i] = t[i]); if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var r = 0, i = Object.getOwnPropertySymbols(t); r < i.length; r++)e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(t, i[r]) && (n[i[r]] = t[i[r]]); return n }; function fw(t) { return t && t.map(function (e, n) { return Et.createElement(e.tag, gi({ key: n }, e.attr), fw(e.child)) }) } function xn(t) { return function (e) { return Et.createElement(eT, gi({ attr: gi({}, t.attr) }, e), fw(t.child)) } } function eT(t) { var e = function (n) { var i = t.attr, r = t.size, s = t.title, o = JM(t, ["attr", "size", "title"]), a = r || n.size || "1em", l; return n.className && (l = n.className), t.className && (l = (l ? l + " " : "") + t.className), Et.createElement("svg", gi({ stroke: "currentColor", fill: "currentColor", strokeWidth: "0" }, n.attr, i, o, { className: l, style: gi(gi({ color: t.color || n.color }, n.style), t.style), height: a, width: a, xmlns: "http://www.w3.org/2000/svg" }), s && Et.createElement("title", null, s), t.children) }; return $g !== void 0 ? Et.createElement($g.Consumer, null, function (n) { return e(n) }) : e(dw) } function tT(t) { return xn({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M448.61 225.62c26.87.18 35.57-7.43 38.92-12.37 12.47-16.32-7.06-47.6-52.85-71.33 17.76-33.58 30.11-63.68 36.34-85.3 3.38-11.83 1.09-19 .45-20.25-1.72 10.52-15.85 48.46-48.2 100.05-25-11.22-56.52-20.1-93.77-23.8-8.94-16.94-34.88-63.86-60.48-88.93C252.18 7.14 238.7 1.07 228.18.22h-.05c-13.83-1.55-22.67 5.85-27.4 11-17.2 18.53-24.33 48.87-25 84.07-7.24-12.35-17.17-24.63-28.5-25.93h-.18c-20.66-3.48-38.39 29.22-36 81.29-38.36 1.38-71 5.75-93 11.23-9.9 2.45-16.22 7.27-17.76 9.72 1-.38 22.4-9.22 111.56-9.22 5.22 53 29.75 101.82 26 93.19-9.73 15.4-38.24 62.36-47.31 97.7-5.87 22.88-4.37 37.61.15 47.14 5.57 12.75 16.41 16.72 23.2 18.26 25 5.71 55.38-3.63 86.7-21.14-7.53 12.84-13.9 28.51-9.06 39.34 7.31 19.65 44.49 18.66 88.44-9.45 20.18 32.18 40.07 57.94 55.7 74.12a39.79 39.79 0 0 0 8.75 7.09c5.14 3.21 8.58 3.37 8.58 3.37-8.24-6.75-34-38-62.54-91.78 22.22-16 45.65-38.87 67.47-69.27 122.82 4.6 143.29-24.76 148-31.64 14.67-19.88 3.43-57.44-57.32-93.69zm-77.85 106.22c23.81-37.71 30.34-67.77 29.45-92.33 27.86 17.57 47.18 37.58 49.06 58.83 1.14 12.93-8.1 29.12-78.51 33.5zM216.9 387.69c9.76-6.23 19.53-13.12 29.2-20.49 6.68 13.33 13.6 26.1 20.6 38.19-40.6 21.86-68.84 12.76-49.8-17.7zm215-171.35c-10.29-5.34-21.16-10.34-32.38-15.05a722.459 722.459 0 0 0 22.74-36.9c39.06 24.1 45.9 53.18 9.64 51.95zM279.18 398c-5.51-11.35-11-23.5-16.5-36.44 43.25 1.27 62.42-18.73 63.28-20.41 0 .07-25 15.64-62.53 12.25a718.78 718.78 0 0 0 85.06-84q13.06-15.31 24.93-31.11c-.36-.29-1.54-3-16.51-12-51.7 60.27-102.34 98-132.75 115.92-20.59-11.18-40.84-31.78-55.71-61.49-20-39.92-30-82.39-31.57-116.07 12.3.91 25.27 2.17 38.85 3.88-22.29 36.8-14.39 63-13.47 64.23 0-.07-.95-29.17 20.14-59.57a695.23 695.23 0 0 0 44.67 152.84c.93-.38 1.84.88 18.67-8.25-26.33-74.47-33.76-138.17-34-173.43 20-12.42 48.18-19.8 81.63-17.81 44.57 2.67 86.36 15.25 116.32 30.71q-10.69 15.66-23.33 32.47C365.63 152 339.1 145.84 337.5 146c.11 0 25.9 14.07 41.52 47.22a717.63 717.63 0 0 0-115.34-31.71 646.608 646.608 0 0 0-39.39-6.05c-.07.45-1.81 1.85-2.16 20.33C300 190.28 358.78 215.68 389.36 233c.74 23.55-6.95 51.61-25.41 79.57-24.6 37.31-56.39 67.23-84.77 85.43zm27.4-287c-44.56-1.66-73.58 7.43-94.69 20.67 2-52.3 21.31-76.38 38.21-75.28C267 52.15 305 108.55 306.58 111zm-130.65 3.1c.48 12.11 1.59 24.62 3.21 37.28-14.55-.85-28.74-1.25-42.4-1.26-.08 3.24-.12-51 24.67-49.59h.09c5.76 1.09 10.63 6.88 14.43 13.57zm-28.06 162c20.76 39.7 43.3 60.57 65.25 72.31-46.79 24.76-77.53 20-84.92 4.51-.2-.21-11.13-15.3 19.67-76.81zm210.06 74.8" } }] })(t) } function nT(t) { return xn({ tag: "svg", attr: { viewBox: "0 0 496 512" }, child: [{ tag: "path", attr: { d: "M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm121.8 169.9l-40.7 191.8c-3 13.6-11.1 16.9-22.4 10.5l-62-45.7-29.9 28.8c-3.3 3.3-6.1 6.1-12.5 6.1l4.4-63.1 114.9-103.8c5-4.4-1.1-6.9-7.7-2.5l-142 89.4-61.2-19.1c-13.3-4.2-13.6-13.3 2.8-19.7l239.1-92.2c11.1-4 20.8 2.7 17.2 19.5z" } }] })(t) } function iT(t) { return xn({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z" } }] })(t) } const rT = () => w.jsxs("footer", { className: "footer items-center p-4 bg-primary text-netural", children: [w.jsxs("div", { className: "items-center grid-flow-col", children: [w.jsx("img", { src: "/logo-side.png", className: "h-12 w-12 bg-primary rounded-full p-1 pt-1.5 " }), w.jsx("p", { children: "Copyright Â© 2023 - All right reserved for TrackTheFunds Bot" })] }), w.jsxs("div", { className: "grid-flow-col gap-4 md:place-self-center md:justify-self-end text-2xl", children: [w.jsx("a", { href: "https://t.me/TTFBotOfficial", target: "_blank", children: w.jsx(nT, {}) }), w.jsx("a", { href: "https://twitter.com/TTFBot", children: w.jsx(iT, {}) }), w.jsx("a", { href: "https://medium.com/@track.the.funds.bot/track-the-funds-ttf-bot-making-cryptocurrency-trading-safer-39d152cde756", children: w.jsx(tT, {}) })] })] }), hw = M.createContext({ transformPagePoint: t => t, isStatic: !1, reducedMotion: "never" }), Hc = M.createContext({}), ap = M.createContext(null), Wc = typeof document < "u", xf = Wc ? M.useLayoutEffect : M.useEffect, pw = M.createContext({ strict: !1 }); function sT(t, e, n, i) { const { visualElement: r } = M.useContext(Hc), s = M.useContext(pw), o = M.useContext(ap), a = M.useContext(hw).reducedMotion, l = M.useRef(); i = i || s.renderer, !l.current && i && (l.current = i(t, { visualState: e, parent: r, props: n, presenceContext: o, blockInitialAnimation: o ? o.initial === !1 : !1, reducedMotionConfig: a })); const c = l.current; return M.useInsertionEffect(() => { c && c.update(n, o) }), xf(() => { c && c.render() }), M.useEffect(() => { c && c.updateFeatures() }), (window.HandoffAppearAnimations ? xf : M.useEffect)(() => { c && c.animationState && c.animationState.animateChanges() }), c } function jr(t) { return typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current") } function oT(t, e, n) { return M.useCallback(i => { i && t.mount && t.mount(i), e && (i ? e.mount(i) : e.unmount()), n && (typeof n == "function" ? n(i) : jr(n) && (n.current = i)) }, [e]) } function Do(t) { return typeof t == "string" || Array.isArray(t) } function $c(t) { return typeof t == "object" && typeof t.start == "function" } const lp = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], cp = ["initial", ...lp]; function Uc(t) { return $c(t.animate) || cp.some(e => Do(t[e])) } function mw(t) { return !!(Uc(t) || t.variants) } function aT(t, e) { if (Uc(t)) { const { initial: n, animate: i } = t; return { initial: n === !1 || Do(n) ? n : void 0, animate: Do(i) ? i : void 0 } } return t.inherit !== !1 ? e : {} } function lT(t) { const { initial: e, animate: n } = aT(t, M.useContext(Hc)); return M.useMemo(() => ({ initial: e, animate: n }), [Ug(e), Ug(n)]) } function Ug(t) { return Array.isArray(t) ? t.join(" ") : t } const Yg = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, Oo = {}; for (const t in Yg) Oo[t] = { isEnabled: e => Yg[t].some(n => !!e[n]) }; function cT(t) { for (const e in t) Oo[e] = { ...Oo[e], ...t[e] } } function up(t) { const e = M.useRef(null); return e.current === null && (e.current = t()), e.current } const Xs = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; let uT = 1; function dT() { return up(() => { if (Xs.hasEverUpdated) return uT++ }) } const gw = M.createContext({}), yw = M.createContext({}), fT = Symbol.for("motionComponentSymbol"); function hT({ preloadedFeatures: t, createVisualElement: e, useRender: n, useVisualState: i, Component: r }) { t && cT(t); function s(a, l) { let c; const u = { ...M.useContext(hw), ...a, layoutId: pT(a) }, { isStatic: d } = u, f = lT(a), h = d ? void 0 : dT(), m = i(a, d); if (!d && Wc) { f.visualElement = sT(r, m, u, e); const p = M.useContext(yw), x = M.useContext(pw).strict; f.visualElement && (c = f.visualElement.loadFeatures(u, x, t, h, p)) } return M.createElement(Hc.Provider, { value: f }, c && f.visualElement ? M.createElement(c, { visualElement: f.visualElement, ...u }) : null, n(r, a, h, oT(m, f.visualElement, l), m, d, f.visualElement)) } const o = M.forwardRef(s); return o[fT] = r, o } function pT({ layoutId: t }) { const e = M.useContext(gw).id; return e && t !== void 0 ? e + "-" + t : t } function mT(t) { function e(i, r = {}) { return hT(t(i, r)) } if (typeof Proxy > "u") return e; const n = new Map; return new Proxy(e, { get: (i, r) => (n.has(r) || n.set(r, e(r)), n.get(r)) }) } const gT = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function dp(t) { return typeof t != "string" || t.includes("-") ? !1 : !!(gT.indexOf(t) > -1 || /[A-Z]/.test(t)) } const Zl = {}; function yT(t) { Object.assign(Zl, t) } const Yc = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], fr = new Set(Yc); function vw(t, { layout: e, layoutId: n }) { return fr.has(t) || t.startsWith("origin") || (e || n !== void 0) && (!!Zl[t] || t === "opacity") } const kt = t => !!(t && t.getVelocity), vT = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, xT = Yc.length; function wT(t, { enableHardwareAcceleration: e = !0, allowTransformNone: n = !0 }, i, r) { let s = ""; for (let o = 0; o < xT; o++) { const a = Yc[o]; if (t[a] !== void 0) { const l = vT[a] || a; s += `${l}(${t[a]}) ` } } return e && !t.z && (s += "translateZ(0)"), s = s.trim(), r ? s = r(t, i ? "" : s) : n && i && (s = "none"), s } const xw = t => e => typeof e == "string" && e.startsWith(t), ww = xw("--"), wf = xw("var(--"), bT = (t, e) => e && typeof t == "number" ? e.transform(t) : t, or = (t, e, n) => Math.min(Math.max(n, t), e), hr = { test: t => typeof t == "number", parse: parseFloat, transform: t => t }, Gs = { ...hr, transform: t => or(0, 1, t) }, Na = { ...hr, default: 1 }, Qs = t => Math.round(t * 1e5) / 1e5, Ro = /(-)?([\d]*\.?[\d])+/g, bf = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi, _T = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i; function ea(t) { return typeof t == "string" } const ta = t => ({ test: e => ea(e) && e.endsWith(t) && e.split(" ").length === 1, parse: parseFloat, transform: e => `${e}${t}` }), Gn = ta("deg"), mn = ta("%"), X = ta("px"), ST = ta("vh"), kT = ta("vw"), Kg = { ...mn, parse: t => mn.parse(t) / 100, transform: t => mn.transform(t * 100) }, Xg = { ...hr, transform: Math.round }, bw = { borderWidth: X, borderTopWidth: X, borderRightWidth: X, borderBottomWidth: X, borderLeftWidth: X, borderRadius: X, radius: X, borderTopLeftRadius: X, borderTopRightRadius: X, borderBottomRightRadius: X, borderBottomLeftRadius: X, width: X, maxWidth: X, height: X, maxHeight: X, size: X, top: X, right: X, bottom: X, left: X, padding: X, paddingTop: X, paddingRight: X, paddingBottom: X, paddingLeft: X, margin: X, marginTop: X, marginRight: X, marginBottom: X, marginLeft: X, rotate: Gn, rotateX: Gn, rotateY: Gn, rotateZ: Gn, scale: Na, scaleX: Na, scaleY: Na, scaleZ: Na, skew: Gn, skewX: Gn, skewY: Gn, distance: X, translateX: X, translateY: X, translateZ: X, x: X, y: X, z: X, perspective: X, transformPerspective: X, opacity: Gs, originX: Kg, originY: Kg, originZ: X, zIndex: Xg, fillOpacity: Gs, strokeOpacity: Gs, numOctaves: Xg }; function fp(t, e, n, i) { const { style: r, vars: s, transform: o, transformOrigin: a } = t; let l = !1, c = !1, u = !0; for (const d in e) { const f = e[d]; if (ww(d)) { s[d] = f; continue } const h = bw[d], m = bT(f, h); if (fr.has(d)) { if (l = !0, o[d] = m, !u) continue; f !== (h.default || 0) && (u = !1) } else d.startsWith("origin") ? (c = !0, a[d] = m) : r[d] = m } if (e.transform || (l || i ? r.transform = wT(t.transform, n, u, i) : r.transform && (r.transform = "none")), c) { const { originX: d = "50%", originY: f = "50%", originZ: h = 0 } = a; r.transformOrigin = `${d} ${f} ${h}` } } const hp = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function _w(t, e, n) { for (const i in e) !kt(e[i]) && !vw(i, n) && (t[i] = e[i]) } function PT({ transformTemplate: t }, e, n) { return M.useMemo(() => { const i = hp(); return fp(i, e, { enableHardwareAcceleration: !n }, t), Object.assign({}, i.vars, i.style) }, [e]) } function CT(t, e, n) { const i = t.style || {}, r = {}; return _w(r, i, t), Object.assign(r, PT(t, e, n)), t.transformValues ? t.transformValues(r) : r } function MT(t, e, n) { const i = {}, r = CT(t, e, n); return t.drag && t.dragListener !== !1 && (i.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = t.drag === !0 ? "none" : `pan-${t.drag === "x" ? "y" : "x"}`), t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (i.tabIndex = 0), i.style = r, i } const TT = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "transformValues", "custom", "inherit", "onLayoutAnimationStart", "onLayoutAnimationComplete", "onLayoutMeasure", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "ignoreStrict", "viewport"]); function Jl(t) { return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || TT.has(t) } let Sw = t => !Jl(t); function ET(t) { t && (Sw = e => e.startsWith("on") ? !Jl(e) : t(e)) } try { ET(require("@emotion/is-prop-valid").default) } catch { } function DT(t, e, n) { const i = {}; for (const r in t) r === "values" && typeof t.values == "object" || (Sw(r) || n === !0 && Jl(r) || !e && !Jl(r) || t.draggable && r.startsWith("onDrag")) && (i[r] = t[r]); return i } function Gg(t, e, n) { return typeof t == "string" ? t : X.transform(e + n * t) } function OT(t, e, n) { const i = Gg(e, t.x, t.width), r = Gg(n, t.y, t.height); return `${i} ${r}` } const RT = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, LT = { offset: "strokeDashoffset", array: "strokeDasharray" }; function jT(t, e, n = 1, i = 0, r = !0) { t.pathLength = 1; const s = r ? RT : LT; t[s.offset] = X.transform(-i); const o = X.transform(e), a = X.transform(n); t[s.array] = `${o} ${a}` } function pp(t, { attrX: e, attrY: n, originX: i, originY: r, pathLength: s, pathSpacing: o = 1, pathOffset: a = 0, ...l }, c, u, d) { if (fp(t, l, c, d), u) { t.style.viewBox && (t.attrs.viewBox = t.style.viewBox); return } t.attrs = t.style, t.style = {}; const { attrs: f, style: h, dimensions: m } = t; f.transform && (m && (h.transform = f.transform), delete f.transform), m && (i !== void 0 || r !== void 0 || h.transform) && (h.transformOrigin = OT(m, i !== void 0 ? i : .5, r !== void 0 ? r : .5)), e !== void 0 && (f.x = e), n !== void 0 && (f.y = n), s !== void 0 && jT(f, s, o, a, !1) } const kw = () => ({ ...hp(), attrs: {} }), mp = t => typeof t == "string" && t.toLowerCase() === "svg"; function AT(t, e, n, i) { const r = M.useMemo(() => { const s = kw(); return pp(s, e, { enableHardwareAcceleration: !1 }, mp(i), t.transformTemplate), { ...s.attrs, style: { ...s.style } } }, [e]); if (t.style) { const s = {}; _w(s, t.style, t), r.style = { ...s, ...r.style } } return r } function NT(t = !1) { return (n, i, r, s, { latestValues: o }, a) => { const c = (dp(n) ? AT : MT)(i, o, a, n), d = { ...DT(i, typeof n == "string", t), ...c, ref: s }, { children: f } = i, h = M.useMemo(() => kt(f) ? f.get() : f, [f]); return r && (d["data-projection-id"] = r), M.createElement(n, { ...d, children: h }) } } const gp = t => t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(); function Pw(t, { style: e, vars: n }, i, r) { Object.assign(t.style, e, r && r.getProjectionStyles(i)); for (const s in n) t.style.setProperty(s, n[s]) } const Cw = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function Mw(t, e, n, i) { Pw(t, e, void 0, i); for (const r in e.attrs) t.setAttribute(Cw.has(r) ? r : gp(r), e.attrs[r]) } function yp(t, e) { const { style: n } = t, i = {}; for (const r in n) (kt(n[r]) || e.style && kt(e.style[r]) || vw(r, t)) && (i[r] = n[r]); return i } function Tw(t, e) { const n = yp(t, e); for (const i in t) if (kt(t[i]) || kt(e[i])) { const r = i === "x" || i === "y" ? "attr" + i.toUpperCase() : i; n[r] = t[i] } return n } function vp(t, e, n, i = {}, r = {}) { return typeof e == "function" && (e = e(n !== void 0 ? n : t.custom, i, r)), typeof e == "string" && (e = t.variants && t.variants[e]), typeof e == "function" && (e = e(n !== void 0 ? n : t.custom, i, r)), e } const ec = t => Array.isArray(t), FT = t => !!(t && typeof t == "object" && t.mix && t.toValue), IT = t => ec(t) ? t[t.length - 1] || 0 : t; function yl(t) { const e = kt(t) ? t.get() : t; return FT(e) ? e.toValue() : e } function VT({ scrapeMotionValuesFromProps: t, createRenderState: e, onMount: n }, i, r, s) { const o = { latestValues: zT(i, r, s, t), renderState: e() }; return n && (o.mount = a => n(i, a, o)), o } const Ew = t => (e, n) => { const i = M.useContext(Hc), r = M.useContext(ap), s = () => VT(t, e, i, r); return n ? s() : up(s) }; function zT(t, e, n, i) { const r = {}, s = i(t, {}); for (const f in s) r[f] = yl(s[f]); let { initial: o, animate: a } = t; const l = Uc(t), c = mw(t); e && c && !l && t.inherit !== !1 && (o === void 0 && (o = e.initial), a === void 0 && (a = e.animate)); let u = n ? n.initial === !1 : !1; u = u || o === !1; const d = u ? a : o; return d && typeof d != "boolean" && !$c(d) && (Array.isArray(d) ? d : [d]).forEach(h => { const m = vp(t, h); if (!m) return; const { transitionEnd: p, transition: x, ...y } = m; for (const g in y) { let v = y[g]; if (Array.isArray(v)) { const b = u ? v.length - 1 : 0; v = v[b] } v !== null && (r[g] = v) } for (const g in p) r[g] = p[g] }), r } const BT = { useVisualState: Ew({ scrapeMotionValuesFromProps: Tw, createRenderState: kw, onMount: (t, e, { renderState: n, latestValues: i }) => { try { n.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect() } catch { n.dimensions = { x: 0, y: 0, width: 0, height: 0 } } pp(n, i, { enableHardwareAcceleration: !1 }, mp(e.tagName), t.transformTemplate), Mw(e, n) } }) }, HT = { useVisualState: Ew({ scrapeMotionValuesFromProps: yp, createRenderState: hp }) }; function WT(t, { forwardMotionProps: e = !1 }, n, i) { return { ...dp(t) ? BT : HT, preloadedFeatures: n, useRender: NT(e), createVisualElement: i, Component: t } } function On(t, e, n, i = { passive: !0 }) { return t.addEventListener(e, n, i), () => t.removeEventListener(e, n) } const Dw = t => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1; function Kc(t, e = "page") { return { point: { x: t[e + "X"], y: t[e + "Y"] } } } const $T = t => e => Dw(e) && t(e, Kc(e)); function Nn(t, e, n, i) { return On(t, e, $T(n), i) } const UT = (t, e) => n => e(t(n)), yi = (...t) => t.reduce(UT); function Ow(t) { let e = null; return () => { const n = () => { e = null }; return e === null ? (e = t, n) : !1 } } const Qg = Ow("dragHorizontal"), qg = Ow("dragVertical"); function Rw(t) { let e = !1; if (t === "y") e = qg(); else if (t === "x") e = Qg(); else { const n = Qg(), i = qg(); n && i ? e = () => { n(), i() } : (n && n(), i && i()) } return e } function Lw() { const t = Rw(!0); return t ? (t(), !1) : !0 } class Ei { constructor(e) { this.isMounted = !1, this.node = e } update() { } } function YT(t) { let e = [], n = [], i = 0, r = !1, s = !1; const o = new WeakSet, a = { schedule: (l, c = !1, u = !1) => { const d = u && r, f = d ? e : n; return c && o.add(l), f.indexOf(l) === -1 && (f.push(l), d && r && (i = e.length)), l }, cancel: l => { const c = n.indexOf(l); c !== -1 && n.splice(c, 1), o.delete(l) }, process: l => { if (r) { s = !0; return } if (r = !0, [e, n] = [n, e], n.length = 0, i = e.length, i) for (let c = 0; c < i; c++) { const u = e[c]; u(l), o.has(u) && (a.schedule(u), t()) } r = !1, s && (s = !1, a.process(l)) } }; return a } const ot = { delta: 0, timestamp: 0, isProcessing: !1 }, KT = 40; let _f = !0, Lo = !1; const na = ["read", "update", "preRender", "render", "postRender"], Xc = na.reduce((t, e) => (t[e] = YT(() => Lo = !0), t), {}), Pe = na.reduce((t, e) => { const n = Xc[e]; return t[e] = (i, r = !1, s = !1) => (Lo || GT(), n.schedule(i, r, s)), t }, {}), _i = na.reduce((t, e) => (t[e] = Xc[e].cancel, t), {}), Wu = na.reduce((t, e) => (t[e] = () => Xc[e].process(ot), t), {}), XT = t => Xc[t].process(ot), jw = t => { Lo = !1, ot.delta = _f ? 1e3 / 60 : Math.max(Math.min(t - ot.timestamp, KT), 1), ot.timestamp = t, ot.isProcessing = !0, na.forEach(XT), ot.isProcessing = !1, Lo && (_f = !1, requestAnimationFrame(jw)) }, GT = () => { Lo = !0, _f = !0, ot.isProcessing || requestAnimationFrame(jw) }; function Zg(t, e) { const n = "pointer" + (e ? "enter" : "leave"), i = "onHover" + (e ? "Start" : "End"), r = (s, o) => { if (s.type === "touch" || Lw()) return; const a = t.getProps(); t.animationState && a.whileHover && t.animationState.setActive("whileHover", e), a[i] && Pe.update(() => a[i](s, o)) }; return Nn(t.current, n, r, { passive: !t.getProps()[i] }) } class QT extends Ei { mount() { this.unmount = yi(Zg(this.node, !0), Zg(this.node, !1)) } unmount() { } } class qT extends Ei { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let e = !1; try { e = this.node.current.matches(":focus-visible") } catch { e = !0 } !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = yi(On(this.node.current, "focus", () => this.onFocus()), On(this.node.current, "blur", () => this.onBlur())) } unmount() { } } const Aw = (t, e) => e ? t === e ? !0 : Aw(t, e.parentElement) : !1, Ke = t => t; function $u(t, e) { if (!e) return; const n = new PointerEvent("pointer" + t); e(n, Kc(n)) } class ZT extends Ei { constructor() { super(...arguments), this.removeStartListeners = Ke, this.removeEndListeners = Ke, this.removeAccessibleListeners = Ke, this.startPointerPress = (e, n) => { if (this.removeEndListeners(), this.isPressing) return; const i = this.node.getProps(), s = Nn(window, "pointerup", (a, l) => { if (!this.checkPressEnd()) return; const { onTap: c, onTapCancel: u } = this.node.getProps(); Pe.update(() => { Aw(this.node.current, a.target) ? c && c(a, l) : u && u(a, l) }) }, { passive: !(i.onTap || i.onPointerUp) }), o = Nn(window, "pointercancel", (a, l) => this.cancelPress(a, l), { passive: !(i.onTapCancel || i.onPointerCancel) }); this.removeEndListeners = yi(s, o), this.startPress(e, n) }, this.startAccessiblePress = () => { const e = s => { if (s.key !== "Enter" || this.isPressing) return; const o = a => { a.key !== "Enter" || !this.checkPressEnd() || $u("up", (l, c) => { const { onTap: u } = this.node.getProps(); u && Pe.update(() => u(l, c)) }) }; this.removeEndListeners(), this.removeEndListeners = On(this.node.current, "keyup", o), $u("down", (a, l) => { this.startPress(a, l) }) }, n = On(this.node.current, "keydown", e), i = () => { this.isPressing && $u("cancel", (s, o) => this.cancelPress(s, o)) }, r = On(this.node.current, "blur", i); this.removeAccessibleListeners = yi(n, r) } } startPress(e, n) { this.isPressing = !0; const { onTapStart: i, whileTap: r } = this.node.getProps(); r && this.node.animationState && this.node.animationState.setActive("whileTap", !0), i && Pe.update(() => i(e, n)) } checkPressEnd() { return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !Lw() } cancelPress(e, n) { if (!this.checkPressEnd()) return; const { onTapCancel: i } = this.node.getProps(); i && Pe.update(() => i(e, n)) } mount() { const e = this.node.getProps(), n = Nn(this.node.current, "pointerdown", this.startPointerPress, { passive: !(e.onTapStart || e.onPointerStart) }), i = On(this.node.current, "focus", this.startAccessiblePress); this.removeStartListeners = yi(n, i) } unmount() { this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners() } } const Sf = new WeakMap, Uu = new WeakMap, JT = t => { const e = Sf.get(t.target); e && e(t) }, eE = t => { t.forEach(JT) }; function tE({ root: t, ...e }) { const n = t || document; Uu.has(n) || Uu.set(n, {}); const i = Uu.get(n), r = JSON.stringify(e); return i[r] || (i[r] = new IntersectionObserver(eE, { root: t, ...e })), i[r] } function nE(t, e, n) { const i = tE(e); return Sf.set(t, n), i.observe(t), () => { Sf.delete(t), i.unobserve(t) } } const iE = { some: 0, all: 1 }; class rE extends Ei { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); const { viewport: e = {} } = this.node.getProps(), { root: n, margin: i, amount: r = "some", once: s } = e, o = { root: n ? n.current : void 0, rootMargin: i, threshold: typeof r == "number" ? r : iE[r] }, a = l => { const { isIntersecting: c } = l; if (this.isInView === c || (this.isInView = c, s && !c && this.hasEnteredView)) return; c && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", c); const { onViewportEnter: u, onViewportLeave: d } = this.node.getProps(), f = c ? u : d; f && f(l) }; return nE(this.node.current, o, a) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; const { props: e, prevProps: n } = this.node;["amount", "margin", "root"].some(sE(e, n)) && this.startObserver() } unmount() { } } function sE({ viewport: t = {} }, { viewport: e = {} } = {}) { return n => t[n] !== e[n] } const oE = { inView: { Feature: rE }, tap: { Feature: ZT }, focus: { Feature: qT }, hover: { Feature: QT } }; function Nw(t, e) { if (!Array.isArray(e)) return !1; const n = e.length; if (n !== t.length) return !1; for (let i = 0; i < n; i++)if (e[i] !== t[i]) return !1; return !0 } function aE(t) { const e = {}; return t.values.forEach((n, i) => e[i] = n.get()), e } function lE(t) { const e = {}; return t.values.forEach((n, i) => e[i] = n.getVelocity()), e } function Gc(t, e, n) { const i = t.getProps(); return vp(i, e, n !== void 0 ? n : i.custom, aE(t), lE(t)) } const cE = "framerAppearId", uE = "data-" + gp(cE); let dE = Ke, Qc = Ke; const vi = t => t * 1e3, ar = t => t / 1e3, fE = { current: !1 }, Fw = t => Array.isArray(t) && typeof t[0] == "number"; function Iw(t) { return !!(!t || typeof t == "string" && Vw[t] || Fw(t) || Array.isArray(t) && t.every(Iw)) } const Ls = ([t, e, n, i]) => `cubic-bezier(${t}, ${e}, ${n}, ${i})`, Vw = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: Ls([0, .65, .55, 1]), circOut: Ls([.55, 0, 1, .45]), backIn: Ls([.31, .01, .66, -.59]), backOut: Ls([.33, 1.53, .69, .99]) }; function zw(t) { if (t) return Fw(t) ? Ls(t) : Array.isArray(t) ? t.map(zw) : Vw[t] } function hE(t, e, n, { delay: i = 0, duration: r, repeat: s = 0, repeatType: o = "loop", ease: a, times: l } = {}) { const c = { [e]: n }; l && (c.offset = l); const u = zw(a); return Array.isArray(u) && (c.easing = u), t.animate(c, { delay: i, duration: r, easing: Array.isArray(u) ? "linear" : u, fill: "both", iterations: s + 1, direction: o === "reverse" ? "alternate" : "normal" }) } const Jg = { waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate") }, Yu = {}, Bw = {}; for (const t in Jg) Bw[t] = () => (Yu[t] === void 0 && (Yu[t] = Jg[t]()), Yu[t]); function pE(t, { repeat: e, repeatType: n = "loop" }) { const i = e && n !== "loop" && e % 2 === 1 ? 0 : t.length - 1; return t[i] } const Hw = (t, e, n) => (((1 - 3 * n + 3 * e) * t + (3 * n - 6 * e)) * t + 3 * e) * t, mE = 1e-7, gE = 12; function yE(t, e, n, i, r) { let s, o, a = 0; do o = e + (n - e) / 2, s = Hw(o, i, r) - t, s > 0 ? n = o : e = o; while (Math.abs(s) > mE && ++a < gE); return o } function ia(t, e, n, i) { if (t === e && n === i) return Ke; const r = s => yE(s, 0, 1, t, n); return s => s === 0 || s === 1 ? s : Hw(r(s), e, i) } const vE = ia(.42, 0, 1, 1), xE = ia(0, 0, .58, 1), Ww = ia(.42, 0, .58, 1), wE = t => Array.isArray(t) && typeof t[0] != "number", $w = t => e => e <= .5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2, Uw = t => e => 1 - t(1 - e), Yw = t => 1 - Math.sin(Math.acos(t)), xp = Uw(Yw), bE = $w(xp), Kw = ia(.33, 1.53, .69, .99), wp = Uw(Kw), _E = $w(wp), SE = t => (t *= 2) < 1 ? .5 * wp(t) : .5 * (2 - Math.pow(2, -10 * (t - 1))), kE = { linear: Ke, easeIn: vE, easeInOut: Ww, easeOut: xE, circIn: Yw, circInOut: bE, circOut: xp, backIn: wp, backInOut: _E, backOut: Kw, anticipate: SE }, ey = t => { if (Array.isArray(t)) { Qc(t.length === 4); const [e, n, i, r] = t; return ia(e, n, i, r) } else if (typeof t == "string") return kE[t]; return t }, bp = (t, e) => n => !!(ea(n) && _T.test(n) && n.startsWith(t) || e && Object.prototype.hasOwnProperty.call(n, e)), Xw = (t, e, n) => i => { if (!ea(i)) return i; const [r, s, o, a] = i.match(Ro); return { [t]: parseFloat(r), [e]: parseFloat(s), [n]: parseFloat(o), alpha: a !== void 0 ? parseFloat(a) : 1 } }, PE = t => or(0, 255, t), Ku = { ...hr, transform: t => Math.round(PE(t)) }, Xi = { test: bp("rgb", "red"), parse: Xw("red", "green", "blue"), transform: ({ red: t, green: e, blue: n, alpha: i = 1 }) => "rgba(" + Ku.transform(t) + ", " + Ku.transform(e) + ", " + Ku.transform(n) + ", " + Qs(Gs.transform(i)) + ")" }; function CE(t) { let e = "", n = "", i = "", r = ""; return t.length > 5 ? (e = t.substring(1, 3), n = t.substring(3, 5), i = t.substring(5, 7), r = t.substring(7, 9)) : (e = t.substring(1, 2), n = t.substring(2, 3), i = t.substring(3, 4), r = t.substring(4, 5), e += e, n += n, i += i, r += r), { red: parseInt(e, 16), green: parseInt(n, 16), blue: parseInt(i, 16), alpha: r ? parseInt(r, 16) / 255 : 1 } } const kf = { test: bp("#"), parse: CE, transform: Xi.transform }, Ar = { test: bp("hsl", "hue"), parse: Xw("hue", "saturation", "lightness"), transform: ({ hue: t, saturation: e, lightness: n, alpha: i = 1 }) => "hsla(" + Math.round(t) + ", " + mn.transform(Qs(e)) + ", " + mn.transform(Qs(n)) + ", " + Qs(Gs.transform(i)) + ")" }, ut = { test: t => Xi.test(t) || kf.test(t) || Ar.test(t), parse: t => Xi.test(t) ? Xi.parse(t) : Ar.test(t) ? Ar.parse(t) : kf.parse(t), transform: t => ea(t) ? t : t.hasOwnProperty("red") ? Xi.transform(t) : Ar.transform(t) }, ke = (t, e, n) => -n * t + n * e + t; function Xu(t, e, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t } function ME({ hue: t, saturation: e, lightness: n, alpha: i }) { t /= 360, e /= 100, n /= 100; let r = 0, s = 0, o = 0; if (!e) r = s = o = n; else { const a = n < .5 ? n * (1 + e) : n + e - n * e, l = 2 * n - a; r = Xu(l, a, t + 1 / 3), s = Xu(l, a, t), o = Xu(l, a, t - 1 / 3) } return { red: Math.round(r * 255), green: Math.round(s * 255), blue: Math.round(o * 255), alpha: i } } const Gu = (t, e, n) => { const i = t * t; return Math.sqrt(Math.max(0, n * (e * e - i) + i)) }, TE = [kf, Xi, Ar], EE = t => TE.find(e => e.test(t)); function ty(t) { const e = EE(t); let n = e.parse(t); return e === Ar && (n = ME(n)), n } const Gw = (t, e) => { const n = ty(t), i = ty(e), r = { ...n }; return s => (r.red = Gu(n.red, i.red, s), r.green = Gu(n.green, i.green, s), r.blue = Gu(n.blue, i.blue, s), r.alpha = ke(n.alpha, i.alpha, s), Xi.transform(r)) }, Qw = "${c}", qw = "${n}"; function DE(t) { var e, n; return isNaN(t) && ea(t) && (((e = t.match(Ro)) === null || e === void 0 ? void 0 : e.length) || 0) + (((n = t.match(bf)) === null || n === void 0 ? void 0 : n.length) || 0) > 0 } function tc(t) { typeof t == "number" && (t = `${t}`); const e = []; let n = 0, i = 0; const r = t.match(bf); r && (n = r.length, t = t.replace(bf, Qw), e.push(...r.map(ut.parse))); const s = t.match(Ro); return s && (i = s.length, t = t.replace(Ro, qw), e.push(...s.map(hr.parse))), { values: e, numColors: n, numNumbers: i, tokenised: t } } function Zw(t) { return tc(t).values } function Jw(t) { const { values: e, numColors: n, tokenised: i } = tc(t), r = e.length; return s => { let o = i; for (let a = 0; a < r; a++)o = o.replace(a < n ? Qw : qw, a < n ? ut.transform(s[a]) : Qs(s[a])); return o } } const OE = t => typeof t == "number" ? 0 : t; function RE(t) { const e = Zw(t); return Jw(t)(e.map(OE)) } const Si = { test: DE, parse: Zw, createTransformer: Jw, getAnimatableNone: RE }; function eb(t, e) { return typeof t == "number" ? n => ke(t, e, n) : ut.test(t) ? Gw(t, e) : nb(t, e) } const tb = (t, e) => { const n = [...t], i = n.length, r = t.map((s, o) => eb(s, e[o])); return s => { for (let o = 0; o < i; o++)n[o] = r[o](s); return n } }, LE = (t, e) => { const n = { ...t, ...e }, i = {}; for (const r in n) t[r] !== void 0 && e[r] !== void 0 && (i[r] = eb(t[r], e[r])); return r => { for (const s in i) n[s] = i[s](r); return n } }, nb = (t, e) => { const n = Si.createTransformer(e), i = tc(t), r = tc(e); return i.numColors === r.numColors && i.numNumbers >= r.numNumbers ? yi(tb(i.values, r.values), n) : o => `${o > 0 ? e : t}` }, jo = (t, e, n) => { const i = e - t; return i === 0 ? 1 : (n - t) / i }, ny = (t, e) => n => ke(t, e, n); function jE(t) { return typeof t == "number" ? ny : typeof t == "string" ? ut.test(t) ? Gw : nb : Array.isArray(t) ? tb : typeof t == "object" ? LE : ny } function AE(t, e, n) { const i = [], r = n || jE(t[0]), s = t.length - 1; for (let o = 0; o < s; o++) { let a = r(t[o], t[o + 1]); if (e) { const l = Array.isArray(e) ? e[o] || Ke : e; a = yi(l, a) } i.push(a) } return i } function ib(t, e, { clamp: n = !0, ease: i, mixer: r } = {}) { const s = t.length; if (Qc(s === e.length), s === 1) return () => e[0]; t[0] > t[s - 1] && (t = [...t].reverse(), e = [...e].reverse()); const o = AE(e, i, r), a = o.length, l = c => { let u = 0; if (a > 1) for (; u < t.length - 2 && !(c < t[u + 1]); u++); const d = jo(t[u], t[u + 1], c); return o[u](d) }; return n ? c => l(or(t[0], t[s - 1], c)) : l } function NE(t, e) { const n = t[t.length - 1]; for (let i = 1; i <= e; i++) { const r = jo(0, e, i); t.push(ke(n, 1, r)) } } function FE(t) { const e = [0]; return NE(e, t.length - 1), e } function IE(t, e) { return t.map(n => n * e) } function VE(t, e) { return t.map(() => e || Ww).splice(0, t.length - 1) } function nc({ duration: t = 300, keyframes: e, times: n, ease: i = "easeInOut" }) { const r = wE(i) ? i.map(ey) : ey(i), s = { done: !1, value: e[0] }, o = IE(n && n.length === e.length ? n : FE(e), t), a = ib(o, e, { ease: Array.isArray(r) ? r : VE(e, r) }); return { calculatedDuration: t, next: l => (s.value = a(l), s.done = l >= t, s) } } function rb(t, e) { return e ? t * (1e3 / e) : 0 } const zE = 5; function sb(t, e, n) { const i = Math.max(e - zE, 0); return rb(n - t(i), e - i) } const Qu = .001, BE = .01, iy = 10, HE = .05, WE = 1; function $E({ duration: t = 800, bounce: e = .25, velocity: n = 0, mass: i = 1 }) { let r, s; dE(t <= vi(iy)); let o = 1 - e; o = or(HE, WE, o), t = or(BE, iy, ar(t)), o < 1 ? (r = c => { const u = c * o, d = u * t, f = u - n, h = Pf(c, o), m = Math.exp(-d); return Qu - f / h * m }, s = c => { const d = c * o * t, f = d * n + n, h = Math.pow(o, 2) * Math.pow(c, 2) * t, m = Math.exp(-d), p = Pf(Math.pow(c, 2), o); return (-r(c) + Qu > 0 ? -1 : 1) * ((f - h) * m) / p }) : (r = c => { const u = Math.exp(-c * t), d = (c - n) * t + 1; return -Qu + u * d }, s = c => { const u = Math.exp(-c * t), d = (n - c) * (t * t); return u * d }); const a = 5 / t, l = YE(r, s, a); if (t = vi(t), isNaN(l)) return { stiffness: 100, damping: 10, duration: t }; { const c = Math.pow(l, 2) * i; return { stiffness: c, damping: o * 2 * Math.sqrt(i * c), duration: t } } } const UE = 12; function YE(t, e, n) { let i = n; for (let r = 1; r < UE; r++)i = i - t(i) / e(i); return i } function Pf(t, e) { return t * Math.sqrt(1 - e * e) } const KE = ["duration", "bounce"], XE = ["stiffness", "damping", "mass"]; function ry(t, e) { return e.some(n => t[n] !== void 0) } function GE(t) { let e = { velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: !1, ...t }; if (!ry(t, XE) && ry(t, KE)) { const n = $E(t); e = { ...e, ...n, velocity: 0, mass: 1 }, e.isResolvedFromDuration = !0 } return e } function ob({ keyframes: t, restDelta: e, restSpeed: n, ...i }) { const r = t[0], s = t[t.length - 1], o = { done: !1, value: r }, { stiffness: a, damping: l, mass: c, velocity: u, duration: d, isResolvedFromDuration: f } = GE(i), h = u ? -ar(u) : 0, m = l / (2 * Math.sqrt(a * c)), p = s - r, x = ar(Math.sqrt(a / c)), y = Math.abs(p) < 5; n || (n = y ? .01 : 2), e || (e = y ? .005 : .5); let g; if (m < 1) { const v = Pf(x, m); g = b => { const _ = Math.exp(-m * x * b); return s - _ * ((h + m * x * p) / v * Math.sin(v * b) + p * Math.cos(v * b)) } } else if (m === 1) g = v => s - Math.exp(-x * v) * (p + (h + x * p) * v); else { const v = x * Math.sqrt(m * m - 1); g = b => { const _ = Math.exp(-m * x * b), k = Math.min(v * b, 300); return s - _ * ((h + m * x * p) * Math.sinh(k) + v * p * Math.cosh(k)) / v } } return { calculatedDuration: f && d || null, next: v => { const b = g(v); if (f) o.done = v >= d; else { let _ = h; v !== 0 && (m < 1 ? _ = sb(g, v, b) : _ = 0); const k = Math.abs(_) <= n, S = Math.abs(s - b) <= e; o.done = k && S } return o.value = o.done ? s : b, o } } } function sy({ keyframes: t, velocity: e = 0, power: n = .8, timeConstant: i = 325, bounceDamping: r = 10, bounceStiffness: s = 500, modifyTarget: o, min: a, max: l, restDelta: c = .5, restSpeed: u }) { const d = t[0], f = { done: !1, value: d }, h = P => a !== void 0 && P < a || l !== void 0 && P > l, m = P => a === void 0 ? l : l === void 0 || Math.abs(a - P) < Math.abs(l - P) ? a : l; let p = n * e; const x = d + p, y = o === void 0 ? x : o(x); y !== x && (p = y - d); const g = P => -p * Math.exp(-P / i), v = P => y + g(P), b = P => { const T = g(P), D = v(P); f.done = Math.abs(T) <= c, f.value = f.done ? y : D }; let _, k; const S = P => { h(f.value) && (_ = P, k = ob({ keyframes: [f.value, m(f.value)], velocity: sb(v, P, f.value), damping: r, stiffness: s, restDelta: c, restSpeed: u })) }; return S(0), { calculatedDuration: null, next: P => { let T = !1; return !k && _ === void 0 && (T = !0, b(P), S(P)), _ !== void 0 && P > _ ? k.next(P - _) : (!T && b(P), f) } } } const QE = t => { const e = ({ timestamp: n }) => t(n); return { start: () => Pe.update(e, !0), stop: () => _i.update(e), now: () => ot.isProcessing ? ot.timestamp : performance.now() } }, qE = { decay: sy, inertia: sy, tween: nc, keyframes: nc, spring: ob }, ZE = 2e4; function JE(t) { let e = 0; const n = 50; let i = t.next(e); for (; !i.done && e < ZE;)e += n, i = t.next(e); return e } function ic({ autoplay: t = !0, delay: e = 0, driver: n = QE, keyframes: i, type: r = "keyframes", repeat: s = 0, repeatDelay: o = 0, repeatType: a = "loop", onPlay: l, onStop: c, onComplete: u, onUpdate: d, ...f }) { let h = 1, m = !1, p, x; const y = () => { p && p(), x = new Promise(Y => { p = Y }) }; y(); let g; const v = qE[r] || nc; let b; v !== nc && typeof i[0] != "number" && (b = ib([0, 100], i, { clamp: !1 }), i = [0, 100]); const _ = v({ ...f, keyframes: i }); let k; a === "mirror" && (k = v({ ...f, keyframes: [...i].reverse(), velocity: -(f.velocity || 0) })); let S = "idle", P = null, T = null, D = null; _.calculatedDuration === null && s && (_.calculatedDuration = JE(_)); const { calculatedDuration: A } = _; let V = 1 / 0, q = 1 / 0; A !== null && (V = A + o, q = V * (s + 1) - o); let G = 0; const z = Y => { if (T === null) return; P !== null ? G = P : G = (Y - T) * h, G = Math.max(G - e, 0), S === "finished" && P === null && (G = q); let ae = G, Te = _; if (s) { const tn = G / V; let mr = Math.floor(tn), wn = tn % 1; !wn && tn >= 1 && (wn = 1), wn === 1 && mr--, mr = Math.min(mr, s + 1); const $n = !!(mr % 2); $n && (a === "reverse" ? (wn = 1 - wn, o && (wn -= o / V)) : a === "mirror" && (Te = k)); let ls = or(0, 1, wn); G > q && (ls = a === "reverse" && $n ? 1 : 0), ae = ls * V } const je = Te.next(ae); b && (je.value = b(je.value)); let { done: mt } = je; A !== null && (mt = G >= q); const $e = P === null && (S === "finished" || S === "running" && mt || h < 0 && G <= 0); return d && d(je.value), $e && L(), je }, J = () => { g && g.stop(), g = void 0 }, re = () => { S = "idle", J(), y(), T = D = null }, L = () => { S = "finished", u && u(), J(), y() }, j = () => { if (m) return; g || (g = n(z)); const Y = g.now(); l && l(), S = "running", P !== null ? T = Y - P : T || (T = Y), D = T, P = null, g.start() }; t && j(); const W = { then(Y, ae) { return x.then(Y, ae) }, get time() { return ar(G) }, set time(Y) { Y = vi(Y), G = Y, P !== null || !g || h === 0 ? P = Y : T = g.now() - Y / h }, get speed() { return h }, set speed(Y) { Y === h || !g || (h = Y, W.time = ar(G)) }, get state() { return S }, play: j, pause: () => { S = "paused", P = G }, stop: () => { m = !0, S !== "idle" && (S = "idle", c && c(), re()) }, cancel: () => { D !== null && z(D), re() }, complete: () => { S = "finished" }, sample: Y => (T = 0, z(Y)) }; return W } const e4 = new Set(["opacity", "clipPath", "filter", "transform", "backgroundColor"]), Fa = 10, t4 = 2e4, n4 = (t, e) => e.type === "spring" || t === "backgroundColor" || !Iw(e.ease); function i4(t, e, { onUpdate: n, onComplete: i, ...r }) { if (!(Bw.waapi() && e4.has(e) && !r.repeatDelay && r.repeatType !== "mirror" && r.damping !== 0 && r.type !== "inertia")) return !1; let o = !1, a, l; const c = () => { l = new Promise(p => { a = p }) }; c(); let { keyframes: u, duration: d = 300, ease: f } = r; if (n4(e, r)) { const p = ic({ ...r, repeat: 0, delay: 0 }); let x = { done: !1, value: u[0] }; const y = []; let g = 0; for (; !x.done && g < t4;)x = p.sample(g), y.push(x.value), g += Fa; u = y, d = g - Fa, f = "linear" } const h = hE(t.owner.current, e, u, { ...r, duration: d, ease: f }), m = () => { Pe.update(() => h.cancel()), a(), c() }; return h.onfinish = () => { t.set(pE(u, r)), i && i(), m() }, { then(p, x) { return l.then(p, x) }, get time() { return ar(h.currentTime || 0) }, set time(p) { h.currentTime = vi(p) }, get speed() { return h.playbackRate }, set speed(p) { h.playbackRate = p }, play: () => { o || h.play() }, pause: () => h.pause(), stop: () => { if (o = !0, h.playState === "idle") return; const { currentTime: p } = h; if (p) { const x = ic({ ...r, autoplay: !1 }); t.setWithVelocity(x.sample(p - Fa).value, x.sample(p).value, Fa) } m() }, complete: () => h.finish(), cancel: m } } function r4({ keyframes: t, delay: e, onUpdate: n, onComplete: i }) { const r = () => (n && n(t[t.length - 1]), i && i(), { time: 0, speed: 1, play: Ke, pause: Ke, stop: Ke, then: s => (s(), Promise.resolve()), cancel: Ke, complete: Ke }); return e ? ic({ keyframes: [0, 1], duration: e, onComplete: r }) : r() } const s4 = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, o4 = t => ({ type: "spring", stiffness: 550, damping: t === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), a4 = { type: "keyframes", duration: .8 }, l4 = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, c4 = (t, { keyframes: e }) => e.length > 2 ? a4 : fr.has(t) ? t.startsWith("scale") ? o4(e[1]) : s4 : l4, Cf = (t, e) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && Si.test(e) && !e.startsWith("url(")), u4 = new Set(["brightness", "contrast", "saturate", "opacity"]); function d4(t) { const [e, n] = t.slice(0, -1).split("("); if (e === "drop-shadow") return t; const [i] = n.match(Ro) || []; if (!i) return t; const r = n.replace(i, ""); let s = u4.has(e) ? 1 : 0; return i !== n && (s *= 100), e + "(" + s + r + ")" } const f4 = /([a-z-]*)\(.*?\)/g, Mf = { ...Si, getAnimatableNone: t => { const e = t.match(f4); return e ? e.map(d4).join(" ") : t } }, h4 = { ...bw, color: ut, backgroundColor: ut, outlineColor: ut, fill: ut, stroke: ut, borderColor: ut, borderTopColor: ut, borderRightColor: ut, borderBottomColor: ut, borderLeftColor: ut, filter: Mf, WebkitFilter: Mf }, _p = t => h4[t]; function Sp(t, e) { let n = _p(t); return n !== Mf && (n = Si), n.getAnimatableNone ? n.getAnimatableNone(e) : void 0 } function p4({ when: t, delay: e, delayChildren: n, staggerChildren: i, staggerDirection: r, repeat: s, repeatType: o, repeatDelay: a, from: l, elapsed: c, ...u }) { return !!Object.keys(u).length } function oy(t) { return t === 0 || typeof t == "string" && parseFloat(t) === 0 && t.indexOf(" ") === -1 } function ay(t) { return typeof t == "number" ? 0 : Sp("", t) } function ab(t, e) { return t[e] || t.default || t } function m4(t, e, n, i) { const r = Cf(e, n); let s = i.from !== void 0 ? i.from : t.get(); if (s === "none" && r && typeof n == "string" ? s = Sp(e, n) : oy(s) && typeof n == "string" ? s = ay(n) : !Array.isArray(n) && oy(n) && typeof s == "string" && (n = ay(s)), Array.isArray(n)) { for (let o = 0; o < n.length; o++)n[o] === null && (n[o] = o === 0 ? s : n[o - 1]); return n } else return [s, n] } const kp = (t, e, n, i = {}) => r => { const s = ab(i, t) || {}, o = s.delay || i.delay || 0; let { elapsed: a = 0 } = i; a = a - vi(o); const l = m4(e, t, n, s), c = l[0], u = l[l.length - 1], d = Cf(t, c), f = Cf(t, u); let h = { keyframes: l, velocity: e.getVelocity(), ease: "easeOut", ...s, delay: -a, onUpdate: m => { e.set(m), s.onUpdate && s.onUpdate(m) }, onComplete: () => { r(), s.onComplete && s.onComplete() } }; if (!d || !f || fE.current || s.type === !1) return r4(h); if (p4(s) || (h = { ...h, ...c4(t, h) }), h.duration && (h.duration = vi(h.duration)), h.repeatDelay && (h.repeatDelay = vi(h.repeatDelay)), e.owner && e.owner.current instanceof HTMLElement && !e.owner.getProps().onUpdate) { const m = i4(e, t, h); if (m) return m } return ic(h) }; function rc(t) { return !!(kt(t) && t.add) } const g4 = t => /^\-?\d*\.?\d+$/.test(t), y4 = t => /^0[^.\s]+$/.test(t); function Pp(t, e) { t.indexOf(e) === -1 && t.push(e) } function Cp(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) } class Mp { constructor() { this.subscriptions = [] } add(e) { return Pp(this.subscriptions, e), () => Cp(this.subscriptions, e) } notify(e, n, i) { const r = this.subscriptions.length; if (r) if (r === 1) this.subscriptions[0](e, n, i); else for (let s = 0; s < r; s++) { const o = this.subscriptions[s]; o && o(e, n, i) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } const v4 = t => !isNaN(parseFloat(t)); class x4 { constructor(e, n = {}) { this.version = "10.9.1", this.timeDelta = 0, this.lastUpdated = 0, this.canTrackVelocity = !1, this.events = {}, this.updateAndNotify = (i, r = !0) => { this.prev = this.current, this.current = i; const { delta: s, timestamp: o } = ot; this.lastUpdated !== o && (this.timeDelta = s, this.lastUpdated = o, Pe.postRender(this.scheduleVelocityCheck)), this.prev !== this.current && this.events.change && this.events.change.notify(this.current), this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()), r && this.events.renderRequest && this.events.renderRequest.notify(this.current) }, this.scheduleVelocityCheck = () => Pe.postRender(this.velocityCheck), this.velocityCheck = ({ timestamp: i }) => { i !== this.lastUpdated && (this.prev = this.current, this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity())) }, this.hasAnimated = !1, this.prev = this.current = e, this.canTrackVelocity = v4(this.current), this.owner = n.owner } onChange(e) { return this.on("change", e) } on(e, n) { this.events[e] || (this.events[e] = new Mp); const i = this.events[e].add(n); return e === "change" ? () => { i(), Pe.read(() => { this.events.change.getSize() || this.stop() }) } : i } clearListeners() { for (const e in this.events) this.events[e].clear() } attach(e, n) { this.passiveEffect = e, this.stopPassiveEffect = n } set(e, n = !0) { !n || !this.passiveEffect ? this.updateAndNotify(e, n) : this.passiveEffect(e, this.updateAndNotify) } setWithVelocity(e, n, i) { this.set(n), this.prev = e, this.timeDelta = i } jump(e) { this.updateAndNotify(e), this.prev = e, this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } get() { return this.current } getPrevious() { return this.prev } getVelocity() { return this.canTrackVelocity ? rb(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0 } start(e) { return this.stop(), new Promise(n => { this.hasAnimated = !0, this.animation = e(n), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function es(t, e) { return new x4(t, e) } const lb = t => e => e.test(t), w4 = { test: t => t === "auto", parse: t => t }, cb = [hr, X, mn, Gn, kT, ST, w4], bs = t => cb.find(lb(t)), b4 = [...cb, ut, Si], _4 = t => b4.find(lb(t)); function S4(t, e, n) { t.hasValue(e) ? t.getValue(e).set(n) : t.addValue(e, es(n)) } function Tp(t, e) { const n = Gc(t, e); let { transitionEnd: i = {}, transition: r = {}, ...s } = n ? t.makeTargetAnimatable(n, !1) : {}; s = { ...s, ...i }; for (const o in s) { const a = IT(s[o]); S4(t, o, a) } } function Tf(t, e) { [...e].reverse().forEach(i => { const r = t.getVariant(i); r && Tp(t, r), t.variantChildren && t.variantChildren.forEach(s => { Tf(s, e) }) }) } function k4(t, e) { if (Array.isArray(e)) return Tf(t, e); if (typeof e == "string") return Tf(t, [e]); Tp(t, e) } function P4(t, e, n) { var i, r; const s = Object.keys(e).filter(a => !t.hasValue(a)), o = s.length; if (o) for (let a = 0; a < o; a++) { const l = s[a], c = e[l]; let u = null; Array.isArray(c) && (u = c[0]), u === null && (u = (r = (i = n[l]) !== null && i !== void 0 ? i : t.readValue(l)) !== null && r !== void 0 ? r : e[l]), u != null && (typeof u == "string" && (g4(u) || y4(u)) ? u = parseFloat(u) : !_4(u) && Si.test(c) && (u = Sp(l, c)), t.addValue(l, es(u, { owner: t })), n[l] === void 0 && (n[l] = u), u !== null && t.setBaseTarget(l, u)) } } function C4(t, e) { return e ? (e[t] || e.default || e).from : void 0 } function M4(t, e, n) { const i = {}; for (const r in t) { const s = C4(r, e); if (s !== void 0) i[r] = s; else { const o = n.getValue(r); o && (i[r] = o.get()) } } return i } function T4({ protectedKeys: t, needsAnimating: e }, n) { const i = t.hasOwnProperty(n) && e[n] !== !0; return e[n] = !1, i } function ub(t, e, { delay: n = 0, transitionOverride: i, type: r } = {}) { let { transition: s = t.getDefaultTransition(), transitionEnd: o, ...a } = t.makeTargetAnimatable(e); const l = t.getValue("willChange"); i && (s = i); const c = [], u = r && t.animationState && t.animationState.getState()[r]; for (const d in a) { const f = t.getValue(d), h = a[d]; if (!f || h === void 0 || u && T4(u, d)) continue; const m = { delay: n, elapsed: 0, ...s }; if (window.HandoffAppearAnimations && !f.hasAnimated) { const x = t.getProps()[uE]; x && (m.elapsed = window.HandoffAppearAnimations(x, d, f, Pe)) } f.start(kp(d, f, h, t.shouldReduceMotion && fr.has(d) ? { type: !1 } : m)); const p = f.animation; rc(l) && (l.add(d), p.then(() => l.remove(d))), c.push(p) } return o && Promise.all(c).then(() => { o && Tp(t, o) }), c } function Ef(t, e, n = {}) { const i = Gc(t, e, n.custom); let { transition: r = t.getDefaultTransition() || {} } = i || {}; n.transitionOverride && (r = n.transitionOverride); const s = i ? () => Promise.all(ub(t, i, n)) : () => Promise.resolve(), o = t.variantChildren && t.variantChildren.size ? (l = 0) => { const { delayChildren: c = 0, staggerChildren: u, staggerDirection: d } = r; return E4(t, e, c + l, u, d, n) } : () => Promise.resolve(), { when: a } = r; if (a) { const [l, c] = a === "beforeChildren" ? [s, o] : [o, s]; return l().then(() => c()) } else return Promise.all([s(), o(n.delay)]) } function E4(t, e, n = 0, i = 0, r = 1, s) { const o = [], a = (t.variantChildren.size - 1) * i, l = r === 1 ? (c = 0) => c * i : (c = 0) => a - c * i; return Array.from(t.variantChildren).sort(D4).forEach((c, u) => { c.notify("AnimationStart", e), o.push(Ef(c, e, { ...s, delay: n + l(u) }).then(() => c.notify("AnimationComplete", e))) }), Promise.all(o) } function D4(t, e) { return t.sortNodePosition(e) } function db(t, e, n = {}) { t.notify("AnimationStart", e); let i; if (Array.isArray(e)) { const r = e.map(s => Ef(t, s, n)); i = Promise.all(r) } else if (typeof e == "string") i = Ef(t, e, n); else { const r = typeof e == "function" ? Gc(t, e, n.custom) : e; i = Promise.all(ub(t, r, n)) } return i.then(() => t.notify("AnimationComplete", e)) } const O4 = [...lp].reverse(), R4 = lp.length; function L4(t) { return e => Promise.all(e.map(({ animation: n, options: i }) => db(t, n, i))) } function j4(t) { let e = L4(t); const n = N4(); let i = !0; const r = (l, c) => { const u = Gc(t, c); if (u) { const { transition: d, transitionEnd: f, ...h } = u; l = { ...l, ...h, ...f } } return l }; function s(l) { e = l(t) } function o(l, c) { const u = t.getProps(), d = t.getVariantContext(!0) || {}, f = [], h = new Set; let m = {}, p = 1 / 0; for (let y = 0; y < R4; y++) { const g = O4[y], v = n[g], b = u[g] !== void 0 ? u[g] : d[g], _ = Do(b), k = g === c ? v.isActive : null; k === !1 && (p = y); let S = b === d[g] && b !== u[g] && _; if (S && i && t.manuallyAnimateOnMount && (S = !1), v.protectedKeys = { ...m }, !v.isActive && k === null || !b && !v.prevProp || $c(b) || typeof b == "boolean") continue; const P = A4(v.prevProp, b); let T = P || g === c && v.isActive && !S && _ || y > p && _; const D = Array.isArray(b) ? b : [b]; let A = D.reduce(r, {}); k === !1 && (A = {}); const { prevResolvedValues: V = {} } = v, q = { ...V, ...A }, G = z => { T = !0, h.delete(z), v.needsAnimating[z] = !0 }; for (const z in q) { const J = A[z], re = V[z]; m.hasOwnProperty(z) || (J !== re ? ec(J) && ec(re) ? !Nw(J, re) || P ? G(z) : v.protectedKeys[z] = !0 : J !== void 0 ? G(z) : h.add(z) : J !== void 0 && h.has(z) ? G(z) : v.protectedKeys[z] = !0) } v.prevProp = b, v.prevResolvedValues = A, v.isActive && (m = { ...m, ...A }), i && t.blockInitialAnimation && (T = !1), T && !S && f.push(...D.map(z => ({ animation: z, options: { type: g, ...l } }))) } if (h.size) { const y = {}; h.forEach(g => { const v = t.getBaseTarget(g); v !== void 0 && (y[g] = v) }), f.push({ animation: y }) } let x = !!f.length; return i && u.initial === !1 && !t.manuallyAnimateOnMount && (x = !1), i = !1, x ? e(f) : Promise.resolve() } function a(l, c, u) { var d; if (n[l].isActive === c) return Promise.resolve(); (d = t.variantChildren) === null || d === void 0 || d.forEach(h => { var m; return (m = h.animationState) === null || m === void 0 ? void 0 : m.setActive(l, c) }), n[l].isActive = c; const f = o(u, l); for (const h in n) n[h].protectedKeys = {}; return f } return { animateChanges: o, setActive: a, setAnimateFunction: s, getState: () => n } } function A4(t, e) { return typeof e == "string" ? e !== t : Array.isArray(e) ? !Nw(e, t) : !1 } function Li(t = !1) { return { isActive: t, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function N4() { return { animate: Li(!0), whileInView: Li(), whileHover: Li(), whileTap: Li(), whileDrag: Li(), whileFocus: Li(), exit: Li() } } class F4 extends Ei { constructor(e) { super(e), e.animationState || (e.animationState = j4(e)) } updateAnimationControlsSubscription() { const { animate: e } = this.node.getProps(); this.unmount(), $c(e) && (this.unmount = e.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: e } = this.node.getProps(), { animate: n } = this.node.prevProps || {}; e !== n && this.updateAnimationControlsSubscription() } unmount() { } } let I4 = 0; class V4 extends Ei { constructor() { super(...arguments), this.id = I4++ } update() { if (!this.node.presenceContext) return; const { isPresent: e, onExitComplete: n, custom: i } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {}; if (!this.node.animationState || e === r) return; const s = this.node.animationState.setActive("exit", !e, { custom: i ?? this.node.getProps().custom }); n && !e && s.then(() => n(this.id)) } mount() { const { register: e } = this.node.presenceContext || {}; e && (this.unmount = e(this.id)) } unmount() { } } const z4 = { animation: { Feature: F4 }, exit: { Feature: V4 } }, ly = (t, e) => Math.abs(t - e); function B4(t, e) { const n = ly(t.x, e.x), i = ly(t.y, e.y); return Math.sqrt(n ** 2 + i ** 2) } class fb { constructor(e, n, { transformPagePoint: i } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; const c = Zu(this.lastMoveEventInfo, this.history), u = this.startEvent !== null, d = B4(c.offset, { x: 0, y: 0 }) >= 3; if (!u && !d) return; const { point: f } = c, { timestamp: h } = ot; this.history.push({ ...f, timestamp: h }); const { onStart: m, onMove: p } = this.handlers; u || (m && m(this.lastMoveEvent, c), this.startEvent = this.lastMoveEvent), p && p(this.lastMoveEvent, c) }, this.handlePointerMove = (c, u) => { this.lastMoveEvent = c, this.lastMoveEventInfo = qu(u, this.transformPagePoint), Pe.update(this.updatePoint, !0) }, this.handlePointerUp = (c, u) => { if (this.end(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; const { onEnd: d, onSessionEnd: f } = this.handlers, h = Zu(c.type === "pointercancel" ? this.lastMoveEventInfo : qu(u, this.transformPagePoint), this.history); this.startEvent && d && d(c, h), f && f(c, h) }, !Dw(e)) return; this.handlers = n, this.transformPagePoint = i; const r = Kc(e), s = qu(r, this.transformPagePoint), { point: o } = s, { timestamp: a } = ot; this.history = [{ ...o, timestamp: a }]; const { onSessionStart: l } = n; l && l(e, Zu(s, this.history)), this.removeListeners = yi(Nn(window, "pointermove", this.handlePointerMove), Nn(window, "pointerup", this.handlePointerUp), Nn(window, "pointercancel", this.handlePointerUp)) } updateHandlers(e) { this.handlers = e } end() { this.removeListeners && this.removeListeners(), _i.update(this.updatePoint) } } function qu(t, e) { return e ? { point: e(t.point) } : t } function cy(t, e) { return { x: t.x - e.x, y: t.y - e.y } } function Zu({ point: t }, e) { return { point: t, delta: cy(t, hb(e)), offset: cy(t, H4(e)), velocity: W4(e, .1) } } function H4(t) { return t[0] } function hb(t) { return t[t.length - 1] } function W4(t, e) { if (t.length < 2) return { x: 0, y: 0 }; let n = t.length - 1, i = null; const r = hb(t); for (; n >= 0 && (i = t[n], !(r.timestamp - i.timestamp > vi(e)));)n--; if (!i) return { x: 0, y: 0 }; const s = ar(r.timestamp - i.timestamp); if (s === 0) return { x: 0, y: 0 }; const o = { x: (r.x - i.x) / s, y: (r.y - i.y) / s }; return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o } function Rt(t) { return t.max - t.min } function Df(t, e = 0, n = .01) { return Math.abs(t - e) <= n } function uy(t, e, n, i = .5) { t.origin = i, t.originPoint = ke(e.min, e.max, t.origin), t.scale = Rt(n) / Rt(e), (Df(t.scale, 1, 1e-4) || isNaN(t.scale)) && (t.scale = 1), t.translate = ke(n.min, n.max, t.origin) - t.originPoint, (Df(t.translate) || isNaN(t.translate)) && (t.translate = 0) } function qs(t, e, n, i) { uy(t.x, e.x, n.x, i ? i.originX : void 0), uy(t.y, e.y, n.y, i ? i.originY : void 0) } function dy(t, e, n) { t.min = n.min + e.min, t.max = t.min + Rt(e) } function $4(t, e, n) { dy(t.x, e.x, n.x), dy(t.y, e.y, n.y) } function fy(t, e, n) { t.min = e.min - n.min, t.max = t.min + Rt(e) } function Zs(t, e, n) { fy(t.x, e.x, n.x), fy(t.y, e.y, n.y) } function U4(t, { min: e, max: n }, i) { return e !== void 0 && t < e ? t = i ? ke(e, t, i.min) : Math.max(t, e) : n !== void 0 && t > n && (t = i ? ke(n, t, i.max) : Math.min(t, n)), t } function hy(t, e, n) { return { min: e !== void 0 ? t.min + e : void 0, max: n !== void 0 ? t.max + n - (t.max - t.min) : void 0 } } function Y4(t, { top: e, left: n, bottom: i, right: r }) { return { x: hy(t.x, n, r), y: hy(t.y, e, i) } } function py(t, e) { let n = e.min - t.min, i = e.max - t.max; return e.max - e.min < t.max - t.min && ([n, i] = [i, n]), { min: n, max: i } } function K4(t, e) { return { x: py(t.x, e.x), y: py(t.y, e.y) } } function X4(t, e) { let n = .5; const i = Rt(t), r = Rt(e); return r > i ? n = jo(e.min, e.max - i, t.min) : i > r && (n = jo(t.min, t.max - r, e.min)), or(0, 1, n) } function G4(t, e) { const n = {}; return e.min !== void 0 && (n.min = e.min - t.min), e.max !== void 0 && (n.max = e.max - t.min), n } const Of = .35; function Q4(t = Of) { return t === !1 ? t = 0 : t === !0 && (t = Of), { x: my(t, "left", "right"), y: my(t, "top", "bottom") } } function my(t, e, n) { return { min: gy(t, e), max: gy(t, n) } } function gy(t, e) { return typeof t == "number" ? t : t[e] || 0 } const yy = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), Js = () => ({ x: yy(), y: yy() }), vy = () => ({ min: 0, max: 0 }), Ie = () => ({ x: vy(), y: vy() }); function cn(t) { return [t("x"), t("y")] } function pb({ top: t, left: e, right: n, bottom: i }) { return { x: { min: e, max: n }, y: { min: t, max: i } } } function q4({ x: t, y: e }) { return { top: e.min, right: t.max, bottom: e.max, left: t.min } } function Z4(t, e) { if (!e) return t; const n = e({ x: t.left, y: t.top }), i = e({ x: t.right, y: t.bottom }); return { top: n.y, left: n.x, bottom: i.y, right: i.x } } function Ju(t) { return t === void 0 || t === 1 } function Rf({ scale: t, scaleX: e, scaleY: n }) { return !Ju(t) || !Ju(e) || !Ju(n) } function zi(t) { return Rf(t) || mb(t) || t.z || t.rotate || t.rotateX || t.rotateY } function mb(t) { return xy(t.x) || xy(t.y) } function xy(t) { return t && t !== "0%" } function sc(t, e, n) { const i = t - n, r = e * i; return n + r } function wy(t, e, n, i, r) { return r !== void 0 && (t = sc(t, r, i)), sc(t, n, i) + e } function Lf(t, e = 0, n = 1, i, r) { t.min = wy(t.min, e, n, i, r), t.max = wy(t.max, e, n, i, r) } function gb(t, { x: e, y: n }) { Lf(t.x, e.translate, e.scale, e.originPoint), Lf(t.y, n.translate, n.scale, n.originPoint) } function J4(t, e, n, i = !1) { const r = n.length; if (!r) return; e.x = e.y = 1; let s, o; for (let a = 0; a < r; a++) { s = n[a], o = s.projectionDelta; const l = s.instance; l && l.style && l.style.display === "contents" || (i && s.options.layoutScroll && s.scroll && s !== s.root && Nr(t, { x: -s.scroll.offset.x, y: -s.scroll.offset.y }), o && (e.x *= o.x.scale, e.y *= o.y.scale, gb(t, o)), i && zi(s.latestValues) && Nr(t, s.latestValues)) } e.x = by(e.x), e.y = by(e.y) } function by(t) { return Number.isInteger(t) || t > 1.0000000000001 || t < .999999999999 ? t : 1 } function Zn(t, e) { t.min = t.min + e, t.max = t.max + e } function _y(t, e, [n, i, r]) { const s = e[r] !== void 0 ? e[r] : .5, o = ke(t.min, t.max, s); Lf(t, e[n], e[i], o, e.scale) } const eD = ["x", "scaleX", "originX"], tD = ["y", "scaleY", "originY"]; function Nr(t, e) { _y(t.x, e, eD), _y(t.y, e, tD) } function yb(t, e) { return pb(Z4(t.getBoundingClientRect(), e)) } function nD(t, e, n) { const i = yb(t, n), { scroll: r } = e; return r && (Zn(i.x, r.offset.x), Zn(i.y, r.offset.y)), i } const iD = new WeakMap; class rD { constructor(e) { this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Ie(), this.visualElement = e } start(e, { snapToCursor: n = !1 } = {}) { const { presenceContext: i } = this.visualElement; if (i && i.isPresent === !1) return; const r = l => { this.stopAnimation(), n && this.snapToCursor(Kc(l, "page").point) }, s = (l, c) => { const { drag: u, dragPropagation: d, onDragStart: f } = this.getProps(); if (u && !d && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = Rw(u), !this.openGlobalLock)) return; this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), cn(m => { let p = this.getAxisMotionValue(m).get() || 0; if (mn.test(p)) { const { projection: x } = this.visualElement; if (x && x.layout) { const y = x.layout.layoutBox[m]; y && (p = Rt(y) * (parseFloat(p) / 100)) } } this.originPoint[m] = p }), f && Pe.update(() => f(l, c)); const { animationState: h } = this.visualElement; h && h.setActive("whileDrag", !0) }, o = (l, c) => { const { dragPropagation: u, dragDirectionLock: d, onDirectionLock: f, onDrag: h } = this.getProps(); if (!u && !this.openGlobalLock) return; const { offset: m } = c; if (d && this.currentDirection === null) { this.currentDirection = sD(m), this.currentDirection !== null && f && f(this.currentDirection); return } this.updateAxis("x", c.point, m), this.updateAxis("y", c.point, m), this.visualElement.render(), h && h(l, c) }, a = (l, c) => this.stop(l, c); this.panSession = new fb(e, { onSessionStart: r, onStart: s, onMove: o, onSessionEnd: a }, { transformPagePoint: this.visualElement.getTransformPagePoint() }) } stop(e, n) { const i = this.isDragging; if (this.cancel(), !i) return; const { velocity: r } = n; this.startAnimation(r); const { onDragEnd: s } = this.getProps(); s && Pe.update(() => s(e, n)) } cancel() { this.isDragging = !1; const { projection: e, animationState: n } = this.visualElement; e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; const { dragPropagation: i } = this.getProps(); !i && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), n && n.setActive("whileDrag", !1) } updateAxis(e, n, i) { const { drag: r } = this.getProps(); if (!i || !Ia(e, r, this.currentDirection)) return; const s = this.getAxisMotionValue(e); let o = this.originPoint[e] + i[e]; this.constraints && this.constraints[e] && (o = U4(o, this.constraints[e], this.elastic[e])), s.set(o) } resolveConstraints() { const { dragConstraints: e, dragElastic: n } = this.getProps(), { layout: i } = this.visualElement.projection || {}, r = this.constraints; e && jr(e) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : e && i ? this.constraints = Y4(i.layoutBox, e) : this.constraints = !1, this.elastic = Q4(n), r !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && cn(s => { this.getAxisMotionValue(s) && (this.constraints[s] = G4(i.layoutBox[s], this.constraints[s])) }) } resolveRefConstraints() { const { dragConstraints: e, onMeasureDragConstraints: n } = this.getProps(); if (!e || !jr(e)) return !1; const i = e.current, { projection: r } = this.visualElement; if (!r || !r.layout) return !1; const s = nD(i, r.root, this.visualElement.getTransformPagePoint()); let o = K4(r.layout.layoutBox, s); if (n) { const a = n(q4(o)); this.hasMutatedConstraints = !!a, a && (o = pb(a)) } return o } startAnimation(e) { const { drag: n, dragMomentum: i, dragElastic: r, dragTransition: s, dragSnapToOrigin: o, onDragTransitionEnd: a } = this.getProps(), l = this.constraints || {}, c = cn(u => { if (!Ia(u, n, this.currentDirection)) return; let d = l && l[u] || {}; o && (d = { min: 0, max: 0 }); const f = r ? 200 : 1e6, h = r ? 40 : 1e7, m = { type: "inertia", velocity: i ? e[u] : 0, bounceStiffness: f, bounceDamping: h, timeConstant: 750, restDelta: 1, restSpeed: 10, ...s, ...d }; return this.startAxisValueAnimation(u, m) }); return Promise.all(c).then(a) } startAxisValueAnimation(e, n) { const i = this.getAxisMotionValue(e); return i.start(kp(e, i, 0, n)) } stopAnimation() { cn(e => this.getAxisMotionValue(e).stop()) } getAxisMotionValue(e) { const n = "_drag" + e.toUpperCase(), i = this.visualElement.getProps(), r = i[n]; return r || this.visualElement.getValue(e, (i.initial ? i.initial[e] : void 0) || 0) } snapToCursor(e) { cn(n => { const { drag: i } = this.getProps(); if (!Ia(n, i, this.currentDirection)) return; const { projection: r } = this.visualElement, s = this.getAxisMotionValue(n); if (r && r.layout) { const { min: o, max: a } = r.layout.layoutBox[n]; s.set(e[n] - ke(o, a, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: e, dragConstraints: n } = this.getProps(), { projection: i } = this.visualElement; if (!jr(n) || !i || !this.constraints) return; this.stopAnimation(); const r = { x: 0, y: 0 }; cn(o => { const a = this.getAxisMotionValue(o); if (a) { const l = a.get(); r[o] = X4({ min: l, max: l }, this.constraints[o]) } }); const { transformTemplate: s } = this.visualElement.getProps(); this.visualElement.current.style.transform = s ? s({}, "") : "none", i.root && i.root.updateScroll(), i.updateLayout(), this.resolveConstraints(), cn(o => { if (!Ia(o, e, null)) return; const a = this.getAxisMotionValue(o), { min: l, max: c } = this.constraints[o]; a.set(ke(l, c, r[o])) }) } addListeners() { if (!this.visualElement.current) return; iD.set(this.visualElement, this); const e = this.visualElement.current, n = Nn(e, "pointerdown", l => { const { drag: c, dragListener: u = !0 } = this.getProps(); c && u && this.start(l) }), i = () => { const { dragConstraints: l } = this.getProps(); jr(l) && (this.constraints = this.resolveRefConstraints()) }, { projection: r } = this.visualElement, s = r.addEventListener("measure", i); r && !r.layout && (r.root && r.root.updateScroll(), r.updateLayout()), i(); const o = On(window, "resize", () => this.scalePositionWithinConstraints()), a = r.addEventListener("didUpdate", ({ delta: l, hasLayoutChanged: c }) => { this.isDragging && c && (cn(u => { const d = this.getAxisMotionValue(u); d && (this.originPoint[u] += l[u].translate, d.set(d.get() + l[u].translate)) }), this.visualElement.render()) }); return () => { o(), n(), s(), a && a() } } getProps() { const e = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: i = !1, dragPropagation: r = !1, dragConstraints: s = !1, dragElastic: o = Of, dragMomentum: a = !0 } = e; return { ...e, drag: n, dragDirectionLock: i, dragPropagation: r, dragConstraints: s, dragElastic: o, dragMomentum: a } } } function Ia(t, e, n) { return (e === !0 || e === t) && (n === null || n === t) } function sD(t, e = 10) { let n = null; return Math.abs(t.y) > e ? n = "y" : Math.abs(t.x) > e && (n = "x"), n } class oD extends Ei { constructor(e) { super(e), this.removeGroupControls = Ke, this.removeListeners = Ke, this.controls = new rD(e) } mount() { const { dragControls: e } = this.node.getProps(); e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Ke } unmount() { this.removeGroupControls(), this.removeListeners() } } const Sy = t => (e, n) => { t && Pe.update(() => t(e, n)) }; class aD extends Ei { constructor() { super(...arguments), this.removePointerDownListener = Ke } onPointerDown(e) { this.session = new fb(e, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint() }) } createPanHandlers() { const { onPanSessionStart: e, onPanStart: n, onPan: i, onPanEnd: r } = this.node.getProps(); return { onSessionStart: Sy(e), onStart: Sy(n), onMove: i, onEnd: (s, o) => { delete this.session, r && Pe.update(() => r(s, o)) } } } mount() { this.removePointerDownListener = Nn(this.node.current, "pointerdown", e => this.onPointerDown(e)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } function lD() { const t = M.useContext(ap); if (t === null) return [!0, null]; const { isPresent: e, onExitComplete: n, register: i } = t, r = M.useId(); return M.useEffect(() => i(r), []), !e && n ? [!1, () => n && n(r)] : [!0] } function ky(t, e) { return e.max === e.min ? 0 : t / (e.max - e.min) * 100 } const _s = { correct: (t, e) => { if (!e.target) return t; if (typeof t == "string") if (X.test(t)) t = parseFloat(t); else return t; const n = ky(t, e.target.x), i = ky(t, e.target.y); return `${n}% ${i}%` } }, vb = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/; function cD(t) { const e = vb.exec(t); if (!e) return [,]; const [, n, i] = e; return [n, i] } function jf(t, e, n = 1) { const [i, r] = cD(t); if (!i) return; const s = window.getComputedStyle(e).getPropertyValue(i); return s ? s.trim() : wf(r) ? jf(r, e, n + 1) : r } function uD(t, { ...e }, n) { const i = t.current; if (!(i instanceof Element)) return { target: e, transitionEnd: n }; n && (n = { ...n }), t.values.forEach(r => { const s = r.get(); if (!wf(s)) return; const o = jf(s, i); o && r.set(o) }); for (const r in e) { const s = e[r]; if (!wf(s)) continue; const o = jf(s, i); o && (e[r] = o, n || (n = {}), n[r] === void 0 && (n[r] = s)) } return { target: e, transitionEnd: n } } const Py = "_$css", dD = { correct: (t, { treeScale: e, projectionDelta: n }) => { const i = t, r = t.includes("var("), s = []; r && (t = t.replace(vb, h => (s.push(h), Py))); const o = Si.parse(t); if (o.length > 5) return i; const a = Si.createTransformer(t), l = typeof o[0] != "number" ? 1 : 0, c = n.x.scale * e.x, u = n.y.scale * e.y; o[0 + l] /= c, o[1 + l] /= u; const d = ke(c, u, .5); typeof o[2 + l] == "number" && (o[2 + l] /= d), typeof o[3 + l] == "number" && (o[3 + l] /= d); let f = a(o); if (r) { let h = 0; f = f.replace(Py, () => { const m = s[h]; return h++, m }) } return f } }; class fD extends Et.Component { componentDidMount() { const { visualElement: e, layoutGroup: n, switchLayoutGroup: i, layoutId: r } = this.props, { projection: s } = e; yT(hD), s && (n.group && n.group.add(s), i && i.register && r && i.register(s), s.root.didUpdate(), s.addEventListener("animationComplete", () => { this.safeToRemove() }), s.setOptions({ ...s.options, onExitComplete: () => this.safeToRemove() })), Xs.hasEverUpdated = !0 } getSnapshotBeforeUpdate(e) { const { layoutDependency: n, visualElement: i, drag: r, isPresent: s } = this.props, o = i.projection; return o && (o.isPresent = s, r || e.layoutDependency !== n || n === void 0 ? o.willUpdate() : this.safeToRemove(), e.isPresent !== s && (s ? o.promote() : o.relegate() || Pe.postRender(() => { const a = o.getStack(); (!a || !a.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { const { projection: e } = this.props.visualElement; e && (e.root.didUpdate(), !e.currentAnimation && e.isLead() && this.safeToRemove()) } componentWillUnmount() { const { visualElement: e, layoutGroup: n, switchLayoutGroup: i } = this.props, { projection: r } = e; r && (r.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(r), i && i.deregister && i.deregister(r)) } safeToRemove() { const { safeToRemove: e } = this.props; e && e() } render() { return null } } function xb(t) { const [e, n] = lD(), i = M.useContext(gw); return Et.createElement(fD, { ...t, layoutGroup: i, switchLayoutGroup: M.useContext(yw), isPresent: e, safeToRemove: n }) } const hD = { borderRadius: { ..._s, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: _s, borderTopRightRadius: _s, borderBottomLeftRadius: _s, borderBottomRightRadius: _s, boxShadow: dD }, wb = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], pD = wb.length, Cy = t => typeof t == "string" ? parseFloat(t) : t, My = t => typeof t == "number" || X.test(t); function mD(t, e, n, i, r, s) { r ? (t.opacity = ke(0, n.opacity !== void 0 ? n.opacity : 1, gD(i)), t.opacityExit = ke(e.opacity !== void 0 ? e.opacity : 1, 0, yD(i))) : s && (t.opacity = ke(e.opacity !== void 0 ? e.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, i)); for (let o = 0; o < pD; o++) { const a = `border${wb[o]}Radius`; let l = Ty(e, a), c = Ty(n, a); if (l === void 0 && c === void 0) continue; l || (l = 0), c || (c = 0), l === 0 || c === 0 || My(l) === My(c) ? (t[a] = Math.max(ke(Cy(l), Cy(c), i), 0), (mn.test(c) || mn.test(l)) && (t[a] += "%")) : t[a] = c } (e.rotate || n.rotate) && (t.rotate = ke(e.rotate || 0, n.rotate || 0, i)) } function Ty(t, e) { return t[e] !== void 0 ? t[e] : t.borderRadius } const gD = bb(0, .5, xp), yD = bb(.5, .95, Ke); function bb(t, e, n) { return i => i < t ? 0 : i > e ? 1 : n(jo(t, e, i)) } function Ey(t, e) { t.min = e.min, t.max = e.max } function At(t, e) { Ey(t.x, e.x), Ey(t.y, e.y) } function Dy(t, e, n, i, r) { return t -= e, t = sc(t, 1 / n, i), r !== void 0 && (t = sc(t, 1 / r, i)), t } function vD(t, e = 0, n = 1, i = .5, r, s = t, o = t) { if (mn.test(e) && (e = parseFloat(e), e = ke(o.min, o.max, e / 100) - o.min), typeof e != "number") return; let a = ke(s.min, s.max, i); t === s && (a -= e), t.min = Dy(t.min, e, n, a, r), t.max = Dy(t.max, e, n, a, r) } function Oy(t, e, [n, i, r], s, o) { vD(t, e[n], e[i], e[r], e.scale, s, o) } const xD = ["x", "scaleX", "originX"], wD = ["y", "scaleY", "originY"]; function Ry(t, e, n, i) { Oy(t.x, e, xD, n ? n.x : void 0, i ? i.x : void 0), Oy(t.y, e, wD, n ? n.y : void 0, i ? i.y : void 0) } function Ly(t) { return t.translate === 0 && t.scale === 1 } function _b(t) { return Ly(t.x) && Ly(t.y) } function Af(t, e) { return t.x.min === e.x.min && t.x.max === e.x.max && t.y.min === e.y.min && t.y.max === e.y.max } function jy(t) { return Rt(t.x) / Rt(t.y) } class bD { constructor() { this.members = [] } add(e) { Pp(this.members, e), e.scheduleRender() } remove(e) { if (Cp(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) { const n = this.members[this.members.length - 1]; n && this.promote(n) } } relegate(e) { const n = this.members.findIndex(r => e === r); if (n === 0) return !1; let i; for (let r = n; r >= 0; r--) { const s = this.members[r]; if (s.isPresent !== !1) { i = s; break } } return i ? (this.promote(i), !0) : !1 } promote(e, n) { const i = this.lead; if (e !== i && (this.prevLead = i, this.lead = e, e.show(), i)) { i.instance && i.scheduleRender(), e.scheduleRender(), e.resumeFrom = i, n && (e.resumeFrom.preserveOpacity = !0), i.snapshot && (e.snapshot = i.snapshot, e.snapshot.latestValues = i.animationValues || i.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0); const { crossfade: r } = e.options; r === !1 && i.hide() } } exitAnimationComplete() { this.members.forEach(e => { const { options: n, resumingFrom: i } = e; n.onExitComplete && n.onExitComplete(), i && i.options.onExitComplete && i.options.onExitComplete() }) } scheduleRender() { this.members.forEach(e => { e.instance && e.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } function Ay(t, e, n) { let i = ""; const r = t.x.translate / e.x, s = t.y.translate / e.y; if ((r || s) && (i = `translate3d(${r}px, ${s}px, 0) `), (e.x !== 1 || e.y !== 1) && (i += `scale(${1 / e.x}, ${1 / e.y}) `), n) { const { rotate: l, rotateX: c, rotateY: u } = n; l && (i += `rotate(${l}deg) `), c && (i += `rotateX(${c}deg) `), u && (i += `rotateY(${u}deg) `) } const o = t.x.scale * e.x, a = t.y.scale * e.y; return (o !== 1 || a !== 1) && (i += `scale(${o}, ${a})`), i || "none" } const _D = (t, e) => t.depth - e.depth; class SD { constructor() { this.children = [], this.isDirty = !1 } add(e) { Pp(this.children, e), this.isDirty = !0 } remove(e) { Cp(this.children, e), this.isDirty = !0 } forEach(e) { this.isDirty && this.children.sort(_D), this.isDirty = !1, this.children.forEach(e) } } function kD(t, e) { const n = performance.now(), i = ({ timestamp: r }) => { const s = r - n; s >= e && (_i.read(i), t(s - e)) }; return Pe.read(i, !0), () => _i.read(i) } function PD(t) { window.MotionDebug && window.MotionDebug.record(t) } function CD(t) { return t instanceof SVGElement && t.tagName !== "svg" } function MD(t, e, n) { const i = kt(t) ? t : es(t); return i.start(kp("", i, e, n)), i.animation } const Ny = ["", "X", "Y", "Z"], Fy = 1e3; let TD = 0; const Bi = { type: "projectionFrame", totalNodes: 0, resolvedTargetDeltas: 0, recalculatedProjection: 0 }; function Sb({ attachResizeListener: t, defaultParent: e, measureScroll: n, checkIsScrollRoot: i, resetTransform: r }) { return class { constructor(o, a = {}, l = e == null ? void 0 : e()) { this.id = TD++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.potentialNodes = new Map, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { Bi.totalNodes = Bi.resolvedTargetDeltas = Bi.recalculatedProjection = 0, this.nodes.forEach(OD), this.nodes.forEach(AD), this.nodes.forEach(ND), this.nodes.forEach(RD), PD(Bi) }, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.elementId = o, this.latestValues = a, this.root = l ? l.root || l : this, this.path = l ? [...l.path, l] : [], this.parent = l, this.depth = l ? l.depth + 1 : 0, o && this.root.registerPotentialNode(o, this); for (let c = 0; c < this.path.length; c++)this.path[c].shouldResetTransform = !0; this.root === this && (this.nodes = new SD) } addEventListener(o, a) { return this.eventHandlers.has(o) || this.eventHandlers.set(o, new Mp), this.eventHandlers.get(o).add(a) } notifyListeners(o, ...a) { const l = this.eventHandlers.get(o); l && l.notify(...a) } hasListeners(o) { return this.eventHandlers.has(o) } registerPotentialNode(o, a) { this.potentialNodes.set(o, a) } mount(o, a = !1) { if (this.instance) return; this.isSVG = CD(o), this.instance = o; const { layoutId: l, layout: c, visualElement: u } = this.options; if (u && !u.current && u.mount(o), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.elementId && this.root.potentialNodes.delete(this.elementId), a && (c || l) && (this.isLayoutDirty = !0), t) { let d; const f = () => this.root.updateBlockedByResize = !1; t(o, () => { this.root.updateBlockedByResize = !0, d && d(), d = kD(f, 250), Xs.hasAnimatedSinceResize && (Xs.hasAnimatedSinceResize = !1, this.nodes.forEach(Vy)) }) } l && this.root.registerSharedNode(l, this), this.options.animate !== !1 && u && (l || c) && this.addEventListener("didUpdate", ({ delta: d, hasLayoutChanged: f, hasRelativeTargetChanged: h, layout: m }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } const p = this.options.transition || u.getDefaultTransition() || BD, { onLayoutAnimationStart: x, onLayoutAnimationComplete: y } = u.getProps(), g = !this.targetLayout || !Af(this.targetLayout, m) || h, v = !f && h; if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || v || f && (g || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(d, v); const b = { ...ab(p, "layout"), onPlay: x, onComplete: y }; (u.shouldReduceMotion || this.options.layoutRoot) && (b.delay = 0, b.type = !1), this.startAnimation(b) } else !f && this.animationProgress === 0 && Vy(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = m }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const o = this.getStack(); o && o.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, _i.preRender(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(FD), this.animationId++) } getTransformTemplate() { const { visualElement: o } = this.options; return o && o.getProps().transformTemplate } willUpdate(o = !0) { if (this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let u = 0; u < this.path.length; u++) { const d = this.path[u]; d.shouldResetTransform = !0, d.updateScroll("snapshot"), d.options.layoutRoot && d.willUpdate(!1) } const { layoutId: a, layout: l } = this.options; if (a === void 0 && !l) return; const c = this.getTransformTemplate(); this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0, this.updateSnapshot(), o && this.notifyListeners("willUpdate") } didUpdate() { if (this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Iy); return } this.isUpdating && (this.isUpdating = !1, this.potentialNodes.size && (this.potentialNodes.forEach(HD), this.potentialNodes.clear()), this.nodes.forEach(jD), this.nodes.forEach(ED), this.nodes.forEach(DD), this.clearAllSnapshots(), Wu.update(), Wu.preRender(), Wu.render()) } clearAllSnapshots() { this.nodes.forEach(LD), this.sharedNodes.forEach(ID) } scheduleUpdateProjection() { Pe.preRender(this.updateProjection, !1, !0) } scheduleCheckAfterUnmount() { Pe.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure()) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let l = 0; l < this.path.length; l++)this.path[l].updateScroll(); const o = this.layout; this.layout = this.measure(!1), this.layoutCorrected = Ie(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: a } = this.options; a && a.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0) } updateScroll(o = "measure") { let a = !!(this.options.layoutScroll && this.instance); this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1), a && (this.scroll = { animationId: this.root.animationId, phase: o, isRoot: i(this.instance), offset: n(this.instance) }) } resetTransform() { if (!r) return; const o = this.isLayoutDirty || this.shouldResetTransform, a = this.projectionDelta && !_b(this.projectionDelta), l = this.getTransformTemplate(), c = l ? l(this.latestValues, "") : void 0, u = c !== this.prevTransformTemplateValue; o && (a || zi(this.latestValues) || u) && (r(this.instance, c), this.shouldResetTransform = !1, this.scheduleRender()) } measure(o = !0) { const a = this.measurePageBox(); let l = this.removeElementScroll(a); return o && (l = this.removeTransform(l)), WD(l), { animationId: this.root.animationId, measuredBox: a, layoutBox: l, latestValues: {}, source: this.id } } measurePageBox() { const { visualElement: o } = this.options; if (!o) return Ie(); const a = o.measureViewportBox(), { scroll: l } = this.root; return l && (Zn(a.x, l.offset.x), Zn(a.y, l.offset.y)), a } removeElementScroll(o) { const a = Ie(); At(a, o); for (let l = 0; l < this.path.length; l++) { const c = this.path[l], { scroll: u, options: d } = c; if (c !== this.root && u && d.layoutScroll) { if (u.isRoot) { At(a, o); const { scroll: f } = this.root; f && (Zn(a.x, -f.offset.x), Zn(a.y, -f.offset.y)) } Zn(a.x, u.offset.x), Zn(a.y, u.offset.y) } } return a } applyTransform(o, a = !1) { const l = Ie(); At(l, o); for (let c = 0; c < this.path.length; c++) { const u = this.path[c]; !a && u.options.layoutScroll && u.scroll && u !== u.root && Nr(l, { x: -u.scroll.offset.x, y: -u.scroll.offset.y }), zi(u.latestValues) && Nr(l, u.latestValues) } return zi(this.latestValues) && Nr(l, this.latestValues), l } removeTransform(o) { const a = Ie(); At(a, o); for (let l = 0; l < this.path.length; l++) { const c = this.path[l]; if (!c.instance || !zi(c.latestValues)) continue; Rf(c.latestValues) && c.updateSnapshot(); const u = Ie(), d = c.measurePageBox(); At(u, d), Ry(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, u) } return zi(this.latestValues) && Ry(a, this.latestValues), a } setTargetDelta(o) { this.targetDelta = o, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(o) { this.options = { ...this.options, ...o, crossfade: o.crossfade !== void 0 ? o.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } resolveTargetDelta(o = !1) { var a; const l = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = l.isSharedProjectionDirty); const c = !!this.resumingFrom || this !== l; if (!(o || c && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget)) return; const { layout: d, layoutId: f } = this.options; if (!(!this.layout || !(d || f))) { if (this.resolvedRelativeTargetAt = ot.timestamp, !this.targetDelta && !this.relativeTarget) { const h = this.getClosestProjectingParent(); h && h.layout ? (this.relativeParent = h, this.relativeTarget = Ie(), this.relativeTargetOrigin = Ie(), Zs(this.relativeTargetOrigin, this.layout.layoutBox, h.layout.layoutBox), At(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } if (!(!this.relativeTarget && !this.targetDelta)) { if (this.target || (this.target = Ie(), this.targetWithTransforms = Ie()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.relativeParent.resolvedRelativeTargetAt !== ot.timestamp && this.relativeParent.resolveTargetDelta(!0), $4(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : At(this.target, this.layout.layoutBox), gb(this.target, this.targetDelta)) : At(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) { this.attemptToResolveRelativeTarget = !1; const h = this.getClosestProjectingParent(); h && !!h.resumingFrom == !!this.resumingFrom && !h.options.layoutScroll && h.target ? (this.relativeParent = h, this.relativeTarget = Ie(), this.relativeTargetOrigin = Ie(), Zs(this.relativeTargetOrigin, this.target, h.target), At(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } Bi.resolvedTargetDeltas++ } } } getClosestProjectingParent() { if (!(!this.parent || Rf(this.parent.latestValues) || mb(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } calcProjection() { var o; const a = this.getLead(), l = !!this.resumingFrom || this !== a; let c = !0; if ((this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty) && (c = !1), l && (this.isSharedProjectionDirty || this.isTransformDirty) && (c = !1), this.resolvedRelativeTargetAt === ot.timestamp && (c = !1), c) return; const { layout: u, layoutId: d } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(u || d)) return; At(this.layoutCorrected, this.layout.layoutBox), J4(this.layoutCorrected, this.treeScale, this.path, l); const { target: f } = a; if (!f) return; this.projectionDelta || (this.projectionDelta = Js(), this.projectionDeltaWithTransform = Js()); const h = this.treeScale.x, m = this.treeScale.y, p = this.projectionTransform; qs(this.projectionDelta, this.layoutCorrected, f, this.latestValues), this.projectionTransform = Ay(this.projectionDelta, this.treeScale), (this.projectionTransform !== p || this.treeScale.x !== h || this.treeScale.y !== m) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", f)), Bi.recalculatedProjection++ } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(o = !0) { if (this.options.scheduleRender && this.options.scheduleRender(), o) { const a = this.getStack(); a && a.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } setAnimationOrigin(o, a = !1) { const l = this.snapshot, c = l ? l.latestValues : {}, u = { ...this.latestValues }, d = Js(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a; const f = Ie(), h = l ? l.source : void 0, m = this.layout ? this.layout.source : void 0, p = h !== m, x = this.getStack(), y = !x || x.members.length <= 1, g = !!(p && !y && this.options.crossfade === !0 && !this.path.some(zD)); this.animationProgress = 0; let v; this.mixTargetDelta = b => { const _ = b / 1e3; zy(d.x, o.x, _), zy(d.y, o.y, _), this.setTargetDelta(d), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Zs(f, this.layout.layoutBox, this.relativeParent.layout.layoutBox), VD(this.relativeTarget, this.relativeTargetOrigin, f, _), v && Af(this.relativeTarget, v) && (this.isProjectionDirty = !1), v || (v = Ie()), At(v, this.relativeTarget)), p && (this.animationValues = u, mD(u, c, this.latestValues, _, g, y)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = _ }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(o) { this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (_i.update(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Pe.update(() => { Xs.hasAnimatedSinceResize = !0, this.currentAnimation = MD(0, Fy, { ...o, onUpdate: a => { this.mixTargetDelta(a), o.onUpdate && o.onUpdate(a) }, onComplete: () => { o.onComplete && o.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const o = this.getStack(); o && o.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(Fy), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const o = this.getLead(); let { targetWithTransforms: a, target: l, layout: c, latestValues: u } = o; if (!(!a || !l || !c)) { if (this !== o && this.layout && c && kb(this.options.animationType, this.layout.layoutBox, c.layoutBox)) { l = this.target || Ie(); const d = Rt(this.layout.layoutBox.x); l.x.min = o.target.x.min, l.x.max = l.x.min + d; const f = Rt(this.layout.layoutBox.y); l.y.min = o.target.y.min, l.y.max = l.y.min + f } At(a, l), Nr(a, u), qs(this.projectionDeltaWithTransform, this.layoutCorrected, a, u) } } registerSharedNode(o, a) { this.sharedNodes.has(o) || this.sharedNodes.set(o, new bD), this.sharedNodes.get(o).add(a); const c = a.options.initialPromotionConfig; a.promote({ transition: c ? c.transition : void 0, preserveFollowOpacity: c && c.shouldPreserveFollowOpacity ? c.shouldPreserveFollowOpacity(a) : void 0 }) } isLead() { const o = this.getStack(); return o ? o.lead === this : !0 } getLead() { var o; const { layoutId: a } = this.options; return a ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) || this : this } getPrevLead() { var o; const { layoutId: a } = this.options; return a ? (o = this.getStack()) === null || o === void 0 ? void 0 : o.prevLead : void 0 } getStack() { const { layoutId: o } = this.options; if (o) return this.root.sharedNodes.get(o) } promote({ needsReset: o, transition: a, preserveFollowOpacity: l } = {}) { const c = this.getStack(); c && c.promote(this, l), o && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a }) } relegate() { const o = this.getStack(); return o ? o.relegate(this) : !1 } resetRotation() { const { visualElement: o } = this.options; if (!o) return; let a = !1; const { latestValues: l } = o; if ((l.rotate || l.rotateX || l.rotateY || l.rotateZ) && (a = !0), !a) return; const c = {}; for (let u = 0; u < Ny.length; u++) { const d = "rotate" + Ny[u]; l[d] && (c[d] = l[d], o.setStaticValue(d, 0)) } o.render(); for (const u in c) o.setStaticValue(u, c[u]); o.scheduleRender() } getProjectionStyles(o = {}) { var a, l; const c = {}; if (!this.instance || this.isSVG) return c; if (this.isVisible) c.visibility = ""; else return { visibility: "hidden" }; const u = this.getTransformTemplate(); if (this.needsReset) return this.needsReset = !1, c.opacity = "", c.pointerEvents = yl(o.pointerEvents) || "", c.transform = u ? u(this.latestValues, "") : "none", c; const d = this.getLead(); if (!this.projectionDelta || !this.layout || !d.target) { const p = {}; return this.options.layoutId && (p.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, p.pointerEvents = yl(o.pointerEvents) || ""), this.hasProjected && !zi(this.latestValues) && (p.transform = u ? u({}, "") : "none", this.hasProjected = !1), p } const f = d.animationValues || d.latestValues; this.applyTransformsToTarget(), c.transform = Ay(this.projectionDeltaWithTransform, this.treeScale, f), u && (c.transform = u(f, c.transform)); const { x: h, y: m } = this.projectionDelta; c.transformOrigin = `${h.origin * 100}% ${m.origin * 100}% 0`, d.animationValues ? c.opacity = d === this ? (l = (a = f.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && l !== void 0 ? l : 1 : this.preserveOpacity ? this.latestValues.opacity : f.opacityExit : c.opacity = d === this ? f.opacity !== void 0 ? f.opacity : "" : f.opacityExit !== void 0 ? f.opacityExit : 0; for (const p in Zl) { if (f[p] === void 0) continue; const { correct: x, applyTo: y } = Zl[p], g = c.transform === "none" ? f[p] : x(f[p], d); if (y) { const v = y.length; for (let b = 0; b < v; b++)c[y[b]] = g } else c[p] = g } return this.options.layoutId && (c.pointerEvents = d === this ? yl(o.pointerEvents) || "" : "none"), c } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(o => { var a; return (a = o.currentAnimation) === null || a === void 0 ? void 0 : a.stop() }), this.root.nodes.forEach(Iy), this.root.sharedNodes.clear() } } } function ED(t) { t.updateLayout() } function DD(t) { var e; const n = ((e = t.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || t.snapshot; if (t.isLead() && t.layout && n && t.hasListeners("didUpdate")) { const { layoutBox: i, measuredBox: r } = t.layout, { animationType: s } = t.options, o = n.source !== t.layout.source; s === "size" ? cn(d => { const f = o ? n.measuredBox[d] : n.layoutBox[d], h = Rt(f); f.min = i[d].min, f.max = f.min + h }) : kb(s, n.layoutBox, i) && cn(d => { const f = o ? n.measuredBox[d] : n.layoutBox[d], h = Rt(i[d]); f.max = f.min + h, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[d].max = t.relativeTarget[d].min + h) }); const a = Js(); qs(a, i, n.layoutBox); const l = Js(); o ? qs(l, t.applyTransform(r, !0), n.measuredBox) : qs(l, i, n.layoutBox); const c = !_b(a); let u = !1; if (!t.resumeFrom) { const d = t.getClosestProjectingParent(); if (d && !d.resumeFrom) { const { snapshot: f, layout: h } = d; if (f && h) { const m = Ie(); Zs(m, n.layoutBox, f.layoutBox); const p = Ie(); Zs(p, i, h.layoutBox), Af(m, p) || (u = !0), d.options.layoutRoot && (t.relativeTarget = p, t.relativeTargetOrigin = m, t.relativeParent = d) } } } t.notifyListeners("didUpdate", { layout: i, snapshot: n, delta: l, layoutDelta: a, hasLayoutChanged: c, hasRelativeTargetChanged: u }) } else if (t.isLead()) { const { onExitComplete: i } = t.options; i && i() } t.options.transition = void 0 } function OD(t) { Bi.totalNodes++, t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty)) } function RD(t) { t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1 } function LD(t) { t.clearSnapshot() } function Iy(t) { t.clearMeasurements() } function jD(t) { const { visualElement: e } = t.options; e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), t.resetTransform() } function Vy(t) { t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0 } function AD(t) { t.resolveTargetDelta() } function ND(t) { t.calcProjection() } function FD(t) { t.resetRotation() } function ID(t) { t.removeLeadSnapshot() } function zy(t, e, n) { t.translate = ke(e.translate, 0, n), t.scale = ke(e.scale, 1, n), t.origin = e.origin, t.originPoint = e.originPoint } function By(t, e, n, i) { t.min = ke(e.min, n.min, i), t.max = ke(e.max, n.max, i) } function VD(t, e, n, i) { By(t.x, e.x, n.x, i), By(t.y, e.y, n.y, i) } function zD(t) { return t.animationValues && t.animationValues.opacityExit !== void 0 } const BD = { duration: .45, ease: [.4, 0, .1, 1] }; function HD(t, e) { let n = t.root; for (let s = t.path.length - 1; s >= 0; s--)if (t.path[s].instance) { n = t.path[s]; break } const r = (n && n !== t.root ? n.instance : document).querySelector(`[data-projection-id="${e}"]`); r && t.mount(r, !0) } function Hy(t) { t.min = Math.round(t.min), t.max = Math.round(t.max) } function WD(t) { Hy(t.x), Hy(t.y) } function kb(t, e, n) { return t === "position" || t === "preserve-aspect" && !Df(jy(e), jy(n), .2) } const $D = Sb({ attachResizeListener: (t, e) => On(t, "resize", e), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), ed = { current: void 0 }, Pb = Sb({ measureScroll: t => ({ x: t.scrollLeft, y: t.scrollTop }), defaultParent: () => { if (!ed.current) { const t = new $D(0, {}); t.mount(window), t.setOptions({ layoutScroll: !0 }), ed.current = t } return ed.current }, resetTransform: (t, e) => { t.style.transform = e !== void 0 ? e : "none" }, checkIsScrollRoot: t => window.getComputedStyle(t).position === "fixed" }), UD = { pan: { Feature: aD }, drag: { Feature: oD, ProjectionNode: Pb, MeasureLayout: xb } }, YD = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y"]), Cb = t => YD.has(t), KD = t => Object.keys(t).some(Cb), Wy = t => t === hr || t === X, $y = (t, e) => parseFloat(t.split(", ")[e]), Uy = (t, e) => (n, { transform: i }) => { if (i === "none" || !i) return 0; const r = i.match(/^matrix3d\((.+)\)$/); if (r) return $y(r[1], e); { const s = i.match(/^matrix\((.+)\)$/); return s ? $y(s[1], t) : 0 } }, XD = new Set(["x", "y", "z"]), GD = Yc.filter(t => !XD.has(t)); function QD(t) { const e = []; return GD.forEach(n => { const i = t.getValue(n); i !== void 0 && (e.push([n, i.get()]), i.set(n.startsWith("scale") ? 1 : 0)) }), e.length && t.render(), e } const Yy = { width: ({ x: t }, { paddingLeft: e = "0", paddingRight: n = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(n), height: ({ y: t }, { paddingTop: e = "0", paddingBottom: n = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(n), top: (t, { top: e }) => parseFloat(e), left: (t, { left: e }) => parseFloat(e), bottom: ({ y: t }, { top: e }) => parseFloat(e) + (t.max - t.min), right: ({ x: t }, { left: e }) => parseFloat(e) + (t.max - t.min), x: Uy(4, 13), y: Uy(5, 14) }, qD = (t, e, n) => { const i = e.measureViewportBox(), r = e.current, s = getComputedStyle(r), { display: o } = s, a = {}; o === "none" && e.setStaticValue("display", t.display || "block"), n.forEach(c => { a[c] = Yy[c](i, s) }), e.render(); const l = e.measureViewportBox(); return n.forEach(c => { const u = e.getValue(c); u && u.jump(a[c]), t[c] = Yy[c](l, s) }), t }, ZD = (t, e, n = {}, i = {}) => { e = { ...e }, i = { ...i }; const r = Object.keys(e).filter(Cb); let s = [], o = !1; const a = []; if (r.forEach(l => { const c = t.getValue(l); if (!t.hasValue(l)) return; let u = n[l], d = bs(u); const f = e[l]; let h; if (ec(f)) { const m = f.length, p = f[0] === null ? 1 : 0; u = f[p], d = bs(u); for (let x = p; x < m; x++)h ? Qc(bs(f[x]) === h) : h = bs(f[x]) } else h = bs(f); if (d !== h) if (Wy(d) && Wy(h)) { const m = c.get(); typeof m == "string" && c.set(parseFloat(m)), typeof f == "string" ? e[l] = parseFloat(f) : Array.isArray(f) && h === X && (e[l] = f.map(parseFloat)) } else d != null && d.transform && (h != null && h.transform) && (u === 0 || f === 0) ? u === 0 ? c.set(h.transform(u)) : e[l] = d.transform(f) : (o || (s = QD(t), o = !0), a.push(l), i[l] = i[l] !== void 0 ? i[l] : e[l], c.jump(f)) }), a.length) { const l = a.indexOf("height") >= 0 ? window.pageYOffset : null, c = qD(e, t, a); return s.length && s.forEach(([u, d]) => { t.getValue(u).set(d) }), t.render(), Wc && l !== null && window.scrollTo({ top: l }), { target: c, transitionEnd: i } } else return { target: e, transitionEnd: i } }; function JD(t, e, n, i) { return KD(e) ? ZD(t, e, n, i) : { target: e, transitionEnd: i } } const eO = (t, e, n, i) => { const r = uD(t, e, i); return e = r.target, i = r.transitionEnd, JD(t, e, n, i) }, Nf = { current: null }, Mb = { current: !1 }; function tO() { if (Mb.current = !0, !!Wc) if (window.matchMedia) { const t = window.matchMedia("(prefers-reduced-motion)"), e = () => Nf.current = t.matches; t.addListener(e), e() } else Nf.current = !1 } function nO(t, e, n) { const { willChange: i } = e; for (const r in e) { const s = e[r], o = n[r]; if (kt(s)) t.addValue(r, s), rc(i) && i.add(r); else if (kt(o)) t.addValue(r, es(s, { owner: t })), rc(i) && i.remove(r); else if (o !== s) if (t.hasValue(r)) { const a = t.getValue(r); !a.hasAnimated && a.set(s) } else { const a = t.getStaticValue(r); t.addValue(r, es(a !== void 0 ? a : s, { owner: t })) } } for (const r in n) e[r] === void 0 && t.removeValue(r); return e } const Ky = new WeakMap, Tb = Object.keys(Oo), iO = Tb.length, Xy = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"], rO = cp.length; class sO { constructor({ parent: e, props: n, presenceContext: i, reducedMotionConfig: r, visualState: s }, o = {}) { this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.scheduleRender = () => Pe.render(this.render, !1, !0); const { latestValues: a, renderState: l } = s; this.latestValues = a, this.baseTarget = { ...a }, this.initialValues = n.initial ? { ...a } : {}, this.renderState = l, this.parent = e, this.props = n, this.presenceContext = i, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = r, this.options = o, this.isControllingVariants = Uc(n), this.isVariantNode = mw(n), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(e && e.current); const { willChange: c, ...u } = this.scrapeMotionValuesFromProps(n, {}); for (const d in u) { const f = u[d]; a[d] !== void 0 && kt(f) && (f.set(a[d], !1), rc(c) && c.add(d)) } } scrapeMotionValuesFromProps(e, n) { return {} } mount(e) { this.current = e, Ky.set(e, this), this.projection && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, i) => this.bindToMotionValue(i, n)), Mb.current || tO(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : Nf.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext) } unmount() { Ky.delete(this.current), this.projection && this.projection.unmount(), _i.update(this.notifyUpdate), _i.render(this.render), this.valueSubscriptions.forEach(e => e()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this); for (const e in this.events) this.events[e].clear(); for (const e in this.features) this.features[e].unmount(); this.current = null } bindToMotionValue(e, n) { const i = fr.has(e), r = n.on("change", o => { this.latestValues[e] = o, this.props.onUpdate && Pe.update(this.notifyUpdate, !1, !0), i && this.projection && (this.projection.isTransformDirty = !0) }), s = n.on("renderRequest", this.scheduleRender); this.valueSubscriptions.set(e, () => { r(), s() }) } sortNodePosition(e) { return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current) } loadFeatures({ children: e, ...n }, i, r, s, o) { let a, l; for (let c = 0; c < iO; c++) { const u = Tb[c], { isEnabled: d, Feature: f, ProjectionNode: h, MeasureLayout: m } = Oo[u]; h && (a = h), d(n) && (!this.features[u] && f && (this.features[u] = new f(this)), m && (l = m)) } if (!this.projection && a) { this.projection = new a(s, this.latestValues, this.parent && this.parent.projection); const { layoutId: c, layout: u, drag: d, dragConstraints: f, layoutScroll: h, layoutRoot: m } = n; this.projection.setOptions({ layoutId: c, layout: u, alwaysMeasureLayout: !!d || f && jr(f), visualElement: this, scheduleRender: () => this.scheduleRender(), animationType: typeof u == "string" ? u : "both", initialPromotionConfig: o, layoutScroll: h, layoutRoot: m }) } return l } updateFeatures() { for (const e in this.features) { const n = this.features[e]; n.isMounted ? n.update(this.props, this.prevProps) : (n.mount(), n.isMounted = !0) } } triggerBuild() { this.build(this.renderState, this.latestValues, this.options, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Ie() } getStaticValue(e) { return this.latestValues[e] } setStaticValue(e, n) { this.latestValues[e] = n } makeTargetAnimatable(e, n = !0) { return this.makeTargetAnimatableFromInstance(e, this.props, n) } update(e, n) { (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = n; for (let i = 0; i < Xy.length; i++) { const r = Xy[i]; this.propEventSubscriptions[r] && (this.propEventSubscriptions[r](), delete this.propEventSubscriptions[r]); const s = e["on" + r]; s && (this.propEventSubscriptions[r] = this.on(r, s)) } this.prevMotionValues = nO(this, this.scrapeMotionValuesFromProps(e, this.prevProps), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(e) { return this.props.variants ? this.props.variants[e] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } getVariantContext(e = !1) { if (e) return this.parent ? this.parent.getVariantContext() : void 0; if (!this.isControllingVariants) { const i = this.parent ? this.parent.getVariantContext() || {} : {}; return this.props.initial !== void 0 && (i.initial = this.props.initial), i } const n = {}; for (let i = 0; i < rO; i++) { const r = cp[i], s = this.props[r]; (Do(s) || s === !1) && (n[r] = s) } return n } addVariantChild(e) { const n = this.getClosestVariantNode(); if (n) return n.variantChildren && n.variantChildren.add(e), () => n.variantChildren.delete(e) } addValue(e, n) { n !== this.values.get(e) && (this.removeValue(e), this.bindToMotionValue(e, n)), this.values.set(e, n), this.latestValues[e] = n.get() } removeValue(e) { this.values.delete(e); const n = this.valueSubscriptions.get(e); n && (n(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState) } hasValue(e) { return this.values.has(e) } getValue(e, n) { if (this.props.values && this.props.values[e]) return this.props.values[e]; let i = this.values.get(e); return i === void 0 && n !== void 0 && (i = es(n, { owner: this }), this.addValue(e, i)), i } readValue(e) { return this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : this.readValueFromInstance(this.current, e, this.options) } setBaseTarget(e, n) { this.baseTarget[e] = n } getBaseTarget(e) { var n; const { initial: i } = this.props, r = typeof i == "string" || typeof i == "object" ? (n = vp(this.props, i)) === null || n === void 0 ? void 0 : n[e] : void 0; if (i && r !== void 0) return r; const s = this.getBaseTargetFromProps(this.props, e); return s !== void 0 && !kt(s) ? s : this.initialValues[e] !== void 0 && r === void 0 ? void 0 : this.baseTarget[e] } on(e, n) { return this.events[e] || (this.events[e] = new Mp), this.events[e].add(n) } notify(e, ...n) { this.events[e] && this.events[e].notify(...n) } } class Eb extends sO { sortInstanceNodePosition(e, n) { return e.compareDocumentPosition(n) & 2 ? 1 : -1 } getBaseTargetFromProps(e, n) { return e.style ? e.style[n] : void 0 } removeValueFromRenderState(e, { vars: n, style: i }) { delete n[e], delete i[e] } makeTargetAnimatableFromInstance({ transition: e, transitionEnd: n, ...i }, { transformValues: r }, s) { let o = M4(i, e || {}, this); if (r && (n && (n = r(n)), i && (i = r(i)), o && (o = r(o))), s) { P4(this, i, o); const a = eO(this, i, o, n); n = a.transitionEnd, i = a.target } return { transition: e, transitionEnd: n, ...i } } } function oO(t) { return window.getComputedStyle(t) } class aO extends Eb { readValueFromInstance(e, n) { if (fr.has(n)) { const i = _p(n); return i && i.default || 0 } else { const i = oO(e), r = (ww(n) ? i.getPropertyValue(n) : i[n]) || 0; return typeof r == "string" ? r.trim() : r } } measureInstanceViewportBox(e, { transformPagePoint: n }) { return yb(e, n) } build(e, n, i, r) { fp(e, n, i, r.transformTemplate) } scrapeMotionValuesFromProps(e, n) { return yp(e, n) } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: e } = this.props; kt(e) && (this.childSubscription = e.on("change", n => { this.current && (this.current.textContent = `${n}`) })) } renderInstance(e, n, i, r) { Pw(e, n, i, r) } } class lO extends Eb { constructor() { super(...arguments), this.isSVGTag = !1 } getBaseTargetFromProps(e, n) { return e[n] } readValueFromInstance(e, n) { if (fr.has(n)) { const i = _p(n); return i && i.default || 0 } return n = Cw.has(n) ? n : gp(n), e.getAttribute(n) } measureInstanceViewportBox() { return Ie() } scrapeMotionValuesFromProps(e, n) { return Tw(e, n) } build(e, n, i, r) { pp(e, n, i, this.isSVGTag, r.transformTemplate) } renderInstance(e, n, i, r) { Mw(e, n, i, r) } mount(e) { this.isSVGTag = mp(e.tagName), super.mount(e) } } const cO = (t, e) => dp(t) ? new lO(e, { enableHardwareAcceleration: !1 }) : new aO(e, { enableHardwareAcceleration: !0 }), uO = { layout: { ProjectionNode: Pb, MeasureLayout: xb } }, dO = { ...z4, ...oE, ...UD, ...uO }, U = mT((t, e) => WT(t, e, dO, cO)); function fO(t, e, n) { var i; if (typeof t == "string") { let r = document; e && (Qc(!!e.current), r = e.current), n ? ((i = n[t]) !== null && i !== void 0 || (n[t] = r.querySelectorAll(t)), t = n[t]) : t = r.querySelectorAll(t) } else t instanceof Element && (t = [t]); return Array.from(t || []) } function hO(t) { t.values.forEach(e => e.stop()) } function pO() { const t = new Set, e = { subscribe(n) { return t.add(n), () => void t.delete(n) }, start(n, i) { const r = []; return t.forEach(s => { r.push(db(s, n, { transitionOverride: i })) }), Promise.all(r) }, set(n) { return t.forEach(i => { k4(i, n) }) }, stop() { t.forEach(n => { hO(n) }) }, mount() { return () => { e.stop() } } }; return e } function oc() { const t = up(pO); return xf(t.mount, []), t } const mO = { any: 0, all: 1 }; function gO(t, e, { root: n, margin: i, amount: r = "any" } = {}) { const s = fO(t), o = new WeakMap, a = c => { c.forEach(u => { const d = o.get(u.target); if (u.isIntersecting !== !!d) if (u.isIntersecting) { const f = e(u); typeof f == "function" ? o.set(u.target, f) : l.unobserve(u.target) } else d && (d(u), o.delete(u.target)) }) }, l = new IntersectionObserver(a, { root: n, rootMargin: i, threshold: typeof r == "number" ? r : mO[r] }); return s.forEach(c => l.observe(c)), () => l.disconnect() } function eo(t, { root: e, margin: n, amount: i, once: r = !1 } = {}) { const [s, o] = M.useState(!1); return M.useEffect(() => { if (!t.current || r && s) return; const a = () => (o(!0), r ? void 0 : () => o(!1)), l = { root: e && e.current || void 0, margin: n, amount: i === "some" ? "any" : i }; return gO(t.current, a, l) }, [e, t, n, r]), s } const yO = ({ loading: t, setLoading: e }) => { const [n, i] = M.useState(0), r = .5; return M.useEffect(() => { setTimeout(() => { e(!1) }, 3e3), setTimeout(() => { i(1), typeof window < "u" && window.document && (document.body.style.overflow = "auto") }, 2800) }, []), t ? w.jsx("div", { className: "h-screen w-full overflow-hidden fixed z-[500]", children: w.jsx("div", { className: ` ${n === 0 ? " bg-primary bg-gradient-to-tr from-[#24243e] via-[#2a355e] to-[#0f0c29] " : "bg-transparent"} transition-colors duration-500 h-screen w-full flex justify-center items-center`, children: n === 0 && w.jsxs("div", { className: " border-accent rounded-full p-4 relative overflow-hidden h-32 w-32", children: [w.jsx(U.div, { animate: { height: ["0%", "100%"] }, initial: { height: "0%" }, transition: { ease: "linear", duration: r + .5, delay: r + 1 }, className: " bg-primary h-full w-full absolute bottom-0 left-0 z-0 " }), w.jsx(U.svg, { className: "z-50 h-full w-full absolute bottom-0 left-0", viewBox: "0 0 110 110", children: w.jsx(U.circle, { className: "z-50", cx: "55", cy: "55", r: "55", fill: "transparent", initial: { pathLength: 0 }, animate: { pathLength: 1 }, transition: { ease: "linear", duration: r + .2, delay: r }, stroke: "#ffffff", strokeWidth: 5 }) }), w.jsx(U.img, { animate: { opacity: [0, 1] }, transition: { ease: "linear", duration: r }, initial: { opacity: 0 }, className: "z-50 relative", src: "/logo-side.png", height: 90, width: 100 })] }) }) }) : w.jsx("div", {}) }, vO = () => { const t = oc(), e = oc(), [n, i] = M.useState(!0); return M.useEffect(() => { setTimeout(() => { t.start({ scale: [.7, .9, 1] }), e.start({ opacity: [.7, .9, 1] }), i(!1) }, 4500) }, [t]), w.jsxs("section", { id: "home", className: "lg:min-h-screen bg-secondary relative flex justify-center", children: [w.jsx("div", { className: "absolute h-full w-full z-10 gradiant" }), w.jsx("div", { className: "screen-optz w-full z-20 flex pt-8 lg:pt-40 flex-wrap", children: w.jsxs("div", { className: "w-full flex justify-center items-center flex-wrap content-center text-center py-4  ", children: [w.jsx("div", { className: "w-full text-accent text-3xl lg:text-7xl font-bold tracking-widest font-mono lg:my-10", children: "TTF Bot" }), w.jsx("div", { className: "w-full text-netural text-xl lg:text-4xl font-semibold my-4  lg:my-6", children: "Track the Funds" }), w.jsx(U.div, { animate: e, initial: { opacity: .7 }, className: "w-full  flex justify-center items-center my-4 px-4", children: w.jsx("video", { muted: !0, autoPlay: !0, className: "rounded-lg h-full w-full lg:w-[calc(100%-10rem)]", controls: !0, children: w.jsx("source", { src: "/intro.mp4", type: "video/mp4" }) }) }), w.jsx("button", { className: "btn btn-primary lg:btn-xl  hover:bg-secondary text-accent my-8 w-40 rounded-full ", children: w.jsx("a", { href: "https://ttf-bot.gitbook.io/track-the-funds-ttf-bot-1/", target: "_blank", children: "Whitepaper" }) })] }) })] }) }; function xO(t) { return xn({ tag: "svg", attr: { viewBox: "0 0 12 16" }, child: [{ tag: "path", attr: { fillRule: "evenodd", d: "M7.48 8l3.75 3.75-1.48 1.48L6 9.48l-3.75 3.75-1.48-1.48L4.52 8 .77 4.25l1.48-1.48L6 6.52l3.75-3.75 1.48 1.48L7.48 8z" } }] })(t) } function wO(t) { return xn({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "none" }, child: [{ tag: "path", attr: { fillRule: "evenodd", clipRule: "evenodd", d: "M16 12C16 14.2091 14.2091 16 12 16C9.79086 16 8 14.2091 8 12C8 9.79086 9.79086 8 12 8C14.2091 8 16 9.79086 16 12ZM14 12C14 13.1046 13.1046 14 12 14C10.8954 14 10 13.1046 10 12C10 10.8954 10.8954 10 12 10C13.1046 10 14 10.8954 14 12Z", fill: "currentColor" } }, { tag: "path", attr: { fillRule: "evenodd", clipRule: "evenodd", d: "M12 3C17.5915 3 22.2898 6.82432 23.6219 12C22.2898 17.1757 17.5915 21 12 21C6.40848 21 1.71018 17.1757 0.378052 12C1.71018 6.82432 6.40848 3 12 3ZM12 19C7.52443 19 3.73132 16.0581 2.45723 12C3.73132 7.94186 7.52443 5 12 5C16.4756 5 20.2687 7.94186 21.5428 12C20.2687 16.0581 16.4756 19 12 19Z", fill: "currentColor" } }] })(t) } function bO(t) { return xn({ tag: "svg", attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { fill: "none", d: "M0 0h24v24H0z" } }, { tag: "path", attr: { d: "M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z" } }] })(t) } const _O = () => w.jsxs("section", { id: "info", className: " bg-neutral relative flex justify-center flex-wrap", children: [w.jsxs("svg", { className: "w-full ", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1440 320", children: [w.jsx("path", { fill: "url(#myGradient)", "fill-opacity": "1", d: "M0,224L48,234.7C96,245,192,267,288,272C384,277,480,267,576,240C672,213,768,171,864,170.7C960,171,1056,213,1152,197.3C1248,181,1344,107,1392,69.3L1440,32L1440,0L1392,0C1344,0,1248,0,1152,0C1056,0,960,0,864,0C768,0,672,0,576,0C480,0,384,0,288,0C192,0,96,0,48,0L0,0Z" }), w.jsxs("linearGradient", { id: "myGradient", x1: "0%", y1: "0%", x2: "100%", y2: "0%", children: [w.jsx("stop", { offset: "0%", "stop-color": "#24243e" }), w.jsx("stop", { offset: "50%", "stop-color": "#2a355e" }), w.jsx("stop", { offset: "100%", "stop-color": "#0f0c29" })] })] }), w.jsxs("div", { className: "screen-optz lg:-my-60   overflow-hidden w-full z-20 flex p-8 lg:py-16 justify-around lg:justify-between lg:flex-nowrap gap-12 flex-wrap ", children: [w.jsxs(U.div, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0, x: -50 }, whileInView: { opacity: [.5, .7, 1], x: 0 }, className: "w-full lg:h-[28rem] xl:h-[36rem] my-4 lg:w-1/3 p-4 flex justify-center flex-wrap content-start  bg-primary rounded-xl ", children: [w.jsx(U.div, { transition: { ease: "linear", duration: .7 }, initial: { scale: .7 }, whileInView: { scale: [.7, .9, 1] }, children: w.jsx(xO, { className: "text-secondary xl:h-24 xl:w-24 h-16 w-16" }) }), w.jsx("div", { className: "w-full text-center text-secondary font-bold xl:text-4xl text-2xl mb-2 xl:mb-6", children: "Problem" }), w.jsx("div", { className: "my-2 py-2  xl:text-xl text-lg text-netural", children: "The most important thing to do when beginning to invest in cryptocurrencies is to practice safe trading." }), w.jsx("div", { className: "my-2 py-2  xl:text-xl text-lg text-netural", children: "Trading cryptocurrency is a risky business but has the potential for high rewards.This attracts investors from all walks of life.But the reality is that only a fraction of investors end up in profit." })] }), w.jsxs(U.div, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0, y: 50 }, whileInView: { y: 0, opacity: [.5, .7, 1] }, className: "w-full lg:h-[28rem] xl:h-[36rem]  my-4 lg:w-1/3 p-4 flex justify-center flex-wrap content-start  bg-primary rounded-xl ", children: [w.jsx(U.div, { transition: { ease: "linear", duration: .7 }, initial: { scale: .7 }, whileInView: { scale: [.7, .9, 1] }, children: w.jsx(wO, { className: "text-secondary xl:h-24 xl:w-24 h-16 w-16" }) }), w.jsx("div", { className: "w-full text-center text-secondary font-bold xl:text-4xl text-2xl mb-2 xl:mb-6", children: "Vision" }), w.jsx("div", { className: "my-2 py-2  xl:text-xl text-lg text-netural", children: "To make trading safer by empowering the investors with data to help select legitimate projects while avoiding scams." }), w.jsx("div", { className: "my-2 py-2  xl:text-xl text-lg text-netural", children: "Assist project owners to provide transparency to their community, so traders can have the confidence to buy or continue to hold." })] }), w.jsxs(U.div, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0, x: 50 }, whileInView: { x: 0, opacity: [.5, .7, 1] }, className: "w-full lg:h-[28rem] xl:h-[36rem]  my-4 lg:w-1/3 p-4 flex justify-center flex-wrap content-start  bg-primary rounded-xl ", children: [w.jsx(U.div, { transition: { ease: "linear", duration: .7 }, initial: { scale: .7 }, whileInView: { scale: [.7, .9, 1] }, children: w.jsx(bO, { className: "text-secondary xl:h-24 xl:w-24 h-16 w-16" }) }), w.jsx("div", { className: "w-full text-center text-secondary font-bold xl:text-4xl text-2xl mb-2 xl:mb-6", children: " Solution" }), w.jsx("div", { className: "my-2 py-2 xl:text-xl  text-lg text-netural", children: "A telegram bot that creates a report on the token and monitors activity on the Blockchain." }), w.jsx("div", { className: "my-2 py-2  xl:text-xl text-lg text-netural", children: "TTF Bot provides data for due diligence, tracks, monitors and alerts blockchain activity, and allows founders to provide transparency." })] })] }), w.jsxs("svg", { className: "w-full lg:-mt-[10rem] ", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1440 320", children: [w.jsx("path", { fill: "url(#myGradient)", "fill-opacity": "1", d: "M0,256L48,240C96,224,192,192,288,176C384,160,480,160,576,176C672,192,768,224,864,202.7C960,181,1056,107,1152,106.7C1248,107,1344,181,1392,218.7L1440,256L1440,320L1392,320C1344,320,1248,320,1152,320C1056,320,960,320,864,320C768,320,672,320,576,320C480,320,384,320,288,320C192,320,96,320,48,320L0,320Z" }), w.jsxs("linearGradient", { id: "myGradient", x1: "0%", y1: "0%", x2: "100%", y2: "0%", children: [w.jsx("stop", { offset: "0%", "stop-color": "#24243e" }), w.jsx("stop", { offset: "50%", "stop-color": "#2a355e" }), w.jsx("stop", { offset: "100%", "stop-color": "#0f0c29" })] })] })] }), SO = () => w.jsx("section", { id: "utility", className: "gradiant relative flex justify-center  ", children: w.jsxs("div", { className: "screen-optz overflow-hidden w-full z-20 flex flex-wrap justify-center px-8 lg:px-0 pt-16 lg:py-20", children: [w.jsx(U.p, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0, x: -50 }, whileInView: { x: 0, opacity: [.5, .7, 1] }, className: "w-full -mb-2 text-base font-semibold leading-7 text-secondary", children: "Features & Benefits" }), w.jsx(U.h1, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0, x: -50 }, whileInView: { x: 0, opacity: [.5, .7, 1] }, className: "w-full text-4xl lg:text-6xl font-extrabold tracking-wide text-accent sm:text-4xl ", children: "TTF Value" }), w.jsxs("div", { className: "w-full lg:h-full lg:w-1/3 flex py-8 lg:px-10 flex-wrap", children: [w.jsx("div", { className: "w-full flex justify-center lg:my-8 lg:h-full lg:items-center", children: w.jsx(U.img, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0, x: -50 }, whileInView: { x: 0, opacity: [.5, .7, 1] }, src: "/utility-1.png", className: "lg:-mt-16 h-148 w-76 lg:h-[43.32rem] lg:w-96  rounded-sm" }) }), w.jsxs(U.div, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0, x: -50 }, whileInView: { x: 0, opacity: [.5, .7, 1] }, className: "lg:hidden w-full h-full lg:text-center ", children: [w.jsx("div", { className: "mb-10 font-semibold text-3xl text-accent mt-8", children: "Token Reports" }), w.jsx("div", { className: "my-4 text-xl font-medium", children: "We recommend using TTF Bot to scan the token prior to purchasing any BSC or ETH projects." }), w.jsx("div", { className: "text-xl  font-medium", children: "You will receive information such as; is it a honeypot; can tokens be minted, market-cap, liquidity, supply, wallet and transaction limits, buy and sell tax. It doesn't end there, it will report balances in marketing and team wallets, airdrops, and top holders." })] })] }), w.jsxs("div", { className: "hidden w-full lg:w-1/3 py-8 lg:flex lg:px-10 flex-wrap", children: [w.jsxs(U.div, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0, x: -50 }, whileInView: { x: 0, opacity: [.5, .7, 1] }, className: "w-full lg:text-center ", children: [w.jsx("div", { className: "mb-10 font-semibold text-3xl text-accent", children: "Token Reports" }), w.jsx("div", { className: "my-4 text-xl font-medium", children: "We recommend using TTF Bot to scan the token prior to purchasing any BSC or ETH projects." }), w.jsx("div", { className: "text-xl  font-medium", children: "You will receive information such as; is it a honeypot; can tokens be minted, market-cap, liquidity, supply, wallet and transaction limits, buy and sell tax. It doesn't end there, it will report balances in marketing and team wallets, airdrops, and top holders." })] }), w.jsxs(U.div, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0, x: 50 }, whileInView: { x: 0, opacity: [.5, .7, 1] }, className: "w-full lg:text-center mt-8 ", children: [w.jsx("div", { className: "mb-10 font-semibold text-3xl text-accent", children: "Charts & Alerts" }), w.jsx("div", { className: "my-4 text-xl font-medium", children: "We recommend using TTF Bot to monitor Blockchain transactions." }), w.jsx("div", { className: "my-4 text-xl font-medium", children: "You will be notified when; funds are moved out of the team wallets, taxes are changed, limits changed, and tokens are bought or sold." }), w.jsx("div", { className: "text-xl  font-medium", children: "Instant on demand charts are available at the touch of a button." })] })] }), w.jsxs("div", { className: "w-full lg:h-full lg:w-1/3 flex py-8 lg:px-10 flex-wrap", children: [w.jsx("div", { className: "w-full flex justify-center lg:my-8 lg:h-full lg:items-center", children: w.jsx(U.img, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0, x: -50 }, whileInView: { x: 0, opacity: [.5, .7, 1] }, src: "/utility-2.png", className: "lg:-mt-16 h-128 w-96 lg:h-[43.32rem] lg:w-96  rounded-sm" }) }), w.jsxs(U.div, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0, x: -50 }, whileInView: { x: 0, opacity: [.5, .7, 1] }, className: "lg:hidden w-full h-full lg:text-center ", children: [w.jsx("div", { className: "mb-10 font-semibold text-3xl text-accent mt-8", children: "Charts & Alerts" }), w.jsx("div", { className: "my-4 text-xl font-medium", children: "We recommend using TTF Bot to monitor Blockchain transactions." }), w.jsx("div", { className: "my-4 text-xl font-medium", children: "You will be notified when; funds are moved out of the team wallets, taxes are changed, limits changed, and tokens are bought or sold." }), w.jsx("div", { className: "text-xl  font-medium", children: "Instant on demand charts are available at the touch of a button." }), "          "] })] })] }) });/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */function ra(t) { return t + .5 | 0 } const ii = (t, e, n) => Math.max(Math.min(t, n), e); function js(t) { return ii(ra(t * 2.55), 0, 255) } function xi(t) { return ii(ra(t * 255), 0, 255) } function Tn(t) { return ii(ra(t / 2.55) / 100, 0, 1) } function Gy(t) { return ii(ra(t * 100), 0, 100) } const Nt = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, Ff = [..."0123456789ABCDEF"], kO = t => Ff[t & 15], PO = t => Ff[(t & 240) >> 4] + Ff[t & 15], Va = t => (t & 240) >> 4 === (t & 15), CO = t => Va(t.r) && Va(t.g) && Va(t.b) && Va(t.a); function MO(t) { var e = t.length, n; return t[0] === "#" && (e === 4 || e === 5 ? n = { r: 255 & Nt[t[1]] * 17, g: 255 & Nt[t[2]] * 17, b: 255 & Nt[t[3]] * 17, a: e === 5 ? Nt[t[4]] * 17 : 255 } : (e === 7 || e === 9) && (n = { r: Nt[t[1]] << 4 | Nt[t[2]], g: Nt[t[3]] << 4 | Nt[t[4]], b: Nt[t[5]] << 4 | Nt[t[6]], a: e === 9 ? Nt[t[7]] << 4 | Nt[t[8]] : 255 })), n } const TO = (t, e) => t < 255 ? e(t) : ""; function EO(t) { var e = CO(t) ? kO : PO; return t ? "#" + e(t.r) + e(t.g) + e(t.b) + TO(t.a, e) : void 0 } const DO = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/; function Db(t, e, n) { const i = e * Math.min(n, 1 - n), r = (s, o = (s + t / 30) % 12) => n - i * Math.max(Math.min(o - 3, 9 - o, 1), -1); return [r(0), r(8), r(4)] } function OO(t, e, n) { const i = (r, s = (r + t / 60) % 6) => n - n * e * Math.max(Math.min(s, 4 - s, 1), 0); return [i(5), i(3), i(1)] } function RO(t, e, n) { const i = Db(t, 1, .5); let r; for (e + n > 1 && (r = 1 / (e + n), e *= r, n *= r), r = 0; r < 3; r++)i[r] *= 1 - e - n, i[r] += e; return i } function LO(t, e, n, i, r) { return t === r ? (e - n) / i + (e < n ? 6 : 0) : e === r ? (n - t) / i + 2 : (t - e) / i + 4 } function Ep(t) { const n = t.r / 255, i = t.g / 255, r = t.b / 255, s = Math.max(n, i, r), o = Math.min(n, i, r), a = (s + o) / 2; let l, c, u; return s !== o && (u = s - o, c = a > .5 ? u / (2 - s - o) : u / (s + o), l = LO(n, i, r, u, s), l = l * 60 + .5), [l | 0, c || 0, a] } function Dp(t, e, n, i) { return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, n, i)).map(xi) } function Op(t, e, n) { return Dp(Db, t, e, n) } function jO(t, e, n) { return Dp(RO, t, e, n) } function AO(t, e, n) { return Dp(OO, t, e, n) } function Ob(t) { return (t % 360 + 360) % 360 } function NO(t) { const e = DO.exec(t); let n = 255, i; if (!e) return; e[5] !== i && (n = e[6] ? js(+e[5]) : xi(+e[5])); const r = Ob(+e[2]), s = +e[3] / 100, o = +e[4] / 100; return e[1] === "hwb" ? i = jO(r, s, o) : e[1] === "hsv" ? i = AO(r, s, o) : i = Op(r, s, o), { r: i[0], g: i[1], b: i[2], a: n } } function FO(t, e) { var n = Ep(t); n[0] = Ob(n[0] + e), n = Op(n), t.r = n[0], t.g = n[1], t.b = n[2] } function IO(t) { if (!t) return; const e = Ep(t), n = e[0], i = Gy(e[1]), r = Gy(e[2]); return t.a < 255 ? `hsla(${n}, ${i}%, ${r}%, ${Tn(t.a)})` : `hsl(${n}, ${i}%, ${r}%)` } const Qy = { x: "dark", Z: "light", Y: "re", X: "blu", W: "gr", V: "medium", U: "slate", A: "ee", T: "ol", S: "or", B: "ra", C: "lateg", D: "ights", R: "in", Q: "turquois", E: "hi", P: "ro", O: "al", N: "le", M: "de", L: "yello", F: "en", K: "ch", G: "arks", H: "ea", I: "ightg", J: "wh" }, qy = { OiceXe: "f0f8ff", antiquewEte: "faebd7", aqua: "ffff", aquamarRe: "7fffd4", azuY: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "0", blanKedOmond: "ffebcd", Xe: "ff", XeviTet: "8a2be2", bPwn: "a52a2a", burlywood: "deb887", caMtXe: "5f9ea0", KartYuse: "7fff00", KocTate: "d2691e", cSO: "ff7f50", cSnflowerXe: "6495ed", cSnsilk: "fff8dc", crimson: "dc143c", cyan: "ffff", xXe: "8b", xcyan: "8b8b", xgTMnPd: "b8860b", xWay: "a9a9a9", xgYF: "6400", xgYy: "a9a9a9", xkhaki: "bdb76b", xmagFta: "8b008b", xTivegYF: "556b2f", xSange: "ff8c00", xScEd: "9932cc", xYd: "8b0000", xsOmon: "e9967a", xsHgYF: "8fbc8f", xUXe: "483d8b", xUWay: "2f4f4f", xUgYy: "2f4f4f", xQe: "ced1", xviTet: "9400d3", dAppRk: "ff1493", dApskyXe: "bfff", dimWay: "696969", dimgYy: "696969", dodgerXe: "1e90ff", fiYbrick: "b22222", flSOwEte: "fffaf0", foYstWAn: "228b22", fuKsia: "ff00ff", gaRsbSo: "dcdcdc", ghostwEte: "f8f8ff", gTd: "ffd700", gTMnPd: "daa520", Way: "808080", gYF: "8000", gYFLw: "adff2f", gYy: "808080", honeyMw: "f0fff0", hotpRk: "ff69b4", RdianYd: "cd5c5c", Rdigo: "4b0082", ivSy: "fffff0", khaki: "f0e68c", lavFMr: "e6e6fa", lavFMrXsh: "fff0f5", lawngYF: "7cfc00", NmoncEffon: "fffacd", ZXe: "add8e6", ZcSO: "f08080", Zcyan: "e0ffff", ZgTMnPdLw: "fafad2", ZWay: "d3d3d3", ZgYF: "90ee90", ZgYy: "d3d3d3", ZpRk: "ffb6c1", ZsOmon: "ffa07a", ZsHgYF: "20b2aa", ZskyXe: "87cefa", ZUWay: "778899", ZUgYy: "778899", ZstAlXe: "b0c4de", ZLw: "ffffe0", lime: "ff00", limegYF: "32cd32", lRF: "faf0e6", magFta: "ff00ff", maPon: "800000", VaquamarRe: "66cdaa", VXe: "cd", VScEd: "ba55d3", VpurpN: "9370db", VsHgYF: "3cb371", VUXe: "7b68ee", VsprRggYF: "fa9a", VQe: "48d1cc", VviTetYd: "c71585", midnightXe: "191970", mRtcYam: "f5fffa", mistyPse: "ffe4e1", moccasR: "ffe4b5", navajowEte: "ffdead", navy: "80", Tdlace: "fdf5e6", Tive: "808000", TivedBb: "6b8e23", Sange: "ffa500", SangeYd: "ff4500", ScEd: "da70d6", pOegTMnPd: "eee8aa", pOegYF: "98fb98", pOeQe: "afeeee", pOeviTetYd: "db7093", papayawEp: "ffefd5", pHKpuff: "ffdab9", peru: "cd853f", pRk: "ffc0cb", plum: "dda0dd", powMrXe: "b0e0e6", purpN: "800080", YbeccapurpN: "663399", Yd: "ff0000", Psybrown: "bc8f8f", PyOXe: "4169e1", saddNbPwn: "8b4513", sOmon: "fa8072", sandybPwn: "f4a460", sHgYF: "2e8b57", sHshell: "fff5ee", siFna: "a0522d", silver: "c0c0c0", skyXe: "87ceeb", UXe: "6a5acd", UWay: "708090", UgYy: "708090", snow: "fffafa", sprRggYF: "ff7f", stAlXe: "4682b4", tan: "d2b48c", teO: "8080", tEstN: "d8bfd8", tomato: "ff6347", Qe: "40e0d0", viTet: "ee82ee", JHt: "f5deb3", wEte: "ffffff", wEtesmoke: "f5f5f5", Lw: "ffff00", LwgYF: "9acd32" }; function VO() { const t = {}, e = Object.keys(qy), n = Object.keys(Qy); let i, r, s, o, a; for (i = 0; i < e.length; i++) { for (o = a = e[i], r = 0; r < n.length; r++)s = n[r], a = a.replace(s, Qy[s]); s = parseInt(qy[o], 16), t[a] = [s >> 16 & 255, s >> 8 & 255, s & 255] } return t } let za; function zO(t) { za || (za = VO(), za.transparent = [0, 0, 0, 0]); const e = za[t.toLowerCase()]; return e && { r: e[0], g: e[1], b: e[2], a: e.length === 4 ? e[3] : 255 } } const BO = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/; function HO(t) { const e = BO.exec(t); let n = 255, i, r, s; if (e) { if (e[7] !== i) { const o = +e[7]; n = e[8] ? js(o) : ii(o * 255, 0, 255) } return i = +e[1], r = +e[3], s = +e[5], i = 255 & (e[2] ? js(i) : ii(i, 0, 255)), r = 255 & (e[4] ? js(r) : ii(r, 0, 255)), s = 255 & (e[6] ? js(s) : ii(s, 0, 255)), { r: i, g: r, b: s, a: n } } } function WO(t) { return t && (t.a < 255 ? `rgba(${t.r}, ${t.g}, ${t.b}, ${Tn(t.a)})` : `rgb(${t.r}, ${t.g}, ${t.b})`) } const td = t => t <= .0031308 ? t * 12.92 : Math.pow(t, 1 / 2.4) * 1.055 - .055, vr = t => t <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4); function $O(t, e, n) { const i = vr(Tn(t.r)), r = vr(Tn(t.g)), s = vr(Tn(t.b)); return { r: xi(td(i + n * (vr(Tn(e.r)) - i))), g: xi(td(r + n * (vr(Tn(e.g)) - r))), b: xi(td(s + n * (vr(Tn(e.b)) - s))), a: t.a + n * (e.a - t.a) } } function Ba(t, e, n) { if (t) { let i = Ep(t); i[e] = Math.max(0, Math.min(i[e] + i[e] * n, e === 0 ? 360 : 1)), i = Op(i), t.r = i[0], t.g = i[1], t.b = i[2] } } function Rb(t, e) { return t && Object.assign(e || {}, t) } function Zy(t) { var e = { r: 0, g: 0, b: 0, a: 255 }; return Array.isArray(t) ? t.length >= 3 && (e = { r: t[0], g: t[1], b: t[2], a: 255 }, t.length > 3 && (e.a = xi(t[3]))) : (e = Rb(t, { r: 0, g: 0, b: 0, a: 1 }), e.a = xi(e.a)), e } function UO(t) { return t.charAt(0) === "r" ? HO(t) : NO(t) } class Ao { constructor(e) { if (e instanceof Ao) return e; const n = typeof e; let i; n === "object" ? i = Zy(e) : n === "string" && (i = MO(e) || zO(e) || UO(e)), this._rgb = i, this._valid = !!i } get valid() { return this._valid } get rgb() { var e = Rb(this._rgb); return e && (e.a = Tn(e.a)), e } set rgb(e) { this._rgb = Zy(e) } rgbString() { return this._valid ? WO(this._rgb) : void 0 } hexString() { return this._valid ? EO(this._rgb) : void 0 } hslString() { return this._valid ? IO(this._rgb) : void 0 } mix(e, n) { if (e) { const i = this.rgb, r = e.rgb; let s; const o = n === s ? .5 : n, a = 2 * o - 1, l = i.a - r.a, c = ((a * l === -1 ? a : (a + l) / (1 + a * l)) + 1) / 2; s = 1 - c, i.r = 255 & c * i.r + s * r.r + .5, i.g = 255 & c * i.g + s * r.g + .5, i.b = 255 & c * i.b + s * r.b + .5, i.a = o * i.a + (1 - o) * r.a, this.rgb = i } return this } interpolate(e, n) { return e && (this._rgb = $O(this._rgb, e._rgb, n)), this } clone() { return new Ao(this.rgb) } alpha(e) { return this._rgb.a = xi(e), this } clearer(e) { const n = this._rgb; return n.a *= 1 - e, this } greyscale() { const e = this._rgb, n = ra(e.r * .3 + e.g * .59 + e.b * .11); return e.r = e.g = e.b = n, this } opaquer(e) { const n = this._rgb; return n.a *= 1 + e, this } negate() { const e = this._rgb; return e.r = 255 - e.r, e.g = 255 - e.g, e.b = 255 - e.b, this } lighten(e) { return Ba(this._rgb, 2, e), this } darken(e) { return Ba(this._rgb, 2, -e), this } saturate(e) { return Ba(this._rgb, 1, e), this } desaturate(e) { return Ba(this._rgb, 1, -e), this } rotate(e) { return FO(this._rgb, e), this } }/*!
 * Chart.js v4.2.1
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */function _n() { } const YO = (() => { let t = 0; return () => t++ })(); function te(t) { return t === null || typeof t > "u" } function me(t) { if (Array.isArray && Array.isArray(t)) return !0; const e = Object.prototype.toString.call(t); return e.slice(0, 7) === "[object" && e.slice(-6) === "Array]" } function ne(t) { return t !== null && Object.prototype.toString.call(t) === "[object Object]" } function Oe(t) { return (typeof t == "number" || t instanceof Number) && isFinite(+t) } function Pt(t, e) { return Oe(t) ? t : e } function Q(t, e) { return typeof t > "u" ? e : t } const KO = (t, e) => typeof t == "string" && t.endsWith("%") ? parseFloat(t) / 100 : +t / e, Lb = (t, e) => typeof t == "string" && t.endsWith("%") ? parseFloat(t) / 100 * e : +t; function de(t, e, n) { if (t && typeof t.call == "function") return t.apply(n, e) } function ce(t, e, n, i) { let r, s, o; if (me(t)) if (s = t.length, i) for (r = s - 1; r >= 0; r--)e.call(n, t[r], r); else for (r = 0; r < s; r++)e.call(n, t[r], r); else if (ne(t)) for (o = Object.keys(t), s = o.length, r = 0; r < s; r++)e.call(n, t[o[r]], o[r]) } function ac(t, e) { let n, i, r, s; if (!t || !e || t.length !== e.length) return !1; for (n = 0, i = t.length; n < i; ++n)if (r = t[n], s = e[n], r.datasetIndex !== s.datasetIndex || r.index !== s.index) return !1; return !0 } function lc(t) { if (me(t)) return t.map(lc); if (ne(t)) { const e = Object.create(null), n = Object.keys(t), i = n.length; let r = 0; for (; r < i; ++r)e[n[r]] = lc(t[n[r]]); return e } return t } function jb(t) { return ["__proto__", "prototype", "constructor"].indexOf(t) === -1 } function XO(t, e, n, i) { if (!jb(t)) return; const r = e[t], s = n[t]; ne(r) && ne(s) ? yn(r, s, i) : e[t] = lc(s) } function yn(t, e, n) { const i = me(e) ? e : [e], r = i.length; if (!ne(t)) return t; n = n || {}; const s = n.merger || XO; let o; for (let a = 0; a < r; ++a) { if (o = i[a], !ne(o)) continue; const l = Object.keys(o); for (let c = 0, u = l.length; c < u; ++c)s(l[c], t, o, n) } return t } function to(t, e) { return yn(t, e, { merger: GO }) } function GO(t, e, n) { if (!jb(t)) return; const i = e[t], r = n[t]; ne(i) && ne(r) ? to(i, r) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = lc(r)) } const Jy = { "": t => t, x: t => t.x, y: t => t.y }; function QO(t) { const e = t.split("."), n = []; let i = ""; for (const r of e) i += r, i.endsWith("\\") ? i = i.slice(0, -1) + "." : (n.push(i), i = ""); return n } function qO(t) { const e = QO(t); return n => { for (const i of e) { if (i === "") break; n = n && n[i] } return n } } function ki(t, e) { return (Jy[e] || (Jy[e] = qO(e)))(t) } function Rp(t) { return t.charAt(0).toUpperCase() + t.slice(1) } const Wt = t => typeof t < "u", Pi = t => typeof t == "function", e0 = (t, e) => { if (t.size !== e.size) return !1; for (const n of t) if (!e.has(n)) return !1; return !0 }; function ZO(t) { return t.type === "mouseup" || t.type === "click" || t.type === "contextmenu" } const we = Math.PI, ye = 2 * we, JO = ye + we, cc = Number.POSITIVE_INFINITY, e5 = we / 180, Re = we / 2, ji = we / 4, t0 = we * 2 / 3, ri = Math.log10, gn = Math.sign; function no(t, e, n) { return Math.abs(t - e) < n } function n0(t) { const e = Math.round(t); t = no(t, e, t / 1e3) ? e : t; const n = Math.pow(10, Math.floor(ri(t))), i = t / n; return (i <= 1 ? 1 : i <= 2 ? 2 : i <= 5 ? 5 : 10) * n } function t5(t) { const e = [], n = Math.sqrt(t); let i; for (i = 1; i < n; i++)t % i === 0 && (e.push(i), e.push(t / i)); return n === (n | 0) && e.push(n), e.sort((r, s) => r - s).pop(), e } function ts(t) { return !isNaN(parseFloat(t)) && isFinite(t) } function n5(t, e) { const n = Math.round(t); return n - e <= t && n + e >= t } function Ab(t, e, n) { let i, r, s; for (i = 0, r = t.length; i < r; i++)s = t[i][n], isNaN(s) || (e.min = Math.min(e.min, s), e.max = Math.max(e.max, s)) } function Qt(t) { return t * (we / 180) } function Lp(t) { return t * (180 / we) } function i0(t) { if (!Oe(t)) return; let e = 1, n = 0; for (; Math.round(t * e) / e !== t;)e *= 10, n++; return n } function Nb(t, e) { const n = e.x - t.x, i = e.y - t.y, r = Math.sqrt(n * n + i * i); let s = Math.atan2(i, n); return s < -.5 * we && (s += ye), { angle: s, distance: r } } function If(t, e) { return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)) } function i5(t, e) { return (t - e + JO) % ye - we } function Mt(t) { return (t % ye + ye) % ye } function No(t, e, n, i) { const r = Mt(t), s = Mt(e), o = Mt(n), a = Mt(s - r), l = Mt(o - r), c = Mt(r - s), u = Mt(r - o); return r === s || r === o || i && s === o || a > l && c < u } function Xe(t, e, n) { return Math.max(e, Math.min(n, t)) } function r5(t) { return Xe(t, -32768, 32767) } function Rn(t, e, n, i = 1e-6) { return t >= Math.min(e, n) - i && t <= Math.max(e, n) + i } function jp(t, e, n) { n = n || (o => t[o] < e); let i = t.length - 1, r = 0, s; for (; i - r > 1;)s = r + i >> 1, n(s) ? r = s : i = s; return { lo: r, hi: i } } const Ln = (t, e, n, i) => jp(t, n, i ? r => { const s = t[r][e]; return s < n || s === n && t[r + 1][e] === n } : r => t[r][e] < n), s5 = (t, e, n) => jp(t, n, i => t[i][e] >= n); function o5(t, e, n) { let i = 0, r = t.length; for (; i < r && t[i] < e;)i++; for (; r > i && t[r - 1] > n;)r--; return i > 0 || r < t.length ? t.slice(i, r) : t } const Fb = ["push", "pop", "shift", "splice", "unshift"]; function a5(t, e) { if (t._chartjs) { t._chartjs.listeners.push(e); return } Object.defineProperty(t, "_chartjs", { configurable: !0, enumerable: !1, value: { listeners: [e] } }), Fb.forEach(n => { const i = "_onData" + Rp(n), r = t[n]; Object.defineProperty(t, n, { configurable: !0, enumerable: !1, value(...s) { const o = r.apply(this, s); return t._chartjs.listeners.forEach(a => { typeof a[i] == "function" && a[i](...s) }), o } }) }) } function r0(t, e) { const n = t._chartjs; if (!n) return; const i = n.listeners, r = i.indexOf(e); r !== -1 && i.splice(r, 1), !(i.length > 0) && (Fb.forEach(s => { delete t[s] }), delete t._chartjs) } function Ib(t) { const e = new Set; let n, i; for (n = 0, i = t.length; n < i; ++n)e.add(t[n]); return e.size === i ? t : Array.from(e) } const Vb = function () { return typeof window > "u" ? function (t) { return t() } : window.requestAnimationFrame }(); function zb(t, e) { let n = [], i = !1; return function (...r) { n = r, i || (i = !0, Vb.call(window, () => { i = !1, t.apply(e, n) })) } } function l5(t, e) { let n; return function (...i) { return e ? (clearTimeout(n), n = setTimeout(t, e, i)) : t.apply(this, i), e } } const Ap = t => t === "start" ? "left" : t === "end" ? "right" : "center", rt = (t, e, n) => t === "start" ? e : t === "end" ? n : (e + n) / 2, c5 = (t, e, n, i) => t === (i ? "left" : "right") ? n : t === "center" ? (e + n) / 2 : e; function Bb(t, e, n) { const i = e.length; let r = 0, s = i; if (t._sorted) { const { iScale: o, _parsed: a } = t, l = o.axis, { min: c, max: u, minDefined: d, maxDefined: f } = o.getUserBounds(); d && (r = Xe(Math.min(Ln(a, o.axis, c).lo, n ? i : Ln(e, l, o.getPixelForValue(c)).lo), 0, i - 1)), f ? s = Xe(Math.max(Ln(a, o.axis, u, !0).hi + 1, n ? 0 : Ln(e, l, o.getPixelForValue(u), !0).hi + 1), r, i) - r : s = i - r } return { start: r, count: s } } function Hb(t) { const { xScale: e, yScale: n, _scaleRanges: i } = t, r = { xmin: e.min, xmax: e.max, ymin: n.min, ymax: n.max }; if (!i) return t._scaleRanges = r, !0; const s = i.xmin !== e.min || i.xmax !== e.max || i.ymin !== n.min || i.ymax !== n.max; return Object.assign(i, r), s } const Ha = t => t === 0 || t === 1, s0 = (t, e, n) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * ye / n)), o0 = (t, e, n) => Math.pow(2, -10 * t) * Math.sin((t - e) * ye / n) + 1, io = { linear: t => t, easeInQuad: t => t * t, easeOutQuad: t => -t * (t - 2), easeInOutQuad: t => (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1), easeInCubic: t => t * t * t, easeOutCubic: t => (t -= 1) * t * t + 1, easeInOutCubic: t => (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2), easeInQuart: t => t * t * t * t, easeOutQuart: t => -((t -= 1) * t * t * t - 1), easeInOutQuart: t => (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2), easeInQuint: t => t * t * t * t * t, easeOutQuint: t => (t -= 1) * t * t * t * t + 1, easeInOutQuint: t => (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2), easeInSine: t => -Math.cos(t * Re) + 1, easeOutSine: t => Math.sin(t * Re), easeInOutSine: t => -.5 * (Math.cos(we * t) - 1), easeInExpo: t => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)), easeOutExpo: t => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1, easeInOutExpo: t => Ha(t) ? t : t < .5 ? .5 * Math.pow(2, 10 * (t * 2 - 1)) : .5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2), easeInCirc: t => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1), easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t), easeInOutCirc: t => (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1), easeInElastic: t => Ha(t) ? t : s0(t, .075, .3), easeOutElastic: t => Ha(t) ? t : o0(t, .075, .3), easeInOutElastic(t) { return Ha(t) ? t : t < .5 ? .5 * s0(t * 2, .1125, .45) : .5 + .5 * o0(t * 2 - 1, .1125, .45) }, easeInBack(t) { return t * t * ((1.70158 + 1) * t - 1.70158) }, easeOutBack(t) { return (t -= 1) * t * ((1.70158 + 1) * t + 1.70158) + 1 }, easeInOutBack(t) { let e = 1.70158; return (t /= .5) < 1 ? .5 * (t * t * (((e *= 1.525) + 1) * t - e)) : .5 * ((t -= 2) * t * (((e *= 1.525) + 1) * t + e) + 2) }, easeInBounce: t => 1 - io.easeOutBounce(1 - t), easeOutBounce(t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375 }, easeInOutBounce: t => t < .5 ? io.easeInBounce(t * 2) * .5 : io.easeOutBounce(t * 2 - 1) * .5 + .5 }; function Wb(t) { if (t && typeof t == "object") { const e = t.toString(); return e === "[object CanvasPattern]" || e === "[object CanvasGradient]" } return !1 } function a0(t) { return Wb(t) ? t : new Ao(t) } function nd(t) { return Wb(t) ? t : new Ao(t).saturate(.5).darken(.1).hexString() } const u5 = ["x", "y", "borderWidth", "radius", "tension"], d5 = ["color", "borderColor", "backgroundColor"]; function f5(t) { t.set("animation", { delay: void 0, duration: 1e3, easing: "easeOutQuart", fn: void 0, from: void 0, loop: void 0, to: void 0, type: void 0 }), t.describe("animation", { _fallback: !1, _indexable: !1, _scriptable: e => e !== "onProgress" && e !== "onComplete" && e !== "fn" }), t.set("animations", { colors: { type: "color", properties: d5 }, numbers: { type: "number", properties: u5 } }), t.describe("animations", { _fallback: "animation" }), t.set("transitions", { active: { animation: { duration: 400 } }, resize: { animation: { duration: 0 } }, show: { animations: { colors: { from: "transparent" }, visible: { type: "boolean", duration: 0 } } }, hide: { animations: { colors: { to: "transparent" }, visible: { type: "boolean", easing: "linear", fn: e => e | 0 } } } }) } function h5(t) { t.set("layout", { autoPadding: !0, padding: { top: 0, right: 0, bottom: 0, left: 0 } }) } const l0 = new Map; function p5(t, e) { e = e || {}; const n = t + JSON.stringify(e); let i = l0.get(n); return i || (i = new Intl.NumberFormat(t, e), l0.set(n, i)), i } function sa(t, e, n) { return p5(e, n).format(t) } const $b = { values(t) { return me(t) ? t : "" + t }, numeric(t, e, n) { if (t === 0) return "0"; const i = this.chart.options.locale; let r, s = t; if (n.length > 1) { const c = Math.max(Math.abs(n[0].value), Math.abs(n[n.length - 1].value)); (c < 1e-4 || c > 1e15) && (r = "scientific"), s = m5(t, n) } const o = ri(Math.abs(s)), a = Math.max(Math.min(-1 * Math.floor(o), 20), 0), l = { notation: r, minimumFractionDigits: a, maximumFractionDigits: a }; return Object.assign(l, this.options.ticks.format), sa(t, i, l) }, logarithmic(t, e, n) { if (t === 0) return "0"; const i = n[e].significand || t / Math.pow(10, Math.floor(ri(t))); return [1, 2, 3, 5, 10, 15].includes(i) || e > .8 * n.length ? $b.numeric.call(this, t, e, n) : "" } }; function m5(t, e) { let n = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value; return Math.abs(n) >= 1 && t !== Math.floor(t) && (n = t - Math.floor(t)), n } var qc = { formatters: $b }; function g5(t) { t.set("scale", { display: !0, offset: !1, reverse: !1, beginAtZero: !1, bounds: "ticks", grace: 0, grid: { display: !0, lineWidth: 1, drawOnChartArea: !0, drawTicks: !0, tickLength: 8, tickWidth: (e, n) => n.lineWidth, tickColor: (e, n) => n.color, offset: !1 }, border: { display: !0, dash: [], dashOffset: 0, width: 1 }, title: { display: !1, text: "", padding: { top: 4, bottom: 4 } }, ticks: { minRotation: 0, maxRotation: 50, mirror: !1, textStrokeWidth: 0, textStrokeColor: "", padding: 3, display: !0, autoSkip: !0, autoSkipPadding: 3, labelOffset: 0, callback: qc.formatters.values, minor: {}, major: {}, align: "center", crossAlign: "near", showLabelBackdrop: !1, backdropColor: "rgba(255, 255, 255, 0.75)", backdropPadding: 2 } }), t.route("scale.ticks", "color", "", "color"), t.route("scale.grid", "color", "", "borderColor"), t.route("scale.border", "color", "", "borderColor"), t.route("scale.title", "color", "", "color"), t.describe("scale", { _fallback: !1, _scriptable: e => !e.startsWith("before") && !e.startsWith("after") && e !== "callback" && e !== "parser", _indexable: e => e !== "borderDash" && e !== "tickBorderDash" && e !== "dash" }), t.describe("scales", { _fallback: "scale" }), t.describe("scale.ticks", { _scriptable: e => e !== "backdropPadding" && e !== "callback", _indexable: e => e !== "backdropPadding" }) } const lr = Object.create(null), Vf = Object.create(null); function ro(t, e) { if (!e) return t; const n = e.split("."); for (let i = 0, r = n.length; i < r; ++i) { const s = n[i]; t = t[s] || (t[s] = Object.create(null)) } return t } function id(t, e, n) { return typeof e == "string" ? yn(ro(t, e), n) : yn(ro(t, ""), e) } class y5 { constructor(e, n) { this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = i => i.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"], this.font = { family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", size: 12, style: "normal", lineHeight: 1.2, weight: null }, this.hover = {}, this.hoverBackgroundColor = (i, r) => nd(r.backgroundColor), this.hoverBorderColor = (i, r) => nd(r.borderColor), this.hoverColor = (i, r) => nd(r.color), this.indexAxis = "x", this.interaction = { mode: "nearest", intersect: !0, includeInvisible: !1 }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(e), this.apply(n) } set(e, n) { return id(this, e, n) } get(e) { return ro(this, e) } describe(e, n) { return id(Vf, e, n) } override(e, n) { return id(lr, e, n) } route(e, n, i, r) { const s = ro(this, e), o = ro(this, i), a = "_" + n; Object.defineProperties(s, { [a]: { value: s[n], writable: !0 }, [n]: { enumerable: !0, get() { const l = this[a], c = o[r]; return ne(l) ? Object.assign({}, c, l) : Q(l, c) }, set(l) { this[a] = l } } }) } apply(e) { e.forEach(n => n(this)) } } var Le = new y5({ _scriptable: t => !t.startsWith("on"), _indexable: t => t !== "events", hover: { _fallback: "interaction" }, interaction: { _scriptable: !1, _indexable: !1 } }, [f5, h5, g5]); function v5(t) { return !t || te(t.size) || te(t.family) ? null : (t.style ? t.style + " " : "") + (t.weight ? t.weight + " " : "") + t.size + "px " + t.family } function uc(t, e, n, i, r) { let s = e[r]; return s || (s = e[r] = t.measureText(r).width, n.push(r)), s > i && (i = s), i } function x5(t, e, n, i) { i = i || {}; let r = i.data = i.data || {}, s = i.garbageCollect = i.garbageCollect || []; i.font !== e && (r = i.data = {}, s = i.garbageCollect = [], i.font = e), t.save(), t.font = e; let o = 0; const a = n.length; let l, c, u, d, f; for (l = 0; l < a; l++)if (d = n[l], d != null && me(d) !== !0) o = uc(t, r, s, o, d); else if (me(d)) for (c = 0, u = d.length; c < u; c++)f = d[c], f != null && !me(f) && (o = uc(t, r, s, o, f)); t.restore(); const h = s.length / 2; if (h > n.length) { for (l = 0; l < h; l++)delete r[s[l]]; s.splice(0, h) } return o } function Ai(t, e, n) { const i = t.currentDevicePixelRatio, r = n !== 0 ? Math.max(n / 2, .5) : 0; return Math.round((e - r) * i) / i + r } function c0(t, e) { e = e || t.getContext("2d"), e.save(), e.resetTransform(), e.clearRect(0, 0, t.width, t.height), e.restore() } function zf(t, e, n, i) { Ub(t, e, n, i, null) } function Ub(t, e, n, i, r) { let s, o, a, l, c, u, d, f; const h = e.pointStyle, m = e.rotation, p = e.radius; let x = (m || 0) * e5; if (h && typeof h == "object" && (s = h.toString(), s === "[object HTMLImageElement]" || s === "[object HTMLCanvasElement]")) { t.save(), t.translate(n, i), t.rotate(x), t.drawImage(h, -h.width / 2, -h.height / 2, h.width, h.height), t.restore(); return } if (!(isNaN(p) || p <= 0)) { switch (t.beginPath(), h) { default: r ? t.ellipse(n, i, r / 2, p, 0, 0, ye) : t.arc(n, i, p, 0, ye), t.closePath(); break; case "triangle": u = r ? r / 2 : p, t.moveTo(n + Math.sin(x) * u, i - Math.cos(x) * p), x += t0, t.lineTo(n + Math.sin(x) * u, i - Math.cos(x) * p), x += t0, t.lineTo(n + Math.sin(x) * u, i - Math.cos(x) * p), t.closePath(); break; case "rectRounded": c = p * .516, l = p - c, o = Math.cos(x + ji) * l, d = Math.cos(x + ji) * (r ? r / 2 - c : l), a = Math.sin(x + ji) * l, f = Math.sin(x + ji) * (r ? r / 2 - c : l), t.arc(n - d, i - a, c, x - we, x - Re), t.arc(n + f, i - o, c, x - Re, x), t.arc(n + d, i + a, c, x, x + Re), t.arc(n - f, i + o, c, x + Re, x + we), t.closePath(); break; case "rect": if (!m) { l = Math.SQRT1_2 * p, u = r ? r / 2 : l, t.rect(n - u, i - l, 2 * u, 2 * l); break } x += ji; case "rectRot": d = Math.cos(x) * (r ? r / 2 : p), o = Math.cos(x) * p, a = Math.sin(x) * p, f = Math.sin(x) * (r ? r / 2 : p), t.moveTo(n - d, i - a), t.lineTo(n + f, i - o), t.lineTo(n + d, i + a), t.lineTo(n - f, i + o), t.closePath(); break; case "crossRot": x += ji; case "cross": d = Math.cos(x) * (r ? r / 2 : p), o = Math.cos(x) * p, a = Math.sin(x) * p, f = Math.sin(x) * (r ? r / 2 : p), t.moveTo(n - d, i - a), t.lineTo(n + d, i + a), t.moveTo(n + f, i - o), t.lineTo(n - f, i + o); break; case "star": d = Math.cos(x) * (r ? r / 2 : p), o = Math.cos(x) * p, a = Math.sin(x) * p, f = Math.sin(x) * (r ? r / 2 : p), t.moveTo(n - d, i - a), t.lineTo(n + d, i + a), t.moveTo(n + f, i - o), t.lineTo(n - f, i + o), x += ji, d = Math.cos(x) * (r ? r / 2 : p), o = Math.cos(x) * p, a = Math.sin(x) * p, f = Math.sin(x) * (r ? r / 2 : p), t.moveTo(n - d, i - a), t.lineTo(n + d, i + a), t.moveTo(n + f, i - o), t.lineTo(n - f, i + o); break; case "line": o = r ? r / 2 : Math.cos(x) * p, a = Math.sin(x) * p, t.moveTo(n - o, i - a), t.lineTo(n + o, i + a); break; case "dash": t.moveTo(n, i), t.lineTo(n + Math.cos(x) * (r ? r / 2 : p), i + Math.sin(x) * p); break; case !1: t.closePath(); break }t.fill(), e.borderWidth > 0 && t.stroke() } } function Fo(t, e, n) { return n = n || .5, !e || t && t.x > e.left - n && t.x < e.right + n && t.y > e.top - n && t.y < e.bottom + n } function Zc(t, e) { t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip() } function Jc(t) { t.restore() } function w5(t, e, n, i, r) { if (!e) return t.lineTo(n.x, n.y); if (r === "middle") { const s = (e.x + n.x) / 2; t.lineTo(s, e.y), t.lineTo(s, n.y) } else r === "after" != !!i ? t.lineTo(e.x, n.y) : t.lineTo(n.x, e.y); t.lineTo(n.x, n.y) } function b5(t, e, n, i) { if (!e) return t.lineTo(n.x, n.y); t.bezierCurveTo(i ? e.cp1x : e.cp2x, i ? e.cp1y : e.cp2y, i ? n.cp2x : n.cp1x, i ? n.cp2y : n.cp1y, n.x, n.y) } function cr(t, e, n, i, r, s = {}) { const o = me(e) ? e : [e], a = s.strokeWidth > 0 && s.strokeColor !== ""; let l, c; for (t.save(), t.font = r.string, _5(t, s), l = 0; l < o.length; ++l)c = o[l], s.backdrop && k5(t, s.backdrop), a && (s.strokeColor && (t.strokeStyle = s.strokeColor), te(s.strokeWidth) || (t.lineWidth = s.strokeWidth), t.strokeText(c, n, i, s.maxWidth)), t.fillText(c, n, i, s.maxWidth), S5(t, n, i, c, s), i += r.lineHeight; t.restore() } function _5(t, e) { e.translation && t.translate(e.translation[0], e.translation[1]), te(e.rotation) || t.rotate(e.rotation), e.color && (t.fillStyle = e.color), e.textAlign && (t.textAlign = e.textAlign), e.textBaseline && (t.textBaseline = e.textBaseline) } function S5(t, e, n, i, r) { if (r.strikethrough || r.underline) { const s = t.measureText(i), o = e - s.actualBoundingBoxLeft, a = e + s.actualBoundingBoxRight, l = n - s.actualBoundingBoxAscent, c = n + s.actualBoundingBoxDescent, u = r.strikethrough ? (l + c) / 2 : c; t.strokeStyle = t.fillStyle, t.beginPath(), t.lineWidth = r.decorationWidth || 2, t.moveTo(o, u), t.lineTo(a, u), t.stroke() } } function k5(t, e) { const n = t.fillStyle; t.fillStyle = e.color, t.fillRect(e.left, e.top, e.width, e.height), t.fillStyle = n } function Io(t, e) { const { x: n, y: i, w: r, h: s, radius: o } = e; t.arc(n + o.topLeft, i + o.topLeft, o.topLeft, -Re, we, !0), t.lineTo(n, i + s - o.bottomLeft), t.arc(n + o.bottomLeft, i + s - o.bottomLeft, o.bottomLeft, we, Re, !0), t.lineTo(n + r - o.bottomRight, i + s), t.arc(n + r - o.bottomRight, i + s - o.bottomRight, o.bottomRight, Re, 0, !0), t.lineTo(n + r, i + o.topRight), t.arc(n + r - o.topRight, i + o.topRight, o.topRight, 0, -Re, !0), t.lineTo(n + o.topLeft, i) } const P5 = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, C5 = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/; function M5(t, e) { const n = ("" + t).match(P5); if (!n || n[1] === "normal") return e * 1.2; switch (t = +n[2], n[3]) { case "px": return t; case "%": t /= 100; break }return e * t } const T5 = t => +t || 0; function Np(t, e) { const n = {}, i = ne(e), r = i ? Object.keys(e) : e, s = ne(t) ? i ? o => Q(t[o], t[e[o]]) : o => t[o] : () => t; for (const o of r) n[o] = T5(s(o)); return n } function Yb(t) { return Np(t, { top: "y", right: "x", bottom: "y", left: "x" }) } function Zi(t) { return Np(t, ["topLeft", "topRight", "bottomLeft", "bottomRight"]) } function Je(t) { const e = Yb(t); return e.width = e.left + e.right, e.height = e.top + e.bottom, e } function ze(t, e) { t = t || {}, e = e || Le.font; let n = Q(t.size, e.size); typeof n == "string" && (n = parseInt(n, 10)); let i = Q(t.style, e.style); i && !("" + i).match(C5) && (console.warn('Invalid font style specified: "' + i + '"'), i = void 0); const r = { family: Q(t.family, e.family), lineHeight: M5(Q(t.lineHeight, e.lineHeight), n), size: n, style: i, weight: Q(t.weight, e.weight), string: "" }; return r.string = v5(r), r } function pe(t, e, n, i) { let r = !0, s, o, a; for (s = 0, o = t.length; s < o; ++s)if (a = t[s], a !== void 0 && (e !== void 0 && typeof a == "function" && (a = a(e), r = !1), n !== void 0 && me(a) && (a = a[n % a.length], r = !1), a !== void 0)) return i && !r && (i.cacheable = !1), a } function E5(t, e, n) { const { min: i, max: r } = t, s = Lb(e, (r - i) / 2), o = (a, l) => n && a === 0 ? 0 : a + l; return { min: o(i, -Math.abs(s)), max: o(r, s) } } function Di(t, e) { return Object.assign(Object.create(t), e) } function Fp(t, e = [""], n = t, i, r = () => t[0]) { Wt(i) || (i = Qb("_fallback", t)); const s = { [Symbol.toStringTag]: "Object", _cacheable: !0, _scopes: t, _rootScopes: n, _fallback: i, _getTarget: r, override: o => Fp([o, ...t], e, n, i) }; return new Proxy(s, { deleteProperty(o, a) { return delete o[a], delete o._keys, delete t[0][a], !0 }, get(o, a) { return Xb(o, a, () => F5(a, e, t, o)) }, getOwnPropertyDescriptor(o, a) { return Reflect.getOwnPropertyDescriptor(o._scopes[0], a) }, getPrototypeOf() { return Reflect.getPrototypeOf(t[0]) }, has(o, a) { return d0(o).includes(a) }, ownKeys(o) { return d0(o) }, set(o, a, l) { const c = o._storage || (o._storage = r()); return o[a] = c[a] = l, delete o._keys, !0 } }) } function ns(t, e, n, i) { const r = { _cacheable: !1, _proxy: t, _context: e, _subProxy: n, _stack: new Set, _descriptors: Kb(t, i), setContext: s => ns(t, s, n, i), override: s => ns(t.override(s), e, n, i) }; return new Proxy(r, { deleteProperty(s, o) { return delete s[o], delete t[o], !0 }, get(s, o, a) { return Xb(s, o, () => O5(s, o, a)) }, getOwnPropertyDescriptor(s, o) { return s._descriptors.allKeys ? Reflect.has(t, o) ? { enumerable: !0, configurable: !0 } : void 0 : Reflect.getOwnPropertyDescriptor(t, o) }, getPrototypeOf() { return Reflect.getPrototypeOf(t) }, has(s, o) { return Reflect.has(t, o) }, ownKeys() { return Reflect.ownKeys(t) }, set(s, o, a) { return t[o] = a, delete s[o], !0 } }) } function Kb(t, e = { scriptable: !0, indexable: !0 }) { const { _scriptable: n = e.scriptable, _indexable: i = e.indexable, _allKeys: r = e.allKeys } = t; return { allKeys: r, scriptable: n, indexable: i, isScriptable: Pi(n) ? n : () => n, isIndexable: Pi(i) ? i : () => i } } const D5 = (t, e) => t ? t + Rp(e) : e, Ip = (t, e) => ne(e) && t !== "adapters" && (Object.getPrototypeOf(e) === null || e.constructor === Object); function Xb(t, e, n) { if (Object.prototype.hasOwnProperty.call(t, e)) return t[e]; const i = n(); return t[e] = i, i } function O5(t, e, n) { const { _proxy: i, _context: r, _subProxy: s, _descriptors: o } = t; let a = i[e]; return Pi(a) && o.isScriptable(e) && (a = R5(e, a, t, n)), me(a) && a.length && (a = L5(e, a, t, o.isIndexable)), Ip(e, a) && (a = ns(a, r, s && s[e], o)), a } function R5(t, e, n, i) { const { _proxy: r, _context: s, _subProxy: o, _stack: a } = n; if (a.has(t)) throw new Error("Recursion detected: " + Array.from(a).join("->") + "->" + t); return a.add(t), e = e(s, o || i), a.delete(t), Ip(t, e) && (e = Vp(r._scopes, r, t, e)), e } function L5(t, e, n, i) { const { _proxy: r, _context: s, _subProxy: o, _descriptors: a } = n; if (Wt(s.index) && i(t)) e = e[s.index % e.length]; else if (ne(e[0])) { const l = e, c = r._scopes.filter(u => u !== l); e = []; for (const u of l) { const d = Vp(c, r, t, u); e.push(ns(d, s, o && o[t], a)) } } return e } function Gb(t, e, n) { return Pi(t) ? t(e, n) : t } const j5 = (t, e) => t === !0 ? e : typeof t == "string" ? ki(e, t) : void 0; function A5(t, e, n, i, r) { for (const s of e) { const o = j5(n, s); if (o) { t.add(o); const a = Gb(o._fallback, n, r); if (Wt(a) && a !== n && a !== i) return a } else if (o === !1 && Wt(i) && n !== i) return null } return !1 } function Vp(t, e, n, i) { const r = e._rootScopes, s = Gb(e._fallback, n, i), o = [...t, ...r], a = new Set; a.add(i); let l = u0(a, o, n, s || n, i); return l === null || Wt(s) && s !== n && (l = u0(a, o, s, l, i), l === null) ? !1 : Fp(Array.from(a), [""], r, s, () => N5(e, n, i)) } function u0(t, e, n, i, r) { for (; n;)n = A5(t, e, n, i, r); return n } function N5(t, e, n) { const i = t._getTarget(); e in i || (i[e] = {}); const r = i[e]; return me(r) && ne(n) ? n : r || {} } function F5(t, e, n, i) { let r; for (const s of e) if (r = Qb(D5(s, t), n), Wt(r)) return Ip(t, r) ? Vp(n, i, t, r) : r } function Qb(t, e) { for (const n of e) { if (!n) continue; const i = n[t]; if (Wt(i)) return i } } function d0(t) { let e = t._keys; return e || (e = t._keys = I5(t._scopes)), e } function I5(t) { const e = new Set; for (const n of t) for (const i of Object.keys(n).filter(r => !r.startsWith("_"))) e.add(i); return Array.from(e) } function qb(t, e, n, i) { const { iScale: r } = t, { key: s = "r" } = this._parsing, o = new Array(i); let a, l, c, u; for (a = 0, l = i; a < l; ++a)c = a + n, u = e[c], o[a] = { r: r.parse(ki(u, s), c) }; return o } const V5 = Number.EPSILON || 1e-14, is = (t, e) => e < t.length && !t[e].skip && t[e], Zb = t => t === "x" ? "y" : "x"; function z5(t, e, n, i) { const r = t.skip ? e : t, s = e, o = n.skip ? e : n, a = If(s, r), l = If(o, s); let c = a / (a + l), u = l / (a + l); c = isNaN(c) ? 0 : c, u = isNaN(u) ? 0 : u; const d = i * c, f = i * u; return { previous: { x: s.x - d * (o.x - r.x), y: s.y - d * (o.y - r.y) }, next: { x: s.x + f * (o.x - r.x), y: s.y + f * (o.y - r.y) } } } function B5(t, e, n) { const i = t.length; let r, s, o, a, l, c = is(t, 0); for (let u = 0; u < i - 1; ++u)if (l = c, c = is(t, u + 1), !(!l || !c)) { if (no(e[u], 0, V5)) { n[u] = n[u + 1] = 0; continue } r = n[u] / e[u], s = n[u + 1] / e[u], a = Math.pow(r, 2) + Math.pow(s, 2), !(a <= 9) && (o = 3 / Math.sqrt(a), n[u] = r * o * e[u], n[u + 1] = s * o * e[u]) } } function H5(t, e, n = "x") { const i = Zb(n), r = t.length; let s, o, a, l = is(t, 0); for (let c = 0; c < r; ++c) { if (o = a, a = l, l = is(t, c + 1), !a) continue; const u = a[n], d = a[i]; o && (s = (u - o[n]) / 3, a[`cp1${n}`] = u - s, a[`cp1${i}`] = d - s * e[c]), l && (s = (l[n] - u) / 3, a[`cp2${n}`] = u + s, a[`cp2${i}`] = d + s * e[c]) } } function W5(t, e = "x") { const n = Zb(e), i = t.length, r = Array(i).fill(0), s = Array(i); let o, a, l, c = is(t, 0); for (o = 0; o < i; ++o)if (a = l, l = c, c = is(t, o + 1), !!l) { if (c) { const u = c[e] - l[e]; r[o] = u !== 0 ? (c[n] - l[n]) / u : 0 } s[o] = a ? c ? gn(r[o - 1]) !== gn(r[o]) ? 0 : (r[o - 1] + r[o]) / 2 : r[o - 1] : r[o] } B5(t, r, s), H5(t, s, e) } function Wa(t, e, n) { return Math.max(Math.min(t, n), e) } function $5(t, e) { let n, i, r, s, o, a = Fo(t[0], e); for (n = 0, i = t.length; n < i; ++n)o = s, s = a, a = n < i - 1 && Fo(t[n + 1], e), s && (r = t[n], o && (r.cp1x = Wa(r.cp1x, e.left, e.right), r.cp1y = Wa(r.cp1y, e.top, e.bottom)), a && (r.cp2x = Wa(r.cp2x, e.left, e.right), r.cp2y = Wa(r.cp2y, e.top, e.bottom))) } function U5(t, e, n, i, r) { let s, o, a, l; if (e.spanGaps && (t = t.filter(c => !c.skip)), e.cubicInterpolationMode === "monotone") W5(t, r); else { let c = i ? t[t.length - 1] : t[0]; for (s = 0, o = t.length; s < o; ++s)a = t[s], l = z5(c, a, t[Math.min(s + 1, o - (i ? 0 : 1)) % o], e.tension), a.cp1x = l.previous.x, a.cp1y = l.previous.y, a.cp2x = l.next.x, a.cp2y = l.next.y, c = a } e.capBezierPoints && $5(t, n) } function Jb() { return typeof window < "u" && typeof document < "u" } function zp(t) { let e = t.parentNode; return e && e.toString() === "[object ShadowRoot]" && (e = e.host), e } function dc(t, e, n) { let i; return typeof t == "string" ? (i = parseInt(t, 10), t.indexOf("%") !== -1 && (i = i / 100 * e.parentNode[n])) : i = t, i } const eu = t => t.ownerDocument.defaultView.getComputedStyle(t, null); function Y5(t, e) { return eu(t).getPropertyValue(e) } const K5 = ["top", "right", "bottom", "left"]; function Ji(t, e, n) { const i = {}; n = n ? "-" + n : ""; for (let r = 0; r < 4; r++) { const s = K5[r]; i[s] = parseFloat(t[e + "-" + s + n]) || 0 } return i.width = i.left + i.right, i.height = i.top + i.bottom, i } const X5 = (t, e, n) => (t > 0 || e > 0) && (!n || !n.shadowRoot); function G5(t, e) { const n = t.touches, i = n && n.length ? n[0] : t, { offsetX: r, offsetY: s } = i; let o = !1, a, l; if (X5(r, s, t.target)) a = r, l = s; else { const c = e.getBoundingClientRect(); a = i.clientX - c.left, l = i.clientY - c.top, o = !0 } return { x: a, y: l, box: o } } function Hi(t, e) { if ("native" in t) return t; const { canvas: n, currentDevicePixelRatio: i } = e, r = eu(n), s = r.boxSizing === "border-box", o = Ji(r, "padding"), a = Ji(r, "border", "width"), { x: l, y: c, box: u } = G5(t, n), d = o.left + (u && a.left), f = o.top + (u && a.top); let { width: h, height: m } = e; return s && (h -= o.width + a.width, m -= o.height + a.height), { x: Math.round((l - d) / h * n.width / i), y: Math.round((c - f) / m * n.height / i) } } function Q5(t, e, n) { let i, r; if (e === void 0 || n === void 0) { const s = zp(t); if (!s) e = t.clientWidth, n = t.clientHeight; else { const o = s.getBoundingClientRect(), a = eu(s), l = Ji(a, "border", "width"), c = Ji(a, "padding"); e = o.width - c.width - l.width, n = o.height - c.height - l.height, i = dc(a.maxWidth, s, "clientWidth"), r = dc(a.maxHeight, s, "clientHeight") } } return { width: e, height: n, maxWidth: i || cc, maxHeight: r || cc } } const $a = t => Math.round(t * 10) / 10; function q5(t, e, n, i) { const r = eu(t), s = Ji(r, "margin"), o = dc(r.maxWidth, t, "clientWidth") || cc, a = dc(r.maxHeight, t, "clientHeight") || cc, l = Q5(t, e, n); let { width: c, height: u } = l; if (r.boxSizing === "content-box") { const f = Ji(r, "border", "width"), h = Ji(r, "padding"); c -= h.width + f.width, u -= h.height + f.height } return c = Math.max(0, c - s.width), u = Math.max(0, i ? c / i : u - s.height), c = $a(Math.min(c, o, l.maxWidth)), u = $a(Math.min(u, a, l.maxHeight)), c && !u && (u = $a(c / 2)), (e !== void 0 || n !== void 0) && i && l.height && u > l.height && (u = l.height, c = $a(Math.floor(u * i))), { width: c, height: u } } function f0(t, e, n) { const i = e || 1, r = Math.floor(t.height * i), s = Math.floor(t.width * i); t.height = Math.floor(t.height), t.width = Math.floor(t.width); const o = t.canvas; return o.style && (n || !o.style.height && !o.style.width) && (o.style.height = `${t.height}px`, o.style.width = `${t.width}px`), t.currentDevicePixelRatio !== i || o.height !== r || o.width !== s ? (t.currentDevicePixelRatio = i, o.height = r, o.width = s, t.ctx.setTransform(i, 0, 0, i, 0, 0), !0) : !1 } const Z5 = function () { let t = !1; try { const e = { get passive() { return t = !0, !1 } }; window.addEventListener("test", null, e), window.removeEventListener("test", null, e) } catch { } return t }(); function h0(t, e) { const n = Y5(t, e), i = n && n.match(/^(\d+)(\.\d+)?px$/); return i ? +i[1] : void 0 } function Wi(t, e, n, i) { return { x: t.x + n * (e.x - t.x), y: t.y + n * (e.y - t.y) } } function J5(t, e, n, i) { return { x: t.x + n * (e.x - t.x), y: i === "middle" ? n < .5 ? t.y : e.y : i === "after" ? n < 1 ? t.y : e.y : n > 0 ? e.y : t.y } } function e3(t, e, n, i) { const r = { x: t.cp2x, y: t.cp2y }, s = { x: e.cp1x, y: e.cp1y }, o = Wi(t, r, n), a = Wi(r, s, n), l = Wi(s, e, n), c = Wi(o, a, n), u = Wi(a, l, n); return Wi(c, u, n) } const t3 = function (t, e) { return { x(n) { return t + t + e - n }, setWidth(n) { e = n }, textAlign(n) { return n === "center" ? n : n === "right" ? "left" : "right" }, xPlus(n, i) { return n - i }, leftForLtr(n, i) { return n - i } } }, n3 = function () { return { x(t) { return t }, setWidth(t) { }, textAlign(t) { return t }, xPlus(t, e) { return t + e }, leftForLtr(t, e) { return t } } }; function $r(t, e, n) { return t ? t3(e, n) : n3() } function e_(t, e) { let n, i; (e === "ltr" || e === "rtl") && (n = t.canvas.style, i = [n.getPropertyValue("direction"), n.getPropertyPriority("direction")], n.setProperty("direction", e, "important"), t.prevTextDirection = i) } function t_(t, e) { e !== void 0 && (delete t.prevTextDirection, t.canvas.style.setProperty("direction", e[0], e[1])) } function n_(t) { return t === "angle" ? { between: No, compare: i5, normalize: Mt } : { between: Rn, compare: (e, n) => e - n, normalize: e => e } } function p0({ start: t, end: e, count: n, loop: i, style: r }) { return { start: t % n, end: e % n, loop: i && (e - t + 1) % n === 0, style: r } } function i3(t, e, n) { const { property: i, start: r, end: s } = n, { between: o, normalize: a } = n_(i), l = e.length; let { start: c, end: u, loop: d } = t, f, h; if (d) { for (c += l, u += l, f = 0, h = l; f < h && o(a(e[c % l][i]), r, s); ++f)c--, u--; c %= l, u %= l } return u < c && (u += l), { start: c, end: u, loop: d, style: t.style } } function i_(t, e, n) { if (!n) return [t]; const { property: i, start: r, end: s } = n, o = e.length, { compare: a, between: l, normalize: c } = n_(i), { start: u, end: d, loop: f, style: h } = i3(t, e, n), m = []; let p = !1, x = null, y, g, v; const b = () => l(r, v, y) && a(r, v) !== 0, _ = () => a(s, y) === 0 || l(s, v, y), k = () => p || b(), S = () => !p || _(); for (let P = u, T = u; P <= d; ++P)g = e[P % o], !g.skip && (y = c(g[i]), y !== v && (p = l(y, r, s), x === null && k() && (x = a(y, r) === 0 ? P : T), x !== null && S() && (m.push(p0({ start: x, end: P, loop: f, count: o, style: h })), x = null), T = P, v = y)); return x !== null && m.push(p0({ start: x, end: d, loop: f, count: o, style: h })), m } function r_(t, e) { const n = [], i = t.segments; for (let r = 0; r < i.length; r++) { const s = i_(i[r], t.points, e); s.length && n.push(...s) } return n } function r3(t, e, n, i) { let r = 0, s = e - 1; if (n && !i) for (; r < e && !t[r].skip;)r++; for (; r < e && t[r].skip;)r++; for (r %= e, n && (s += r); s > r && t[s % e].skip;)s--; return s %= e, { start: r, end: s } } function s3(t, e, n, i) { const r = t.length, s = []; let o = e, a = t[e], l; for (l = e + 1; l <= n; ++l) { const c = t[l % r]; c.skip || c.stop ? a.skip || (i = !1, s.push({ start: e % r, end: (l - 1) % r, loop: i }), e = o = c.stop ? l : null) : (o = l, a.skip && (e = l)), a = c } return o !== null && s.push({ start: e % r, end: o % r, loop: i }), s } function o3(t, e) { const n = t.points, i = t.options.spanGaps, r = n.length; if (!r) return []; const s = !!t._loop, { start: o, end: a } = r3(n, r, s, i); if (i === !0) return m0(t, [{ start: o, end: a, loop: s }], n, e); const l = a < o ? a + r : a, c = !!t._fullLoop && o === 0 && a === r - 1; return m0(t, s3(n, o, l, c), n, e) } function m0(t, e, n, i) { return !i || !i.setContext || !n ? e : a3(t, e, n, i) } function a3(t, e, n, i) { const r = t._chart.getContext(), s = g0(t.options), { _datasetIndex: o, options: { spanGaps: a } } = t, l = n.length, c = []; let u = s, d = e[0].start, f = d; function h(m, p, x, y) { const g = a ? -1 : 1; if (m !== p) { for (m += l; n[m % l].skip;)m -= g; for (; n[p % l].skip;)p += g; m % l !== p % l && (c.push({ start: m % l, end: p % l, loop: x, style: y }), u = y, d = p % l) } } for (const m of e) { d = a ? d : m.start; let p = n[d % l], x; for (f = d + 1; f <= m.end; f++) { const y = n[f % l]; x = g0(i.setContext(Di(r, { type: "segment", p0: p, p1: y, p0DataIndex: (f - 1) % l, p1DataIndex: f % l, datasetIndex: o }))), l3(x, u) && h(d, f - 1, m.loop, u), p = y, u = x } d < f - 1 && h(d, f - 1, m.loop, u) } return c } function g0(t) { return { backgroundColor: t.backgroundColor, borderCapStyle: t.borderCapStyle, borderDash: t.borderDash, borderDashOffset: t.borderDashOffset, borderJoinStyle: t.borderJoinStyle, borderWidth: t.borderWidth, borderColor: t.borderColor } } function l3(t, e) { return e && JSON.stringify(t) !== JSON.stringify(e) }/*!
 * Chart.js v4.2.1
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */class c3 { constructor() { this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0 } _notify(e, n, i, r) { const s = n.listeners[r], o = n.duration; s.forEach(a => a({ chart: e, initial: n.initial, numSteps: o, currentStep: Math.min(i - n.start, o) })) } _refresh() { this._request || (this._running = !0, this._request = Vb.call(window, () => { this._update(), this._request = null, this._running && this._refresh() })) } _update(e = Date.now()) { let n = 0; this._charts.forEach((i, r) => { if (!i.running || !i.items.length) return; const s = i.items; let o = s.length - 1, a = !1, l; for (; o >= 0; --o)l = s[o], l._active ? (l._total > i.duration && (i.duration = l._total), l.tick(e), a = !0) : (s[o] = s[s.length - 1], s.pop()); a && (r.draw(), this._notify(r, i, e, "progress")), s.length || (i.running = !1, this._notify(r, i, e, "complete"), i.initial = !1), n += s.length }), this._lastDate = e, n === 0 && (this._running = !1) } _getAnims(e) { const n = this._charts; let i = n.get(e); return i || (i = { running: !1, initial: !0, items: [], listeners: { complete: [], progress: [] } }, n.set(e, i)), i } listen(e, n, i) { this._getAnims(e).listeners[n].push(i) } add(e, n) { !n || !n.length || this._getAnims(e).items.push(...n) } has(e) { return this._getAnims(e).items.length > 0 } start(e) { const n = this._charts.get(e); n && (n.running = !0, n.start = Date.now(), n.duration = n.items.reduce((i, r) => Math.max(i, r._duration), 0), this._refresh()) } running(e) { if (!this._running) return !1; const n = this._charts.get(e); return !(!n || !n.running || !n.items.length) } stop(e) { const n = this._charts.get(e); if (!n || !n.items.length) return; const i = n.items; let r = i.length - 1; for (; r >= 0; --r)i[r].cancel(); n.items = [], this._notify(e, n, Date.now(), "complete") } remove(e) { return this._charts.delete(e) } } var Sn = new c3; const y0 = "transparent", u3 = { boolean(t, e, n) { return n > .5 ? e : t }, color(t, e, n) { const i = a0(t || y0), r = i.valid && a0(e || y0); return r && r.valid ? r.mix(i, n).hexString() : e }, number(t, e, n) { return t + (e - t) * n } }; class d3 { constructor(e, n, i, r) { const s = n[i]; r = pe([e.to, r, s, e.from]); const o = pe([e.from, s, r]); this._active = !0, this._fn = e.fn || u3[e.type || typeof o], this._easing = io[e.easing] || io.linear, this._start = Math.floor(Date.now() + (e.delay || 0)), this._duration = this._total = Math.floor(e.duration), this._loop = !!e.loop, this._target = n, this._prop = i, this._from = o, this._to = r, this._promises = void 0 } active() { return this._active } update(e, n, i) { if (this._active) { this._notify(!1); const r = this._target[this._prop], s = i - this._start, o = this._duration - s; this._start = i, this._duration = Math.floor(Math.max(o, e.duration)), this._total += s, this._loop = !!e.loop, this._to = pe([e.to, n, r, e.from]), this._from = pe([e.from, r, n]) } } cancel() { this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1)) } tick(e) { const n = e - this._start, i = this._duration, r = this._prop, s = this._from, o = this._loop, a = this._to; let l; if (this._active = s !== a && (o || n < i), !this._active) { this._target[r] = a, this._notify(!0); return } if (n < 0) { this._target[r] = s; return } l = n / i % 2, l = o && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[r] = this._fn(s, a, l) } wait() { const e = this._promises || (this._promises = []); return new Promise((n, i) => { e.push({ res: n, rej: i }) }) } _notify(e) { const n = e ? "res" : "rej", i = this._promises || []; for (let r = 0; r < i.length; r++)i[r][n]() } } class s_ { constructor(e, n) { this._chart = e, this._properties = new Map, this.configure(n) } configure(e) { if (!ne(e)) return; const n = Object.keys(Le.animation), i = this._properties; Object.getOwnPropertyNames(e).forEach(r => { const s = e[r]; if (!ne(s)) return; const o = {}; for (const a of n) o[a] = s[a]; (me(s.properties) && s.properties || [r]).forEach(a => { (a === r || !i.has(a)) && i.set(a, o) }) }) } _animateOptions(e, n) { const i = n.options, r = h3(e, i); if (!r) return []; const s = this._createAnimations(r, i); return i.$shared && f3(e.options.$animations, i).then(() => { e.options = i }, () => { }), s } _createAnimations(e, n) { const i = this._properties, r = [], s = e.$animations || (e.$animations = {}), o = Object.keys(n), a = Date.now(); let l; for (l = o.length - 1; l >= 0; --l) { const c = o[l]; if (c.charAt(0) === "$") continue; if (c === "options") { r.push(...this._animateOptions(e, n)); continue } const u = n[c]; let d = s[c]; const f = i.get(c); if (d) if (f && d.active()) { d.update(f, u, a); continue } else d.cancel(); if (!f || !f.duration) { e[c] = u; continue } s[c] = d = new d3(f, e, c, u), r.push(d) } return r } update(e, n) { if (this._properties.size === 0) { Object.assign(e, n); return } const i = this._createAnimations(e, n); if (i.length) return Sn.add(this._chart, i), !0 } } function f3(t, e) { const n = [], i = Object.keys(e); for (let r = 0; r < i.length; r++) { const s = t[i[r]]; s && s.active() && n.push(s.wait()) } return Promise.all(n) } function h3(t, e) { if (!e) return; let n = t.options; if (!n) { t.options = e; return } return n.$shared && (t.options = n = Object.assign({}, n, { $shared: !1, $animations: {} })), n } function v0(t, e) { const n = t && t.options || {}, i = n.reverse, r = n.min === void 0 ? e : 0, s = n.max === void 0 ? e : 0; return { start: i ? s : r, end: i ? r : s } } function p3(t, e, n) { if (n === !1) return !1; const i = v0(t, n), r = v0(e, n); return { top: r.end, right: i.end, bottom: r.start, left: i.start } } function m3(t) { let e, n, i, r; return ne(t) ? (e = t.top, n = t.right, i = t.bottom, r = t.left) : e = n = i = r = t, { top: e, right: n, bottom: i, left: r, disabled: t === !1 } } function o_(t, e) { const n = [], i = t._getSortedDatasetMetas(e); let r, s; for (r = 0, s = i.length; r < s; ++r)n.push(i[r].index); return n } function x0(t, e, n, i = {}) { const r = t.keys, s = i.mode === "single"; let o, a, l, c; if (e !== null) { for (o = 0, a = r.length; o < a; ++o) { if (l = +r[o], l === n) { if (i.all) continue; break } c = t.values[l], Oe(c) && (s || e === 0 || gn(e) === gn(c)) && (e += c) } return e } } function g3(t) { const e = Object.keys(t), n = new Array(e.length); let i, r, s; for (i = 0, r = e.length; i < r; ++i)s = e[i], n[i] = { x: s, y: t[s] }; return n } function w0(t, e) { const n = t && t.options.stacked; return n || n === void 0 && e.stack !== void 0 } function y3(t, e, n) { return `${t.id}.${e.id}.${n.stack || n.type}` } function v3(t) { const { min: e, max: n, minDefined: i, maxDefined: r } = t.getUserBounds(); return { min: i ? e : Number.NEGATIVE_INFINITY, max: r ? n : Number.POSITIVE_INFINITY } } function x3(t, e, n) { const i = t[e] || (t[e] = {}); return i[n] || (i[n] = {}) } function b0(t, e, n, i) { for (const r of e.getMatchingVisibleMetas(i).reverse()) { const s = t[r.index]; if (n && s > 0 || !n && s < 0) return r.index } return null } function _0(t, e) { const { chart: n, _cachedMeta: i } = t, r = n._stacks || (n._stacks = {}), { iScale: s, vScale: o, index: a } = i, l = s.axis, c = o.axis, u = y3(s, o, i), d = e.length; let f; for (let h = 0; h < d; ++h) { const m = e[h], { [l]: p, [c]: x } = m, y = m._stacks || (m._stacks = {}); f = y[c] = x3(r, u, p), f[a] = x, f._top = b0(f, o, !0, i.type), f._bottom = b0(f, o, !1, i.type); const g = f._visualValues || (f._visualValues = {}); g[a] = x } } function rd(t, e) { const n = t.scales; return Object.keys(n).filter(i => n[i].axis === e).shift() } function w3(t, e) { return Di(t, { active: !1, dataset: void 0, datasetIndex: e, index: e, mode: "default", type: "dataset" }) } function b3(t, e, n) { return Di(t, { active: !1, dataIndex: e, parsed: void 0, raw: void 0, element: n, index: e, mode: "default", type: "data" }) } function Ss(t, e) { const n = t.controller.index, i = t.vScale && t.vScale.axis; if (i) { e = e || t._parsed; for (const r of e) { const s = r._stacks; if (!s || s[i] === void 0 || s[i][n] === void 0) return; delete s[i][n], s[i]._visualValues !== void 0 && s[i]._visualValues[n] !== void 0 && delete s[i]._visualValues[n] } } } const sd = t => t === "reset" || t === "none", S0 = (t, e) => e ? t : Object.assign({}, t), _3 = (t, e, n) => t && !e.hidden && e._stacked && { keys: o_(n, !0), values: null }; class Jt { constructor(e, n) { this.chart = e, this._ctx = e.ctx, this.index = n, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize() } initialize() { const e = this._cachedMeta; this.configure(), this.linkScales(), e._stacked = w0(e.vScale, e), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options") } updateIndex(e) { this.index !== e && Ss(this._cachedMeta), this.index = e } linkScales() { const e = this.chart, n = this._cachedMeta, i = this.getDataset(), r = (d, f, h, m) => d === "x" ? f : d === "r" ? m : h, s = n.xAxisID = Q(i.xAxisID, rd(e, "x")), o = n.yAxisID = Q(i.yAxisID, rd(e, "y")), a = n.rAxisID = Q(i.rAxisID, rd(e, "r")), l = n.indexAxis, c = n.iAxisID = r(l, s, o, a), u = n.vAxisID = r(l, o, s, a); n.xScale = this.getScaleForId(s), n.yScale = this.getScaleForId(o), n.rScale = this.getScaleForId(a), n.iScale = this.getScaleForId(c), n.vScale = this.getScaleForId(u) } getDataset() { return this.chart.data.datasets[this.index] } getMeta() { return this.chart.getDatasetMeta(this.index) } getScaleForId(e) { return this.chart.scales[e] } _getOtherScale(e) { const n = this._cachedMeta; return e === n.iScale ? n.vScale : n.iScale } reset() { this._update("reset") } _destroy() { const e = this._cachedMeta; this._data && r0(this._data, this), e._stacked && Ss(e) } _dataCheck() { const e = this.getDataset(), n = e.data || (e.data = []), i = this._data; if (ne(n)) this._data = g3(n); else if (i !== n) { if (i) { r0(i, this); const r = this._cachedMeta; Ss(r), r._parsed = [] } n && Object.isExtensible(n) && a5(n, this), this._syncList = [], this._data = n } } addElements() { const e = this._cachedMeta; this._dataCheck(), this.datasetElementType && (e.dataset = new this.datasetElementType) } buildOrUpdateElements(e) { const n = this._cachedMeta, i = this.getDataset(); let r = !1; this._dataCheck(); const s = n._stacked; n._stacked = w0(n.vScale, n), n.stack !== i.stack && (r = !0, Ss(n), n.stack = i.stack), this._resyncElements(e), (r || s !== n._stacked) && _0(this, n._parsed) } configure() { const e = this.chart.config, n = e.datasetScopeKeys(this._type), i = e.getOptionScopes(this.getDataset(), n, !0); this.options = e.createResolver(i, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {} } parse(e, n) { const { _cachedMeta: i, _data: r } = this, { iScale: s, _stacked: o } = i, a = s.axis; let l = e === 0 && n === r.length ? !0 : i._sorted, c = e > 0 && i._parsed[e - 1], u, d, f; if (this._parsing === !1) i._parsed = r, i._sorted = !0, f = r; else { me(r[e]) ? f = this.parseArrayData(i, r, e, n) : ne(r[e]) ? f = this.parseObjectData(i, r, e, n) : f = this.parsePrimitiveData(i, r, e, n); const h = () => d[a] === null || c && d[a] < c[a]; for (u = 0; u < n; ++u)i._parsed[u + e] = d = f[u], l && (h() && (l = !1), c = d); i._sorted = l } o && _0(this, f) } parsePrimitiveData(e, n, i, r) { const { iScale: s, vScale: o } = e, a = s.axis, l = o.axis, c = s.getLabels(), u = s === o, d = new Array(r); let f, h, m; for (f = 0, h = r; f < h; ++f)m = f + i, d[f] = { [a]: u || s.parse(c[m], m), [l]: o.parse(n[m], m) }; return d } parseArrayData(e, n, i, r) { const { xScale: s, yScale: o } = e, a = new Array(r); let l, c, u, d; for (l = 0, c = r; l < c; ++l)u = l + i, d = n[u], a[l] = { x: s.parse(d[0], u), y: o.parse(d[1], u) }; return a } parseObjectData(e, n, i, r) { const { xScale: s, yScale: o } = e, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, c = new Array(r); let u, d, f, h; for (u = 0, d = r; u < d; ++u)f = u + i, h = n[f], c[u] = { x: s.parse(ki(h, a), f), y: o.parse(ki(h, l), f) }; return c } getParsed(e) { return this._cachedMeta._parsed[e] } getDataElement(e) { return this._cachedMeta.data[e] } applyStack(e, n, i) { const r = this.chart, s = this._cachedMeta, o = n[e.axis], a = { keys: o_(r, !0), values: n._stacks[e.axis]._visualValues }; return x0(a, o, s.index, { mode: i }) } updateRangeFromParsed(e, n, i, r) { const s = i[n.axis]; let o = s === null ? NaN : s; const a = r && i._stacks[n.axis]; r && a && (r.values = a, o = x0(r, s, this._cachedMeta.index)), e.min = Math.min(e.min, o), e.max = Math.max(e.max, o) } getMinMax(e, n) { const i = this._cachedMeta, r = i._parsed, s = i._sorted && e === i.iScale, o = r.length, a = this._getOtherScale(e), l = _3(n, i, this.chart), c = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }, { min: u, max: d } = v3(a); let f, h; function m() { h = r[f]; const p = h[a.axis]; return !Oe(h[e.axis]) || u > p || d < p } for (f = 0; f < o && !(!m() && (this.updateRangeFromParsed(c, e, h, l), s)); ++f); if (s) { for (f = o - 1; f >= 0; --f)if (!m()) { this.updateRangeFromParsed(c, e, h, l); break } } return c } getAllParsedValues(e) { const n = this._cachedMeta._parsed, i = []; let r, s, o; for (r = 0, s = n.length; r < s; ++r)o = n[r][e.axis], Oe(o) && i.push(o); return i } getMaxOverflow() { return !1 } getLabelAndValue(e) { const n = this._cachedMeta, i = n.iScale, r = n.vScale, s = this.getParsed(e); return { label: i ? "" + i.getLabelForValue(s[i.axis]) : "", value: r ? "" + r.getLabelForValue(s[r.axis]) : "" } } _update(e) { const n = this._cachedMeta; this.update(e || "default"), n._clip = m3(Q(this.options.clip, p3(n.xScale, n.yScale, this.getMaxOverflow()))) } update(e) { } draw() { const e = this._ctx, n = this.chart, i = this._cachedMeta, r = i.data || [], s = n.chartArea, o = [], a = this._drawStart || 0, l = this._drawCount || r.length - a, c = this.options.drawActiveElementsOnTop; let u; for (i.dataset && i.dataset.draw(e, s, a, l), u = a; u < a + l; ++u) { const d = r[u]; d.hidden || (d.active && c ? o.push(d) : d.draw(e, s)) } for (u = 0; u < o.length; ++u)o[u].draw(e, s) } getStyle(e, n) { const i = n ? "active" : "default"; return e === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i) : this.resolveDataElementOptions(e || 0, i) } getContext(e, n, i) { const r = this.getDataset(); let s; if (e >= 0 && e < this._cachedMeta.data.length) { const o = this._cachedMeta.data[e]; s = o.$context || (o.$context = b3(this.getContext(), e, o)), s.parsed = this.getParsed(e), s.raw = r.data[e], s.index = s.dataIndex = e } else s = this.$context || (this.$context = w3(this.chart.getContext(), this.index)), s.dataset = r, s.index = s.datasetIndex = this.index; return s.active = !!n, s.mode = i, s } resolveDatasetElementOptions(e) { return this._resolveElementOptions(this.datasetElementType.id, e) } resolveDataElementOptions(e, n) { return this._resolveElementOptions(this.dataElementType.id, n, e) } _resolveElementOptions(e, n = "default", i) { const r = n === "active", s = this._cachedDataOpts, o = e + "-" + n, a = s[o], l = this.enableOptionSharing && Wt(i); if (a) return S0(a, l); const c = this.chart.config, u = c.datasetElementScopeKeys(this._type, e), d = r ? [`${e}Hover`, "hover", e, ""] : [e, ""], f = c.getOptionScopes(this.getDataset(), u), h = Object.keys(Le.elements[e]), m = () => this.getContext(i, r, n), p = c.resolveNamedOptions(f, h, m, d); return p.$shared && (p.$shared = l, s[o] = Object.freeze(S0(p, l))), p } _resolveAnimations(e, n, i) { const r = this.chart, s = this._cachedDataOpts, o = `animation-${n}`, a = s[o]; if (a) return a; let l; if (r.options.animation !== !1) { const u = this.chart.config, d = u.datasetAnimationScopeKeys(this._type, n), f = u.getOptionScopes(this.getDataset(), d); l = u.createResolver(f, this.getContext(e, i, n)) } const c = new s_(r, l && l.animations); return l && l._cacheable && (s[o] = Object.freeze(c)), c } getSharedOptions(e) { if (e.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, e)) } includeOptions(e, n) { return !n || sd(e) || this.chart._animationsDisabled } _getSharedOptions(e, n) { const i = this.resolveDataElementOptions(e, n), r = this._sharedOptions, s = this.getSharedOptions(i), o = this.includeOptions(n, s) || s !== r; return this.updateSharedOptions(s, n, i), { sharedOptions: s, includeOptions: o } } updateElement(e, n, i, r) { sd(r) ? Object.assign(e, i) : this._resolveAnimations(n, r).update(e, i) } updateSharedOptions(e, n, i) { e && !sd(n) && this._resolveAnimations(void 0, n).update(e, i) } _setStyle(e, n, i, r) { e.active = r; const s = this.getStyle(n, r); this._resolveAnimations(n, i, r).update(e, { options: !r && this.getSharedOptions(s) || s }) } removeHoverStyle(e, n, i) { this._setStyle(e, i, "active", !1) } setHoverStyle(e, n, i) { this._setStyle(e, i, "active", !0) } _removeDatasetHoverStyle() { const e = this._cachedMeta.dataset; e && this._setStyle(e, void 0, "active", !1) } _setDatasetHoverStyle() { const e = this._cachedMeta.dataset; e && this._setStyle(e, void 0, "active", !0) } _resyncElements(e) { const n = this._data, i = this._cachedMeta.data; for (const [a, l, c] of this._syncList) this[a](l, c); this._syncList = []; const r = i.length, s = n.length, o = Math.min(s, r); o && this.parse(0, o), s > r ? this._insertElements(r, s - r, e) : s < r && this._removeElements(s, r - s) } _insertElements(e, n, i = !0) { const r = this._cachedMeta, s = r.data, o = e + n; let a; const l = c => { for (c.length += n, a = c.length - 1; a >= o; a--)c[a] = c[a - n] }; for (l(s), a = e; a < o; ++a)s[a] = new this.dataElementType; this._parsing && l(r._parsed), this.parse(e, n), i && this.updateElements(s, e, n, "reset") } updateElements(e, n, i, r) { } _removeElements(e, n) { const i = this._cachedMeta; if (this._parsing) { const r = i._parsed.splice(e, n); i._stacked && Ss(i, r) } i.data.splice(e, n) } _sync(e) { if (this._parsing) this._syncList.push(e); else { const [n, i, r] = e; this[n](i, r) } this.chart._dataChanges.push([this.index, ...e]) } _onDataPush() { const e = arguments.length; this._sync(["_insertElements", this.getDataset().data.length - e, e]) } _onDataPop() { this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]) } _onDataShift() { this._sync(["_removeElements", 0, 1]) } _onDataSplice(e, n) { n && this._sync(["_removeElements", e, n]); const i = arguments.length - 2; i && this._sync(["_insertElements", e, i]) } _onDataUnshift() { this._sync(["_insertElements", 0, arguments.length]) } } F(Jt, "defaults", {}), F(Jt, "datasetElementType", null), F(Jt, "dataElementType", null); function S3(t, e) { if (!t._cache.$bar) { const n = t.getMatchingVisibleMetas(e); let i = []; for (let r = 0, s = n.length; r < s; r++)i = i.concat(n[r].controller.getAllParsedValues(t)); t._cache.$bar = Ib(i.sort((r, s) => r - s)) } return t._cache.$bar } function k3(t) { const e = t.iScale, n = S3(e, t.type); let i = e._length, r, s, o, a; const l = () => { o === 32767 || o === -32768 || (Wt(a) && (i = Math.min(i, Math.abs(o - a) || i)), a = o) }; for (r = 0, s = n.length; r < s; ++r)o = e.getPixelForValue(n[r]), l(); for (a = void 0, r = 0, s = e.ticks.length; r < s; ++r)o = e.getPixelForTick(r), l(); return i } function P3(t, e, n, i) { const r = n.barThickness; let s, o; return te(r) ? (s = e.min * n.categoryPercentage, o = n.barPercentage) : (s = r * i, o = 1), { chunk: s / i, ratio: o, start: e.pixels[t] - s / 2 } } function C3(t, e, n, i) { const r = e.pixels, s = r[t]; let o = t > 0 ? r[t - 1] : null, a = t < r.length - 1 ? r[t + 1] : null; const l = n.categoryPercentage; o === null && (o = s - (a === null ? e.end - e.start : a - s)), a === null && (a = s + s - o); const c = s - (s - Math.min(o, a)) / 2 * l; return { chunk: Math.abs(a - o) / 2 * l / i, ratio: n.barPercentage, start: c } } function M3(t, e, n, i) { const r = n.parse(t[0], i), s = n.parse(t[1], i), o = Math.min(r, s), a = Math.max(r, s); let l = o, c = a; Math.abs(o) > Math.abs(a) && (l = a, c = o), e[n.axis] = c, e._custom = { barStart: l, barEnd: c, start: r, end: s, min: o, max: a } } function a_(t, e, n, i) { return me(t) ? M3(t, e, n, i) : e[n.axis] = n.parse(t, i), e } function k0(t, e, n, i) { const r = t.iScale, s = t.vScale, o = r.getLabels(), a = r === s, l = []; let c, u, d, f; for (c = n, u = n + i; c < u; ++c)f = e[c], d = {}, d[r.axis] = a || r.parse(o[c], c), l.push(a_(f, d, s, c)); return l } function od(t) { return t && t.barStart !== void 0 && t.barEnd !== void 0 } function T3(t, e, n) { return t !== 0 ? gn(t) : (e.isHorizontal() ? 1 : -1) * (e.min >= n ? 1 : -1) } function E3(t) { let e, n, i, r, s; return t.horizontal ? (e = t.base > t.x, n = "left", i = "right") : (e = t.base < t.y, n = "bottom", i = "top"), e ? (r = "end", s = "start") : (r = "start", s = "end"), { start: n, end: i, reverse: e, top: r, bottom: s } } function D3(t, e, n, i) { let r = e.borderSkipped; const s = {}; if (!r) { t.borderSkipped = s; return } if (r === !0) { t.borderSkipped = { top: !0, right: !0, bottom: !0, left: !0 }; return } const { start: o, end: a, reverse: l, top: c, bottom: u } = E3(t); r === "middle" && n && (t.enableBorderRadius = !0, (n._top || 0) === i ? r = c : (n._bottom || 0) === i ? r = u : (s[P0(u, o, a, l)] = !0, r = c)), s[P0(r, o, a, l)] = !0, t.borderSkipped = s } function P0(t, e, n, i) { return i ? (t = O3(t, e, n), t = C0(t, n, e)) : t = C0(t, e, n), t } function O3(t, e, n) { return t === e ? n : t === n ? e : t } function C0(t, e, n) { return t === "start" ? e : t === "end" ? n : t } function R3(t, { inflateAmount: e }, n) { t.inflateAmount = e === "auto" ? n === 1 ? .33 : 0 : e } class vl extends Jt { parsePrimitiveData(e, n, i, r) { return k0(e, n, i, r) } parseArrayData(e, n, i, r) { return k0(e, n, i, r) } parseObjectData(e, n, i, r) { const { iScale: s, vScale: o } = e, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, c = s.axis === "x" ? a : l, u = o.axis === "x" ? a : l, d = []; let f, h, m, p; for (f = i, h = i + r; f < h; ++f)p = n[f], m = {}, m[s.axis] = s.parse(ki(p, c), f), d.push(a_(ki(p, u), m, o, f)); return d } updateRangeFromParsed(e, n, i, r) { super.updateRangeFromParsed(e, n, i, r); const s = i._custom; s && n === this._cachedMeta.vScale && (e.min = Math.min(e.min, s.min), e.max = Math.max(e.max, s.max)) } getMaxOverflow() { return 0 } getLabelAndValue(e) { const n = this._cachedMeta, { iScale: i, vScale: r } = n, s = this.getParsed(e), o = s._custom, a = od(o) ? "[" + o.start + ", " + o.end + "]" : "" + r.getLabelForValue(s[r.axis]); return { label: "" + i.getLabelForValue(s[i.axis]), value: a } } initialize() { this.enableOptionSharing = !0, super.initialize(); const e = this._cachedMeta; e.stack = this.getDataset().stack } update(e) { const n = this._cachedMeta; this.updateElements(n.data, 0, n.data.length, e) } updateElements(e, n, i, r) { const s = r === "reset", { index: o, _cachedMeta: { vScale: a } } = this, l = a.getBasePixel(), c = a.isHorizontal(), u = this._getRuler(), { sharedOptions: d, includeOptions: f } = this._getSharedOptions(n, r); for (let h = n; h < n + i; h++) { const m = this.getParsed(h), p = s || te(m[a.axis]) ? { base: l, head: l } : this._calculateBarValuePixels(h), x = this._calculateBarIndexPixels(h, u), y = (m._stacks || {})[a.axis], g = { horizontal: c, base: p.base, enableBorderRadius: !y || od(m._custom) || o === y._top || o === y._bottom, x: c ? p.head : x.center, y: c ? x.center : p.head, height: c ? x.size : Math.abs(p.size), width: c ? Math.abs(p.size) : x.size }; f && (g.options = d || this.resolveDataElementOptions(h, e[h].active ? "active" : r)); const v = g.options || e[h].options; D3(g, v, y, o), R3(g, v, u.ratio), this.updateElement(e[h], h, g, r) } } _getStacks(e, n) { const { iScale: i } = this._cachedMeta, r = i.getMatchingVisibleMetas(this._type).filter(l => l.controller.options.grouped), s = i.options.stacked, o = [], a = l => { const c = l.controller.getParsed(n), u = c && c[l.vScale.axis]; if (te(u) || isNaN(u)) return !0 }; for (const l of r) if (!(n !== void 0 && a(l)) && ((s === !1 || o.indexOf(l.stack) === -1 || s === void 0 && l.stack === void 0) && o.push(l.stack), l.index === e)) break; return o.length || o.push(void 0), o } _getStackCount(e) { return this._getStacks(void 0, e).length } _getStackIndex(e, n, i) { const r = this._getStacks(e, i), s = n !== void 0 ? r.indexOf(n) : -1; return s === -1 ? r.length - 1 : s } _getRuler() { const e = this.options, n = this._cachedMeta, i = n.iScale, r = []; let s, o; for (s = 0, o = n.data.length; s < o; ++s)r.push(i.getPixelForValue(this.getParsed(s)[i.axis], s)); const a = e.barThickness; return { min: a || k3(n), pixels: r, start: i._startPixel, end: i._endPixel, stackCount: this._getStackCount(), scale: i, grouped: e.grouped, ratio: a ? 1 : e.categoryPercentage * e.barPercentage } } _calculateBarValuePixels(e) { const { _cachedMeta: { vScale: n, _stacked: i, index: r }, options: { base: s, minBarLength: o } } = this, a = s || 0, l = this.getParsed(e), c = l._custom, u = od(c); let d = l[n.axis], f = 0, h = i ? this.applyStack(n, l, i) : d, m, p; h !== d && (f = h - d, h = d), u && (d = c.barStart, h = c.barEnd - c.barStart, d !== 0 && gn(d) !== gn(c.barEnd) && (f = 0), f += d); const x = !te(s) && !u ? s : f; let y = n.getPixelForValue(x); if (this.chart.getDataVisibility(e) ? m = n.getPixelForValue(f + h) : m = y, p = m - y, Math.abs(p) < o) { p = T3(p, n, a) * o, d === a && (y -= p / 2); const g = n.getPixelForDecimal(0), v = n.getPixelForDecimal(1), b = Math.min(g, v), _ = Math.max(g, v); y = Math.max(Math.min(y, _), b), m = y + p, i && !u && (l._stacks[n.axis]._visualValues[r] = n.getValueForPixel(m) - n.getValueForPixel(y)) } if (y === n.getPixelForValue(a)) { const g = gn(p) * n.getLineWidthForValue(a) / 2; y += g, p -= g } return { size: p, base: y, head: m, center: m + p / 2 } } _calculateBarIndexPixels(e, n) { const i = n.scale, r = this.options, s = r.skipNull, o = Q(r.maxBarThickness, 1 / 0); let a, l; if (n.grouped) { const c = s ? this._getStackCount(e) : n.stackCount, u = r.barThickness === "flex" ? C3(e, n, r, c) : P3(e, n, r, c), d = this._getStackIndex(this.index, this._cachedMeta.stack, s ? e : void 0); a = u.start + u.chunk * d + u.chunk / 2, l = Math.min(o, u.chunk * u.ratio) } else a = i.getPixelForValue(this.getParsed(e)[i.axis], e), l = Math.min(o, n.min * n.ratio); return { base: a - l / 2, head: a + l / 2, center: a, size: l } } draw() { const e = this._cachedMeta, n = e.vScale, i = e.data, r = i.length; let s = 0; for (; s < r; ++s)this.getParsed(s)[n.axis] !== null && i[s].draw(this._ctx) } } F(vl, "id", "bar"), F(vl, "defaults", { datasetElementType: !1, dataElementType: "bar", categoryPercentage: .8, barPercentage: .9, grouped: !0, animations: { numbers: { type: "number", properties: ["x", "y", "base", "width", "height"] } } }), F(vl, "overrides", { scales: { _index_: { type: "category", offset: !0, grid: { offset: !0 } }, _value_: { type: "linear", beginAtZero: !0 } } }); class xl extends Jt { initialize() { this.enableOptionSharing = !0, super.initialize() } parsePrimitiveData(e, n, i, r) { const s = super.parsePrimitiveData(e, n, i, r); for (let o = 0; o < s.length; o++)s[o]._custom = this.resolveDataElementOptions(o + i).radius; return s } parseArrayData(e, n, i, r) { const s = super.parseArrayData(e, n, i, r); for (let o = 0; o < s.length; o++) { const a = n[i + o]; s[o]._custom = Q(a[2], this.resolveDataElementOptions(o + i).radius) } return s } parseObjectData(e, n, i, r) { const s = super.parseObjectData(e, n, i, r); for (let o = 0; o < s.length; o++) { const a = n[i + o]; s[o]._custom = Q(a && a.r && +a.r, this.resolveDataElementOptions(o + i).radius) } return s } getMaxOverflow() { const e = this._cachedMeta.data; let n = 0; for (let i = e.length - 1; i >= 0; --i)n = Math.max(n, e[i].size(this.resolveDataElementOptions(i)) / 2); return n > 0 && n } getLabelAndValue(e) { const n = this._cachedMeta, i = this.chart.data.labels || [], { xScale: r, yScale: s } = n, o = this.getParsed(e), a = r.getLabelForValue(o.x), l = s.getLabelForValue(o.y), c = o._custom; return { label: i[e] || "", value: "(" + a + ", " + l + (c ? ", " + c : "") + ")" } } update(e) { const n = this._cachedMeta.data; this.updateElements(n, 0, n.length, e) } updateElements(e, n, i, r) { const s = r === "reset", { iScale: o, vScale: a } = this._cachedMeta, { sharedOptions: l, includeOptions: c } = this._getSharedOptions(n, r), u = o.axis, d = a.axis; for (let f = n; f < n + i; f++) { const h = e[f], m = !s && this.getParsed(f), p = {}, x = p[u] = s ? o.getPixelForDecimal(.5) : o.getPixelForValue(m[u]), y = p[d] = s ? a.getBasePixel() : a.getPixelForValue(m[d]); p.skip = isNaN(x) || isNaN(y), c && (p.options = l || this.resolveDataElementOptions(f, h.active ? "active" : r), s && (p.options.radius = 0)), this.updateElement(h, f, p, r) } } resolveDataElementOptions(e, n) { const i = this.getParsed(e); let r = super.resolveDataElementOptions(e, n); r.$shared && (r = Object.assign({}, r, { $shared: !1 })); const s = r.radius; return n !== "active" && (r.radius = 0), r.radius += Q(i && i._custom, s), r } } F(xl, "id", "bubble"), F(xl, "defaults", { datasetElementType: !1, dataElementType: "point", animations: { numbers: { type: "number", properties: ["x", "y", "borderWidth", "radius"] } } }), F(xl, "overrides", { scales: { x: { type: "linear" }, y: { type: "linear" } } }); function L3(t, e, n) { let i = 1, r = 1, s = 0, o = 0; if (e < ye) { const a = t, l = a + e, c = Math.cos(a), u = Math.sin(a), d = Math.cos(l), f = Math.sin(l), h = (v, b, _) => No(v, a, l, !0) ? 1 : Math.max(b, b * n, _, _ * n), m = (v, b, _) => No(v, a, l, !0) ? -1 : Math.min(b, b * n, _, _ * n), p = h(0, c, d), x = h(Re, u, f), y = m(we, c, d), g = m(we + Re, u, f); i = (p - y) / 2, r = (x - g) / 2, s = -(p + y) / 2, o = -(x + g) / 2 } return { ratioX: i, ratioY: r, offsetX: s, offsetY: o } } class si extends Jt { constructor(e, n) { super(e, n), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0 } linkScales() { } parse(e, n) { const i = this.getDataset().data, r = this._cachedMeta; if (this._parsing === !1) r._parsed = i; else { let s = l => +i[l]; if (ne(i[e])) { const { key: l = "value" } = this._parsing; s = c => +ki(i[c], l) } let o, a; for (o = e, a = e + n; o < a; ++o)r._parsed[o] = s(o) } } _getRotation() { return Qt(this.options.rotation - 90) } _getCircumference() { return Qt(this.options.circumference) } _getRotationExtents() { let e = ye, n = -ye; for (let i = 0; i < this.chart.data.datasets.length; ++i)if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) { const r = this.chart.getDatasetMeta(i).controller, s = r._getRotation(), o = r._getCircumference(); e = Math.min(e, s), n = Math.max(n, s + o) } return { rotation: e, circumference: n - e } } update(e) { const n = this.chart, { chartArea: i } = n, r = this._cachedMeta, s = r.data, o = this.getMaxBorderWidth() + this.getMaxOffset(s) + this.options.spacing, a = Math.max((Math.min(i.width, i.height) - o) / 2, 0), l = Math.min(KO(this.options.cutout, a), 1), c = this._getRingWeight(this.index), { circumference: u, rotation: d } = this._getRotationExtents(), { ratioX: f, ratioY: h, offsetX: m, offsetY: p } = L3(d, u, l), x = (i.width - o) / f, y = (i.height - o) / h, g = Math.max(Math.min(x, y) / 2, 0), v = Lb(this.options.radius, g), b = Math.max(v * l, 0), _ = (v - b) / this._getVisibleDatasetWeightTotal(); this.offsetX = m * v, this.offsetY = p * v, r.total = this.calculateTotal(), this.outerRadius = v - _ * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - _ * c, 0), this.updateElements(s, 0, s.length, e) } _circumference(e, n) { const i = this.options, r = this._cachedMeta, s = this._getCircumference(); return n && i.animation.animateRotate || !this.chart.getDataVisibility(e) || r._parsed[e] === null || r.data[e].hidden ? 0 : this.calculateCircumference(r._parsed[e] * s / ye) } updateElements(e, n, i, r) { const s = r === "reset", o = this.chart, a = o.chartArea, c = o.options.animation, u = (a.left + a.right) / 2, d = (a.top + a.bottom) / 2, f = s && c.animateScale, h = f ? 0 : this.innerRadius, m = f ? 0 : this.outerRadius, { sharedOptions: p, includeOptions: x } = this._getSharedOptions(n, r); let y = this._getRotation(), g; for (g = 0; g < n; ++g)y += this._circumference(g, s); for (g = n; g < n + i; ++g) { const v = this._circumference(g, s), b = e[g], _ = { x: u + this.offsetX, y: d + this.offsetY, startAngle: y, endAngle: y + v, circumference: v, outerRadius: m, innerRadius: h }; x && (_.options = p || this.resolveDataElementOptions(g, b.active ? "active" : r)), y += v, this.updateElement(b, g, _, r) } } calculateTotal() { const e = this._cachedMeta, n = e.data; let i = 0, r; for (r = 0; r < n.length; r++) { const s = e._parsed[r]; s !== null && !isNaN(s) && this.chart.getDataVisibility(r) && !n[r].hidden && (i += Math.abs(s)) } return i } calculateCircumference(e) { const n = this._cachedMeta.total; return n > 0 && !isNaN(e) ? ye * (Math.abs(e) / n) : 0 } getLabelAndValue(e) { const n = this._cachedMeta, i = this.chart, r = i.data.labels || [], s = sa(n._parsed[e], i.options.locale); return { label: r[e] || "", value: s } } getMaxBorderWidth(e) { let n = 0; const i = this.chart; let r, s, o, a, l; if (!e) { for (r = 0, s = i.data.datasets.length; r < s; ++r)if (i.isDatasetVisible(r)) { o = i.getDatasetMeta(r), e = o.data, a = o.controller; break } } if (!e) return 0; for (r = 0, s = e.length; r < s; ++r)l = a.resolveDataElementOptions(r), l.borderAlign !== "inner" && (n = Math.max(n, l.borderWidth || 0, l.hoverBorderWidth || 0)); return n } getMaxOffset(e) { let n = 0; for (let i = 0, r = e.length; i < r; ++i) { const s = this.resolveDataElementOptions(i); n = Math.max(n, s.offset || 0, s.hoverOffset || 0) } return n } _getRingWeightOffset(e) { let n = 0; for (let i = 0; i < e; ++i)this.chart.isDatasetVisible(i) && (n += this._getRingWeight(i)); return n } _getRingWeight(e) { return Math.max(Q(this.chart.data.datasets[e].weight, 1), 0) } _getVisibleDatasetWeightTotal() { return this._getRingWeightOffset(this.chart.data.datasets.length) || 1 } } F(si, "id", "doughnut"), F(si, "defaults", { datasetElementType: !1, dataElementType: "arc", animation: { animateRotate: !0, animateScale: !1 }, animations: { numbers: { type: "number", properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"] } }, cutout: "50%", rotation: 0, circumference: 360, radius: "100%", spacing: 0, indexAxis: "r" }), F(si, "descriptors", { _scriptable: e => e !== "spacing", _indexable: e => e !== "spacing" }), F(si, "overrides", { aspectRatio: 1, plugins: { legend: { labels: { generateLabels(e) { const n = e.data; if (n.labels.length && n.datasets.length) { const { labels: { pointStyle: i, color: r } } = e.legend.options; return n.labels.map((s, o) => { const l = e.getDatasetMeta(0).controller.getStyle(o); return { text: s, fillStyle: l.backgroundColor, strokeStyle: l.borderColor, fontColor: r, lineWidth: l.borderWidth, pointStyle: i, hidden: !e.getDataVisibility(o), index: o } }) } return [] } }, onClick(e, n, i) { i.chart.toggleDataVisibility(n.index), i.chart.update() } } } }); class wl extends Jt { initialize() { this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize() } update(e) { const n = this._cachedMeta, { dataset: i, data: r = [], _dataset: s } = n, o = this.chart._animationsDisabled; let { start: a, count: l } = Bb(n, r, o); this._drawStart = a, this._drawCount = l, Hb(n) && (a = 0, l = r.length), i._chart = this.chart, i._datasetIndex = this.index, i._decimated = !!s._decimated, i.points = r; const c = this.resolveDatasetElementOptions(e); this.options.showLine || (c.borderWidth = 0), c.segment = this.options.segment, this.updateElement(i, void 0, { animated: !o, options: c }, e), this.updateElements(r, a, l, e) } updateElements(e, n, i, r) { const s = r === "reset", { iScale: o, vScale: a, _stacked: l, _dataset: c } = this._cachedMeta, { sharedOptions: u, includeOptions: d } = this._getSharedOptions(n, r), f = o.axis, h = a.axis, { spanGaps: m, segment: p } = this.options, x = ts(m) ? m : Number.POSITIVE_INFINITY, y = this.chart._animationsDisabled || s || r === "none", g = n + i, v = e.length; let b = n > 0 && this.getParsed(n - 1); for (let _ = 0; _ < v; ++_) { const k = e[_], S = y ? k : {}; if (_ < n || _ >= g) { S.skip = !0; continue } const P = this.getParsed(_), T = te(P[h]), D = S[f] = o.getPixelForValue(P[f], _), A = S[h] = s || T ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, P, l) : P[h], _); S.skip = isNaN(D) || isNaN(A) || T, S.stop = _ > 0 && Math.abs(P[f] - b[f]) > x, p && (S.parsed = P, S.raw = c.data[_]), d && (S.options = u || this.resolveDataElementOptions(_, k.active ? "active" : r)), y || this.updateElement(k, _, S, r), b = P } } getMaxOverflow() { const e = this._cachedMeta, n = e.dataset, i = n.options && n.options.borderWidth || 0, r = e.data || []; if (!r.length) return i; const s = r[0].size(this.resolveDataElementOptions(0)), o = r[r.length - 1].size(this.resolveDataElementOptions(r.length - 1)); return Math.max(i, s, o) / 2 } draw() { const e = this._cachedMeta; e.dataset.updateControlPoints(this.chart.chartArea, e.iScale.axis), super.draw() } } F(wl, "id", "line"), F(wl, "defaults", { datasetElementType: "line", dataElementType: "point", showLine: !0, spanGaps: !1 }), F(wl, "overrides", { scales: { _index_: { type: "category" }, _value_: { type: "linear" } } }); class so extends Jt { constructor(e, n) { super(e, n), this.innerRadius = void 0, this.outerRadius = void 0 } getLabelAndValue(e) { const n = this._cachedMeta, i = this.chart, r = i.data.labels || [], s = sa(n._parsed[e].r, i.options.locale); return { label: r[e] || "", value: s } } parseObjectData(e, n, i, r) { return qb.bind(this)(e, n, i, r) } update(e) { const n = this._cachedMeta.data; this._updateRadius(), this.updateElements(n, 0, n.length, e) } getMinMax() { const e = this._cachedMeta, n = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }; return e.data.forEach((i, r) => { const s = this.getParsed(r).r; !isNaN(s) && this.chart.getDataVisibility(r) && (s < n.min && (n.min = s), s > n.max && (n.max = s)) }), n } _updateRadius() { const e = this.chart, n = e.chartArea, i = e.options, r = Math.min(n.right - n.left, n.bottom - n.top), s = Math.max(r / 2, 0), o = Math.max(i.cutoutPercentage ? s / 100 * i.cutoutPercentage : 1, 0), a = (s - o) / e.getVisibleDatasetCount(); this.outerRadius = s - a * this.index, this.innerRadius = this.outerRadius - a } updateElements(e, n, i, r) { const s = r === "reset", o = this.chart, l = o.options.animation, c = this._cachedMeta.rScale, u = c.xCenter, d = c.yCenter, f = c.getIndexAngle(0) - .5 * we; let h = f, m; const p = 360 / this.countVisibleElements(); for (m = 0; m < n; ++m)h += this._computeAngle(m, r, p); for (m = n; m < n + i; m++) { const x = e[m]; let y = h, g = h + this._computeAngle(m, r, p), v = o.getDataVisibility(m) ? c.getDistanceFromCenterForValue(this.getParsed(m).r) : 0; h = g, s && (l.animateScale && (v = 0), l.animateRotate && (y = g = f)); const b = { x: u, y: d, innerRadius: 0, outerRadius: v, startAngle: y, endAngle: g, options: this.resolveDataElementOptions(m, x.active ? "active" : r) }; this.updateElement(x, m, b, r) } } countVisibleElements() { const e = this._cachedMeta; let n = 0; return e.data.forEach((i, r) => { !isNaN(this.getParsed(r).r) && this.chart.getDataVisibility(r) && n++ }), n } _computeAngle(e, n, i) { return this.chart.getDataVisibility(e) ? Qt(this.resolveDataElementOptions(e, n).angle || i) : 0 } } F(so, "id", "polarArea"), F(so, "defaults", { dataElementType: "arc", animation: { animateRotate: !0, animateScale: !0 }, animations: { numbers: { type: "number", properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"] } }, indexAxis: "r", startAngle: 0 }), F(so, "overrides", { aspectRatio: 1, plugins: { legend: { labels: { generateLabels(e) { const n = e.data; if (n.labels.length && n.datasets.length) { const { labels: { pointStyle: i, color: r } } = e.legend.options; return n.labels.map((s, o) => { const l = e.getDatasetMeta(0).controller.getStyle(o); return { text: s, fillStyle: l.backgroundColor, strokeStyle: l.borderColor, fontColor: r, lineWidth: l.borderWidth, pointStyle: i, hidden: !e.getDataVisibility(o), index: o } }) } return [] } }, onClick(e, n, i) { i.chart.toggleDataVisibility(n.index), i.chart.update() } } }, scales: { r: { type: "radialLinear", angleLines: { display: !1 }, beginAtZero: !0, grid: { circular: !0 }, pointLabels: { display: !1 }, startAngle: 0 } } }); class Bf extends si { } F(Bf, "id", "pie"), F(Bf, "defaults", { cutout: 0, rotation: 0, circumference: 360, radius: "100%" }); class bl extends Jt { getLabelAndValue(e) { const n = this._cachedMeta.vScale, i = this.getParsed(e); return { label: n.getLabels()[e], value: "" + n.getLabelForValue(i[n.axis]) } } parseObjectData(e, n, i, r) { return qb.bind(this)(e, n, i, r) } update(e) { const n = this._cachedMeta, i = n.dataset, r = n.data || [], s = n.iScale.getLabels(); if (i.points = r, e !== "resize") { const o = this.resolveDatasetElementOptions(e); this.options.showLine || (o.borderWidth = 0); const a = { _loop: !0, _fullLoop: s.length === r.length, options: o }; this.updateElement(i, void 0, a, e) } this.updateElements(r, 0, r.length, e) } updateElements(e, n, i, r) { const s = this._cachedMeta.rScale, o = r === "reset"; for (let a = n; a < n + i; a++) { const l = e[a], c = this.resolveDataElementOptions(a, l.active ? "active" : r), u = s.getPointPositionForValue(a, this.getParsed(a).r), d = o ? s.xCenter : u.x, f = o ? s.yCenter : u.y, h = { x: d, y: f, angle: u.angle, skip: isNaN(d) || isNaN(f), options: c }; this.updateElement(l, a, h, r) } } } F(bl, "id", "radar"), F(bl, "defaults", { datasetElementType: "line", dataElementType: "point", indexAxis: "r", showLine: !0, elements: { line: { fill: "start" } } }), F(bl, "overrides", { aspectRatio: 1, scales: { r: { type: "radialLinear" } } }); class _l extends Jt { getLabelAndValue(e) { const n = this._cachedMeta, i = this.chart.data.labels || [], { xScale: r, yScale: s } = n, o = this.getParsed(e), a = r.getLabelForValue(o.x), l = s.getLabelForValue(o.y); return { label: i[e] || "", value: "(" + a + ", " + l + ")" } } update(e) { const n = this._cachedMeta, { data: i = [] } = n, r = this.chart._animationsDisabled; let { start: s, count: o } = Bb(n, i, r); if (this._drawStart = s, this._drawCount = o, Hb(n) && (s = 0, o = i.length), this.options.showLine) { const { dataset: a, _dataset: l } = n; a._chart = this.chart, a._datasetIndex = this.index, a._decimated = !!l._decimated, a.points = i; const c = this.resolveDatasetElementOptions(e); c.segment = this.options.segment, this.updateElement(a, void 0, { animated: !r, options: c }, e) } this.updateElements(i, s, o, e) } addElements() { const { showLine: e } = this.options; !this.datasetElementType && e && (this.datasetElementType = this.chart.registry.getElement("line")), super.addElements() } updateElements(e, n, i, r) { const s = r === "reset", { iScale: o, vScale: a, _stacked: l, _dataset: c } = this._cachedMeta, u = this.resolveDataElementOptions(n, r), d = this.getSharedOptions(u), f = this.includeOptions(r, d), h = o.axis, m = a.axis, { spanGaps: p, segment: x } = this.options, y = ts(p) ? p : Number.POSITIVE_INFINITY, g = this.chart._animationsDisabled || s || r === "none"; let v = n > 0 && this.getParsed(n - 1); for (let b = n; b < n + i; ++b) { const _ = e[b], k = this.getParsed(b), S = g ? _ : {}, P = te(k[m]), T = S[h] = o.getPixelForValue(k[h], b), D = S[m] = s || P ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, k, l) : k[m], b); S.skip = isNaN(T) || isNaN(D) || P, S.stop = b > 0 && Math.abs(k[h] - v[h]) > y, x && (S.parsed = k, S.raw = c.data[b]), f && (S.options = d || this.resolveDataElementOptions(b, _.active ? "active" : r)), g || this.updateElement(_, b, S, r), v = k } this.updateSharedOptions(d, r, u) } getMaxOverflow() { const e = this._cachedMeta, n = e.data || []; if (!this.options.showLine) { let a = 0; for (let l = n.length - 1; l >= 0; --l)a = Math.max(a, n[l].size(this.resolveDataElementOptions(l)) / 2); return a > 0 && a } const i = e.dataset, r = i.options && i.options.borderWidth || 0; if (!n.length) return r; const s = n[0].size(this.resolveDataElementOptions(0)), o = n[n.length - 1].size(this.resolveDataElementOptions(n.length - 1)); return Math.max(r, s, o) / 2 } } F(_l, "id", "scatter"), F(_l, "defaults", { datasetElementType: !1, dataElementType: "point", showLine: !1, fill: !1 }), F(_l, "overrides", { interaction: { mode: "point" }, scales: { x: { type: "linear" }, y: { type: "linear" } } }); var j3 = Object.freeze({ __proto__: null, BarController: vl, BubbleController: xl, DoughnutController: si, LineController: wl, PolarAreaController: so, PieController: Bf, RadarController: bl, ScatterController: _l }); function Ni() { throw new Error("This method is not implemented: Check that a complete date adapter is provided.") } class Bp { static override(e) { Object.assign(Bp.prototype, e) } constructor(e) { this.options = e || {} } init() { } formats() { return Ni() } parse() { return Ni() } format() { return Ni() } add() { return Ni() } diff() { return Ni() } startOf() { return Ni() } endOf() { return Ni() } } var A3 = { _date: Bp }; function N3(t, e, n, i) { const { controller: r, data: s, _sorted: o } = t, a = r._cachedMeta.iScale; if (a && e === a.axis && e !== "r" && o && s.length) { const l = a._reversePixels ? s5 : Ln; if (i) { if (r._sharedOptions) { const c = s[0], u = typeof c.getRange == "function" && c.getRange(e); if (u) { const d = l(s, e, n - u), f = l(s, e, n + u); return { lo: d.lo, hi: f.hi } } } } else return l(s, e, n) } return { lo: 0, hi: s.length - 1 } } function oa(t, e, n, i, r) { const s = t.getSortedVisibleDatasetMetas(), o = n[e]; for (let a = 0, l = s.length; a < l; ++a) { const { index: c, data: u } = s[a], { lo: d, hi: f } = N3(s[a], e, o, r); for (let h = d; h <= f; ++h) { const m = u[h]; m.skip || i(m, c, h) } } } function F3(t) { const e = t.indexOf("x") !== -1, n = t.indexOf("y") !== -1; return function (i, r) { const s = e ? Math.abs(i.x - r.x) : 0, o = n ? Math.abs(i.y - r.y) : 0; return Math.sqrt(Math.pow(s, 2) + Math.pow(o, 2)) } } function ad(t, e, n, i, r) { const s = []; return !r && !t.isPointInArea(e) || oa(t, n, e, function (a, l, c) { !r && !Fo(a, t.chartArea, 0) || a.inRange(e.x, e.y, i) && s.push({ element: a, datasetIndex: l, index: c }) }, !0), s } function I3(t, e, n, i) { let r = []; function s(o, a, l) { const { startAngle: c, endAngle: u } = o.getProps(["startAngle", "endAngle"], i), { angle: d } = Nb(o, { x: e.x, y: e.y }); No(d, c, u) && r.push({ element: o, datasetIndex: a, index: l }) } return oa(t, n, e, s), r } function V3(t, e, n, i, r, s) { let o = []; const a = F3(n); let l = Number.POSITIVE_INFINITY; function c(u, d, f) { const h = u.inRange(e.x, e.y, r); if (i && !h) return; const m = u.getCenterPoint(r); if (!(!!s || t.isPointInArea(m)) && !h) return; const x = a(e, m); x < l ? (o = [{ element: u, datasetIndex: d, index: f }], l = x) : x === l && o.push({ element: u, datasetIndex: d, index: f }) } return oa(t, n, e, c), o } function ld(t, e, n, i, r, s) { return !s && !t.isPointInArea(e) ? [] : n === "r" && !i ? I3(t, e, n, r) : V3(t, e, n, i, r, s) } function M0(t, e, n, i, r) { const s = [], o = n === "x" ? "inXRange" : "inYRange"; let a = !1; return oa(t, n, e, (l, c, u) => { l[o](e[n], r) && (s.push({ element: l, datasetIndex: c, index: u }), a = a || l.inRange(e.x, e.y, r)) }), i && !a ? [] : s } var z3 = { evaluateInteractionItems: oa, modes: { index(t, e, n, i) { const r = Hi(e, t), s = n.axis || "x", o = n.includeInvisible || !1, a = n.intersect ? ad(t, r, s, i, o) : ld(t, r, s, !1, i, o), l = []; return a.length ? (t.getSortedVisibleDatasetMetas().forEach(c => { const u = a[0].index, d = c.data[u]; d && !d.skip && l.push({ element: d, datasetIndex: c.index, index: u }) }), l) : [] }, dataset(t, e, n, i) { const r = Hi(e, t), s = n.axis || "xy", o = n.includeInvisible || !1; let a = n.intersect ? ad(t, r, s, i, o) : ld(t, r, s, !1, i, o); if (a.length > 0) { const l = a[0].datasetIndex, c = t.getDatasetMeta(l).data; a = []; for (let u = 0; u < c.length; ++u)a.push({ element: c[u], datasetIndex: l, index: u }) } return a }, point(t, e, n, i) { const r = Hi(e, t), s = n.axis || "xy", o = n.includeInvisible || !1; return ad(t, r, s, i, o) }, nearest(t, e, n, i) { const r = Hi(e, t), s = n.axis || "xy", o = n.includeInvisible || !1; return ld(t, r, s, n.intersect, i, o) }, x(t, e, n, i) { const r = Hi(e, t); return M0(t, r, "x", n.intersect, i) }, y(t, e, n, i) { const r = Hi(e, t); return M0(t, r, "y", n.intersect, i) } } }; const l_ = ["left", "top", "right", "bottom"]; function ks(t, e) { return t.filter(n => n.pos === e) } function T0(t, e) { return t.filter(n => l_.indexOf(n.pos) === -1 && n.box.axis === e) } function Ps(t, e) { return t.sort((n, i) => { const r = e ? i : n, s = e ? n : i; return r.weight === s.weight ? r.index - s.index : r.weight - s.weight }) } function B3(t) { const e = []; let n, i, r, s, o, a; for (n = 0, i = (t || []).length; n < i; ++n)r = t[n], { position: s, options: { stack: o, stackWeight: a = 1 } } = r, e.push({ index: n, box: r, pos: s, horizontal: r.isHorizontal(), weight: r.weight, stack: o && s + o, stackWeight: a }); return e } function H3(t) { const e = {}; for (const n of t) { const { stack: i, pos: r, stackWeight: s } = n; if (!i || !l_.includes(r)) continue; const o = e[i] || (e[i] = { count: 0, placed: 0, weight: 0, size: 0 }); o.count++, o.weight += s } return e } function W3(t, e) { const n = H3(t), { vBoxMaxWidth: i, hBoxMaxHeight: r } = e; let s, o, a; for (s = 0, o = t.length; s < o; ++s) { a = t[s]; const { fullSize: l } = a.box, c = n[a.stack], u = c && a.stackWeight / c.weight; a.horizontal ? (a.width = u ? u * i : l && e.availableWidth, a.height = r) : (a.width = i, a.height = u ? u * r : l && e.availableHeight) } return n } function $3(t) { const e = B3(t), n = Ps(e.filter(c => c.box.fullSize), !0), i = Ps(ks(e, "left"), !0), r = Ps(ks(e, "right")), s = Ps(ks(e, "top"), !0), o = Ps(ks(e, "bottom")), a = T0(e, "x"), l = T0(e, "y"); return { fullSize: n, leftAndTop: i.concat(s), rightAndBottom: r.concat(l).concat(o).concat(a), chartArea: ks(e, "chartArea"), vertical: i.concat(r).concat(l), horizontal: s.concat(o).concat(a) } } function E0(t, e, n, i) { return Math.max(t[n], e[n]) + Math.max(t[i], e[i]) } function c_(t, e) { t.top = Math.max(t.top, e.top), t.left = Math.max(t.left, e.left), t.bottom = Math.max(t.bottom, e.bottom), t.right = Math.max(t.right, e.right) } function U3(t, e, n, i) { const { pos: r, box: s } = n, o = t.maxPadding; if (!ne(r)) { n.size && (t[r] -= n.size); const d = i[n.stack] || { size: 0, count: 1 }; d.size = Math.max(d.size, n.horizontal ? s.height : s.width), n.size = d.size / d.count, t[r] += n.size } s.getPadding && c_(o, s.getPadding()); const a = Math.max(0, e.outerWidth - E0(o, t, "left", "right")), l = Math.max(0, e.outerHeight - E0(o, t, "top", "bottom")), c = a !== t.w, u = l !== t.h; return t.w = a, t.h = l, n.horizontal ? { same: c, other: u } : { same: u, other: c } } function Y3(t) { const e = t.maxPadding; function n(i) { const r = Math.max(e[i] - t[i], 0); return t[i] += r, r } t.y += n("top"), t.x += n("left"), n("right"), n("bottom") } function K3(t, e) { const n = e.maxPadding; function i(r) { const s = { left: 0, top: 0, right: 0, bottom: 0 }; return r.forEach(o => { s[o] = Math.max(e[o], n[o]) }), s } return i(t ? ["left", "right"] : ["top", "bottom"]) } function As(t, e, n, i) { const r = []; let s, o, a, l, c, u; for (s = 0, o = t.length, c = 0; s < o; ++s) { a = t[s], l = a.box, l.update(a.width || e.w, a.height || e.h, K3(a.horizontal, e)); const { same: d, other: f } = U3(e, n, a, i); c |= d && r.length, u = u || f, l.fullSize || r.push(a) } return c && As(r, e, n, i) || u } function Ua(t, e, n, i, r) { t.top = n, t.left = e, t.right = e + i, t.bottom = n + r, t.width = i, t.height = r } function D0(t, e, n, i) { const r = n.padding; let { x: s, y: o } = e; for (const a of t) { const l = a.box, c = i[a.stack] || { count: 1, placed: 0, weight: 1 }, u = a.stackWeight / c.weight || 1; if (a.horizontal) { const d = e.w * u, f = c.size || l.height; Wt(c.start) && (o = c.start), l.fullSize ? Ua(l, r.left, o, n.outerWidth - r.right - r.left, f) : Ua(l, e.left + c.placed, o, d, f), c.start = o, c.placed += d, o = l.bottom } else { const d = e.h * u, f = c.size || l.width; Wt(c.start) && (s = c.start), l.fullSize ? Ua(l, s, r.top, f, n.outerHeight - r.bottom - r.top) : Ua(l, s, e.top + c.placed, f, d), c.start = s, c.placed += d, s = l.right } } e.x = s, e.y = o } var at = { addBox(t, e) { t.boxes || (t.boxes = []), e.fullSize = e.fullSize || !1, e.position = e.position || "top", e.weight = e.weight || 0, e._layers = e._layers || function () { return [{ z: 0, draw(n) { e.draw(n) } }] }, t.boxes.push(e) }, removeBox(t, e) { const n = t.boxes ? t.boxes.indexOf(e) : -1; n !== -1 && t.boxes.splice(n, 1) }, configure(t, e, n) { e.fullSize = n.fullSize, e.position = n.position, e.weight = n.weight }, update(t, e, n, i) { if (!t) return; const r = Je(t.options.layout.padding), s = Math.max(e - r.width, 0), o = Math.max(n - r.height, 0), a = $3(t.boxes), l = a.vertical, c = a.horizontal; ce(t.boxes, p => { typeof p.beforeLayout == "function" && p.beforeLayout() }); const u = l.reduce((p, x) => x.box.options && x.box.options.display === !1 ? p : p + 1, 0) || 1, d = Object.freeze({ outerWidth: e, outerHeight: n, padding: r, availableWidth: s, availableHeight: o, vBoxMaxWidth: s / 2 / u, hBoxMaxHeight: o / 2 }), f = Object.assign({}, r); c_(f, Je(i)); const h = Object.assign({ maxPadding: f, w: s, h: o, x: r.left, y: r.top }, r), m = W3(l.concat(c), d); As(a.fullSize, h, d, m), As(l, h, d, m), As(c, h, d, m) && As(l, h, d, m), Y3(h), D0(a.leftAndTop, h, d, m), h.x += h.w, h.y += h.h, D0(a.rightAndBottom, h, d, m), t.chartArea = { left: h.left, top: h.top, right: h.left + h.w, bottom: h.top + h.h, height: h.h, width: h.w }, ce(a.chartArea, p => { const x = p.box; Object.assign(x, t.chartArea), x.update(h.w, h.h, { left: 0, top: 0, right: 0, bottom: 0 }) }) } }; class u_ { acquireContext(e, n) { } releaseContext(e) { return !1 } addEventListener(e, n, i) { } removeEventListener(e, n, i) { } getDevicePixelRatio() { return 1 } getMaximumSize(e, n, i, r) { return n = Math.max(0, n || e.width), i = i || e.height, { width: n, height: Math.max(0, r ? Math.floor(n / r) : i) } } isAttached(e) { return !0 } updateConfig(e) { } } class X3 extends u_ { acquireContext(e) { return e && e.getContext && e.getContext("2d") || null } updateConfig(e) { e.options.animation = !1 } } const Sl = "$chartjs", G3 = { touchstart: "mousedown", touchmove: "mousemove", touchend: "mouseup", pointerenter: "mouseenter", pointerdown: "mousedown", pointermove: "mousemove", pointerup: "mouseup", pointerleave: "mouseout", pointerout: "mouseout" }, O0 = t => t === null || t === ""; function Q3(t, e) { const n = t.style, i = t.getAttribute("height"), r = t.getAttribute("width"); if (t[Sl] = { initial: { height: i, width: r, style: { display: n.display, height: n.height, width: n.width } } }, n.display = n.display || "block", n.boxSizing = n.boxSizing || "border-box", O0(r)) { const s = h0(t, "width"); s !== void 0 && (t.width = s) } if (O0(i)) if (t.style.height === "") t.height = t.width / (e || 2); else { const s = h0(t, "height"); s !== void 0 && (t.height = s) } return t } const d_ = Z5 ? { passive: !0 } : !1; function q3(t, e, n) { t.addEventListener(e, n, d_) } function Z3(t, e, n) { t.canvas.removeEventListener(e, n, d_) } function J3(t, e) { const n = G3[t.type] || t.type, { x: i, y: r } = Hi(t, e); return { type: n, chart: e, native: t, x: i !== void 0 ? i : null, y: r !== void 0 ? r : null } } function fc(t, e) { for (const n of t) if (n === e || n.contains(e)) return !0 } function eR(t, e, n) { const i = t.canvas, r = new MutationObserver(s => { let o = !1; for (const a of s) o = o || fc(a.addedNodes, i), o = o && !fc(a.removedNodes, i); o && n() }); return r.observe(document, { childList: !0, subtree: !0 }), r } function tR(t, e, n) { const i = t.canvas, r = new MutationObserver(s => { let o = !1; for (const a of s) o = o || fc(a.removedNodes, i), o = o && !fc(a.addedNodes, i); o && n() }); return r.observe(document, { childList: !0, subtree: !0 }), r } const Vo = new Map; let R0 = 0; function f_() { const t = window.devicePixelRatio; t !== R0 && (R0 = t, Vo.forEach((e, n) => { n.currentDevicePixelRatio !== t && e() })) } function nR(t, e) { Vo.size || window.addEventListener("resize", f_), Vo.set(t, e) } function iR(t) { Vo.delete(t), Vo.size || window.removeEventListener("resize", f_) } function rR(t, e, n) { const i = t.canvas, r = i && zp(i); if (!r) return; const s = zb((a, l) => { const c = r.clientWidth; n(a, l), c < r.clientWidth && n() }, window), o = new ResizeObserver(a => { const l = a[0], c = l.contentRect.width, u = l.contentRect.height; c === 0 && u === 0 || s(c, u) }); return o.observe(r), nR(t, s), o } function cd(t, e, n) { n && n.disconnect(), e === "resize" && iR(t) } function sR(t, e, n) { const i = t.canvas, r = zb(s => { t.ctx !== null && n(J3(s, t)) }, t); return q3(i, e, r), r } class oR extends u_ { acquireContext(e, n) { const i = e && e.getContext && e.getContext("2d"); return i && i.canvas === e ? (Q3(e, n), i) : null } releaseContext(e) { const n = e.canvas; if (!n[Sl]) return !1; const i = n[Sl].initial;["height", "width"].forEach(s => { const o = i[s]; te(o) ? n.removeAttribute(s) : n.setAttribute(s, o) }); const r = i.style || {}; return Object.keys(r).forEach(s => { n.style[s] = r[s] }), n.width = n.width, delete n[Sl], !0 } addEventListener(e, n, i) { this.removeEventListener(e, n); const r = e.$proxies || (e.$proxies = {}), o = { attach: eR, detach: tR, resize: rR }[n] || sR; r[n] = o(e, n, i) } removeEventListener(e, n) { const i = e.$proxies || (e.$proxies = {}), r = i[n]; if (!r) return; ({ attach: cd, detach: cd, resize: cd }[n] || Z3)(e, n, r), i[n] = void 0 } getDevicePixelRatio() { return window.devicePixelRatio } getMaximumSize(e, n, i, r) { return q5(e, n, i, r) } isAttached(e) { const n = zp(e); return !!(n && n.isConnected) } } function aR(t) { return !Jb() || typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas ? X3 : oR } var rl; let Wn = (rl = class { constructor() { F(this, "active", !1) } tooltipPosition(e) { const { x: n, y: i } = this.getProps(["x", "y"], e); return { x: n, y: i } } hasValue() { return ts(this.x) && ts(this.y) } getProps(e, n) { const i = this.$animations; if (!n || !i) return this; const r = {}; return e.forEach(s => { r[s] = i[s] && i[s].active() ? i[s]._to : this[s] }), r } }, F(rl, "defaults", {}), F(rl, "defaultRoutes"), rl); function lR(t, e) { const n = t.options.ticks, i = cR(t), r = Math.min(n.maxTicksLimit || i, i), s = n.major.enabled ? dR(e) : [], o = s.length, a = s[0], l = s[o - 1], c = []; if (o > r) return fR(e, c, s, o / r), c; const u = uR(s, e, r); if (o > 0) { let d, f; const h = o > 1 ? Math.round((l - a) / (o - 1)) : null; for (Ya(e, c, u, te(h) ? 0 : a - h, a), d = 0, f = o - 1; d < f; d++)Ya(e, c, u, s[d], s[d + 1]); return Ya(e, c, u, l, te(h) ? e.length : l + h), c } return Ya(e, c, u), c } function cR(t) { const e = t.options.offset, n = t._tickSize(), i = t._length / n + (e ? 0 : 1), r = t._maxLength / n; return Math.floor(Math.min(i, r)) } function uR(t, e, n) { const i = hR(t), r = e.length / n; if (!i) return Math.max(r, 1); const s = t5(i); for (let o = 0, a = s.length - 1; o < a; o++) { const l = s[o]; if (l > r) return l } return Math.max(r, 1) } function dR(t) { const e = []; let n, i; for (n = 0, i = t.length; n < i; n++)t[n].major && e.push(n); return e } function fR(t, e, n, i) { let r = 0, s = n[0], o; for (i = Math.ceil(i), o = 0; o < t.length; o++)o === s && (e.push(t[o]), r++, s = n[r * i]) } function Ya(t, e, n, i, r) { const s = Q(i, 0), o = Math.min(Q(r, t.length), t.length); let a = 0, l, c, u; for (n = Math.ceil(n), r && (l = r - i, n = l / Math.floor(l / n)), u = s; u < 0;)a++, u = Math.round(s + a * n); for (c = Math.max(s, 0); c < o; c++)c === u && (e.push(t[c]), a++, u = Math.round(s + a * n)) } function hR(t) { const e = t.length; let n, i; if (e < 2) return !1; for (i = t[0], n = 1; n < e; ++n)if (t[n] - t[n - 1] !== i) return !1; return i } const pR = t => t === "left" ? "right" : t === "right" ? "left" : t, L0 = (t, e, n) => e === "top" || e === "left" ? t[e] + n : t[e] - n, j0 = (t, e) => Math.min(e || t, t); function A0(t, e) { const n = [], i = t.length / e, r = t.length; let s = 0; for (; s < r; s += i)n.push(t[Math.floor(s)]); return n } function mR(t, e, n) { const i = t.ticks.length, r = Math.min(e, i - 1), s = t._startPixel, o = t._endPixel, a = 1e-6; let l = t.getPixelForTick(r), c; if (!(n && (i === 1 ? c = Math.max(l - s, o - l) : e === 0 ? c = (t.getPixelForTick(1) - l) / 2 : c = (l - t.getPixelForTick(r - 1)) / 2, l += r < e ? c : -c, l < s - a || l > o + a))) return l } function gR(t, e) { ce(t, n => { const i = n.gc, r = i.length / 2; let s; if (r > e) { for (s = 0; s < r; ++s)delete n.data[i[s]]; i.splice(0, r) } }) } function Cs(t) { return t.drawTicks ? t.tickLength : 0 } function N0(t, e) { if (!t.display) return 0; const n = ze(t.font, e), i = Je(t.padding); return (me(t.text) ? t.text.length : 1) * n.lineHeight + i.height } function yR(t, e) { return Di(t, { scale: e, type: "scale" }) } function vR(t, e, n) { return Di(t, { tick: n, index: e, type: "tick" }) } function xR(t, e, n) { let i = Ap(t); return (n && e !== "right" || !n && e === "right") && (i = pR(i)), i } function wR(t, e, n, i) { const { top: r, left: s, bottom: o, right: a, chart: l } = t, { chartArea: c, scales: u } = l; let d = 0, f, h, m; const p = o - r, x = a - s; if (t.isHorizontal()) { if (h = rt(i, s, a), ne(n)) { const y = Object.keys(n)[0], g = n[y]; m = u[y].getPixelForValue(g) + p - e } else n === "center" ? m = (c.bottom + c.top) / 2 + p - e : m = L0(t, n, e); f = a - s } else { if (ne(n)) { const y = Object.keys(n)[0], g = n[y]; h = u[y].getPixelForValue(g) - x + e } else n === "center" ? h = (c.left + c.right) / 2 - x + e : h = L0(t, n, e); m = rt(i, o, r), d = n === "left" ? -Re : Re } return { titleX: h, titleY: m, maxWidth: f, rotation: d } } class pr extends Wn { constructor(e) { super(), this.id = e.id, this.type = e.type, this.options = void 0, this.ctx = e.ctx, this.chart = e.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = { left: 0, right: 0, top: 0, bottom: 0 }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0 } init(e) { this.options = e.setContext(this.getContext()), this.axis = e.axis, this._userMin = this.parse(e.min), this._userMax = this.parse(e.max), this._suggestedMin = this.parse(e.suggestedMin), this._suggestedMax = this.parse(e.suggestedMax) } parse(e, n) { return e } getUserBounds() { let { _userMin: e, _userMax: n, _suggestedMin: i, _suggestedMax: r } = this; return e = Pt(e, Number.POSITIVE_INFINITY), n = Pt(n, Number.NEGATIVE_INFINITY), i = Pt(i, Number.POSITIVE_INFINITY), r = Pt(r, Number.NEGATIVE_INFINITY), { min: Pt(e, i), max: Pt(n, r), minDefined: Oe(e), maxDefined: Oe(n) } } getMinMax(e) { let { min: n, max: i, minDefined: r, maxDefined: s } = this.getUserBounds(), o; if (r && s) return { min: n, max: i }; const a = this.getMatchingVisibleMetas(); for (let l = 0, c = a.length; l < c; ++l)o = a[l].controller.getMinMax(this, e), r || (n = Math.min(n, o.min)), s || (i = Math.max(i, o.max)); return n = s && n > i ? i : n, i = r && n > i ? n : i, { min: Pt(n, Pt(i, n)), max: Pt(i, Pt(n, i)) } } getPadding() { return { left: this.paddingLeft || 0, top: this.paddingTop || 0, right: this.paddingRight || 0, bottom: this.paddingBottom || 0 } } getTicks() { return this.ticks } getLabels() { const e = this.chart.data; return this.options.labels || (this.isHorizontal() ? e.xLabels : e.yLabels) || e.labels || [] } getLabelItems(e = this.chart.chartArea) { return this._labelItems || (this._labelItems = this._computeLabelItems(e)) } beforeLayout() { this._cache = {}, this._dataLimitsCached = !1 } beforeUpdate() { de(this.options.beforeUpdate, [this]) } update(e, n, i) { const { beginAtZero: r, grace: s, ticks: o } = this.options, a = o.sampleSize; this.beforeUpdate(), this.maxWidth = e, this.maxHeight = n, this._margins = i = Object.assign({ left: 0, right: 0, top: 0, bottom: 0 }, i), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = E5(this, s, r), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks(); const l = a < this.ticks.length; this._convertTicksToLabels(l ? A0(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || o.source === "auto") && (this.ticks = lR(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate() } configure() { let e = this.options.reverse, n, i; this.isHorizontal() ? (n = this.left, i = this.right) : (n = this.top, i = this.bottom, e = !e), this._startPixel = n, this._endPixel = i, this._reversePixels = e, this._length = i - n, this._alignToPixels = this.options.alignToPixels } afterUpdate() { de(this.options.afterUpdate, [this]) } beforeSetDimensions() { de(this.options.beforeSetDimensions, [this]) } setDimensions() { this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0 } afterSetDimensions() { de(this.options.afterSetDimensions, [this]) } _callHooks(e) { this.chart.notifyPlugins(e, this.getContext()), de(this.options[e], [this]) } beforeDataLimits() { this._callHooks("beforeDataLimits") } determineDataLimits() { } afterDataLimits() { this._callHooks("afterDataLimits") } beforeBuildTicks() { this._callHooks("beforeBuildTicks") } buildTicks() { return [] } afterBuildTicks() { this._callHooks("afterBuildTicks") } beforeTickToLabelConversion() { de(this.options.beforeTickToLabelConversion, [this]) } generateTickLabels(e) { const n = this.options.ticks; let i, r, s; for (i = 0, r = e.length; i < r; i++)s = e[i], s.label = de(n.callback, [s.value, i, e], this) } afterTickToLabelConversion() { de(this.options.afterTickToLabelConversion, [this]) } beforeCalculateLabelRotation() { de(this.options.beforeCalculateLabelRotation, [this]) } calculateLabelRotation() { const e = this.options, n = e.ticks, i = j0(this.ticks.length, e.ticks.maxTicksLimit), r = n.minRotation || 0, s = n.maxRotation; let o = r, a, l, c; if (!this._isVisible() || !n.display || r >= s || i <= 1 || !this.isHorizontal()) { this.labelRotation = r; return } const u = this._getLabelSizes(), d = u.widest.width, f = u.highest.height, h = Xe(this.chart.width - d, 0, this.maxWidth); a = e.offset ? this.maxWidth / i : h / (i - 1), d + 6 > a && (a = h / (i - (e.offset ? .5 : 1)), l = this.maxHeight - Cs(e.grid) - n.padding - N0(e.title, this.chart.options.font), c = Math.sqrt(d * d + f * f), o = Lp(Math.min(Math.asin(Xe((u.highest.height + 6) / a, -1, 1)), Math.asin(Xe(l / c, -1, 1)) - Math.asin(Xe(f / c, -1, 1)))), o = Math.max(r, Math.min(s, o))), this.labelRotation = o } afterCalculateLabelRotation() { de(this.options.afterCalculateLabelRotation, [this]) } afterAutoSkip() { } beforeFit() { de(this.options.beforeFit, [this]) } fit() { const e = { width: 0, height: 0 }, { chart: n, options: { ticks: i, title: r, grid: s } } = this, o = this._isVisible(), a = this.isHorizontal(); if (o) { const l = N0(r, n.options.font); if (a ? (e.width = this.maxWidth, e.height = Cs(s) + l) : (e.height = this.maxHeight, e.width = Cs(s) + l), i.display && this.ticks.length) { const { first: c, last: u, widest: d, highest: f } = this._getLabelSizes(), h = i.padding * 2, m = Qt(this.labelRotation), p = Math.cos(m), x = Math.sin(m); if (a) { const y = i.mirror ? 0 : x * d.width + p * f.height; e.height = Math.min(this.maxHeight, e.height + y + h) } else { const y = i.mirror ? 0 : p * d.width + x * f.height; e.width = Math.min(this.maxWidth, e.width + y + h) } this._calculatePadding(c, u, x, p) } } this._handleMargins(), a ? (this.width = this._length = n.width - this._margins.left - this._margins.right, this.height = e.height) : (this.width = e.width, this.height = this._length = n.height - this._margins.top - this._margins.bottom) } _calculatePadding(e, n, i, r) { const { ticks: { align: s, padding: o }, position: a } = this.options, l = this.labelRotation !== 0, c = a !== "top" && this.axis === "x"; if (this.isHorizontal()) { const u = this.getPixelForTick(0) - this.left, d = this.right - this.getPixelForTick(this.ticks.length - 1); let f = 0, h = 0; l ? c ? (f = r * e.width, h = i * n.height) : (f = i * e.height, h = r * n.width) : s === "start" ? h = n.width : s === "end" ? f = e.width : s !== "inner" && (f = e.width / 2, h = n.width / 2), this.paddingLeft = Math.max((f - u + o) * this.width / (this.width - u), 0), this.paddingRight = Math.max((h - d + o) * this.width / (this.width - d), 0) } else { let u = n.height / 2, d = e.height / 2; s === "start" ? (u = 0, d = e.height) : s === "end" && (u = n.height, d = 0), this.paddingTop = u + o, this.paddingBottom = d + o } } _handleMargins() { this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom)) } afterFit() { de(this.options.afterFit, [this]) } isHorizontal() { const { axis: e, position: n } = this.options; return n === "top" || n === "bottom" || e === "x" } isFullSize() { return this.options.fullSize } _convertTicksToLabels(e) { this.beforeTickToLabelConversion(), this.generateTickLabels(e); let n, i; for (n = 0, i = e.length; n < i; n++)te(e[n].label) && (e.splice(n, 1), i--, n--); this.afterTickToLabelConversion() } _getLabelSizes() { let e = this._labelSizes; if (!e) { const n = this.options.ticks.sampleSize; let i = this.ticks; n < i.length && (i = A0(i, n)), this._labelSizes = e = this._computeLabelSizes(i, i.length, this.options.ticks.maxTicksLimit) } return e } _computeLabelSizes(e, n, i) { const { ctx: r, _longestTextCache: s } = this, o = [], a = [], l = Math.floor(n / j0(n, i)); let c = 0, u = 0, d, f, h, m, p, x, y, g, v, b, _; for (d = 0; d < n; d += l) { if (m = e[d].label, p = this._resolveTickFontOptions(d), r.font = x = p.string, y = s[x] = s[x] || { data: {}, gc: [] }, g = p.lineHeight, v = b = 0, !te(m) && !me(m)) v = uc(r, y.data, y.gc, v, m), b = g; else if (me(m)) for (f = 0, h = m.length; f < h; ++f)_ = m[f], !te(_) && !me(_) && (v = uc(r, y.data, y.gc, v, _), b += g); o.push(v), a.push(b), c = Math.max(v, c), u = Math.max(b, u) } gR(s, n); const k = o.indexOf(c), S = a.indexOf(u), P = T => ({ width: o[T] || 0, height: a[T] || 0 }); return { first: P(0), last: P(n - 1), widest: P(k), highest: P(S), widths: o, heights: a } } getLabelForValue(e) { return e } getPixelForValue(e, n) { return NaN } getValueForPixel(e) { } getPixelForTick(e) { const n = this.ticks; return e < 0 || e > n.length - 1 ? null : this.getPixelForValue(n[e].value) } getPixelForDecimal(e) { this._reversePixels && (e = 1 - e); const n = this._startPixel + e * this._length; return r5(this._alignToPixels ? Ai(this.chart, n, 0) : n) } getDecimalForPixel(e) { const n = (e - this._startPixel) / this._length; return this._reversePixels ? 1 - n : n } getBasePixel() { return this.getPixelForValue(this.getBaseValue()) } getBaseValue() { const { min: e, max: n } = this; return e < 0 && n < 0 ? n : e > 0 && n > 0 ? e : 0 } getContext(e) { const n = this.ticks || []; if (e >= 0 && e < n.length) { const i = n[e]; return i.$context || (i.$context = vR(this.getContext(), e, i)) } return this.$context || (this.$context = yR(this.chart.getContext(), this)) } _tickSize() { const e = this.options.ticks, n = Qt(this.labelRotation), i = Math.abs(Math.cos(n)), r = Math.abs(Math.sin(n)), s = this._getLabelSizes(), o = e.autoSkipPadding || 0, a = s ? s.widest.width + o : 0, l = s ? s.highest.height + o : 0; return this.isHorizontal() ? l * i > a * r ? a / i : l / r : l * r < a * i ? l / i : a / r } _isVisible() { const e = this.options.display; return e !== "auto" ? !!e : this.getMatchingVisibleMetas().length > 0 } _computeGridLineItems(e) { const n = this.axis, i = this.chart, r = this.options, { grid: s, position: o, border: a } = r, l = s.offset, c = this.isHorizontal(), d = this.ticks.length + (l ? 1 : 0), f = Cs(s), h = [], m = a.setContext(this.getContext()), p = m.display ? m.width : 0, x = p / 2, y = function (J) { return Ai(i, J, p) }; let g, v, b, _, k, S, P, T, D, A, V, q; if (o === "top") g = y(this.bottom), S = this.bottom - f, T = g - x, A = y(e.top) + x, q = e.bottom; else if (o === "bottom") g = y(this.top), A = e.top, q = y(e.bottom) - x, S = g + x, T = this.top + f; else if (o === "left") g = y(this.right), k = this.right - f, P = g - x, D = y(e.left) + x, V = e.right; else if (o === "right") g = y(this.left), D = e.left, V = y(e.right) - x, k = g + x, P = this.left + f; else if (n === "x") { if (o === "center") g = y((e.top + e.bottom) / 2 + .5); else if (ne(o)) { const J = Object.keys(o)[0], re = o[J]; g = y(this.chart.scales[J].getPixelForValue(re)) } A = e.top, q = e.bottom, S = g + x, T = S + f } else if (n === "y") { if (o === "center") g = y((e.left + e.right) / 2); else if (ne(o)) { const J = Object.keys(o)[0], re = o[J]; g = y(this.chart.scales[J].getPixelForValue(re)) } k = g - x, P = k - f, D = e.left, V = e.right } const G = Q(r.ticks.maxTicksLimit, d), z = Math.max(1, Math.ceil(d / G)); for (v = 0; v < d; v += z) { const J = this.getContext(v), re = s.setContext(J), L = a.setContext(J), j = re.lineWidth, W = re.color, Y = L.dash || [], ae = L.dashOffset, Te = re.tickWidth, je = re.tickColor, mt = re.tickBorderDash || [], $e = re.tickBorderDashOffset; b = mR(this, v, l), b !== void 0 && (_ = Ai(i, b, j), c ? k = P = D = V = _ : S = T = A = q = _, h.push({ tx1: k, ty1: S, tx2: P, ty2: T, x1: D, y1: A, x2: V, y2: q, width: j, color: W, borderDash: Y, borderDashOffset: ae, tickWidth: Te, tickColor: je, tickBorderDash: mt, tickBorderDashOffset: $e })) } return this._ticksLength = d, this._borderValue = g, h } _computeLabelItems(e) { const n = this.axis, i = this.options, { position: r, ticks: s } = i, o = this.isHorizontal(), a = this.ticks, { align: l, crossAlign: c, padding: u, mirror: d } = s, f = Cs(i.grid), h = f + u, m = d ? -u : h, p = -Qt(this.labelRotation), x = []; let y, g, v, b, _, k, S, P, T, D, A, V, q = "middle"; if (r === "top") k = this.bottom - m, S = this._getXAxisLabelAlignment(); else if (r === "bottom") k = this.top + m, S = this._getXAxisLabelAlignment(); else if (r === "left") { const z = this._getYAxisLabelAlignment(f); S = z.textAlign, _ = z.x } else if (r === "right") { const z = this._getYAxisLabelAlignment(f); S = z.textAlign, _ = z.x } else if (n === "x") { if (r === "center") k = (e.top + e.bottom) / 2 + h; else if (ne(r)) { const z = Object.keys(r)[0], J = r[z]; k = this.chart.scales[z].getPixelForValue(J) + h } S = this._getXAxisLabelAlignment() } else if (n === "y") { if (r === "center") _ = (e.left + e.right) / 2 - h; else if (ne(r)) { const z = Object.keys(r)[0], J = r[z]; _ = this.chart.scales[z].getPixelForValue(J) } S = this._getYAxisLabelAlignment(f).textAlign } n === "y" && (l === "start" ? q = "top" : l === "end" && (q = "bottom")); const G = this._getLabelSizes(); for (y = 0, g = a.length; y < g; ++y) { v = a[y], b = v.label; const z = s.setContext(this.getContext(y)); P = this.getPixelForTick(y) + s.labelOffset, T = this._resolveTickFontOptions(y), D = T.lineHeight, A = me(b) ? b.length : 1; const J = A / 2, re = z.color, L = z.textStrokeColor, j = z.textStrokeWidth; let W = S; o ? (_ = P, S === "inner" && (y === g - 1 ? W = this.options.reverse ? "left" : "right" : y === 0 ? W = this.options.reverse ? "right" : "left" : W = "center"), r === "top" ? c === "near" || p !== 0 ? V = -A * D + D / 2 : c === "center" ? V = -G.highest.height / 2 - J * D + D : V = -G.highest.height + D / 2 : c === "near" || p !== 0 ? V = D / 2 : c === "center" ? V = G.highest.height / 2 - J * D : V = G.highest.height - A * D, d && (V *= -1), p !== 0 && !z.showLabelBackdrop && (_ += D / 2 * Math.sin(p))) : (k = P, V = (1 - A) * D / 2); let Y; if (z.showLabelBackdrop) { const ae = Je(z.backdropPadding), Te = G.heights[y], je = G.widths[y]; let mt = V - ae.top, $e = 0 - ae.left; switch (q) { case "middle": mt -= Te / 2; break; case "bottom": mt -= Te; break }switch (S) { case "center": $e -= je / 2; break; case "right": $e -= je; break }Y = { left: $e, top: mt, width: je + ae.width, height: Te + ae.height, color: z.backdropColor } } x.push({ label: b, font: T, textOffset: V, options: { rotation: p, color: re, strokeColor: L, strokeWidth: j, textAlign: W, textBaseline: q, translation: [_, k], backdrop: Y } }) } return x } _getXAxisLabelAlignment() { const { position: e, ticks: n } = this.options; if (-Qt(this.labelRotation)) return e === "top" ? "left" : "right"; let r = "center"; return n.align === "start" ? r = "left" : n.align === "end" ? r = "right" : n.align === "inner" && (r = "inner"), r } _getYAxisLabelAlignment(e) { const { position: n, ticks: { crossAlign: i, mirror: r, padding: s } } = this.options, o = this._getLabelSizes(), a = e + s, l = o.widest.width; let c, u; return n === "left" ? r ? (u = this.right + s, i === "near" ? c = "left" : i === "center" ? (c = "center", u += l / 2) : (c = "right", u += l)) : (u = this.right - a, i === "near" ? c = "right" : i === "center" ? (c = "center", u -= l / 2) : (c = "left", u = this.left)) : n === "right" ? r ? (u = this.left + s, i === "near" ? c = "right" : i === "center" ? (c = "center", u -= l / 2) : (c = "left", u -= l)) : (u = this.left + a, i === "near" ? c = "left" : i === "center" ? (c = "center", u += l / 2) : (c = "right", u = this.right)) : c = "right", { textAlign: c, x: u } } _computeLabelArea() { if (this.options.ticks.mirror) return; const e = this.chart, n = this.options.position; if (n === "left" || n === "right") return { top: 0, left: this.left, bottom: e.height, right: this.right }; if (n === "top" || n === "bottom") return { top: this.top, left: 0, bottom: this.bottom, right: e.width } } drawBackground() { const { ctx: e, options: { backgroundColor: n }, left: i, top: r, width: s, height: o } = this; n && (e.save(), e.fillStyle = n, e.fillRect(i, r, s, o), e.restore()) } getLineWidthForValue(e) { const n = this.options.grid; if (!this._isVisible() || !n.display) return 0; const r = this.ticks.findIndex(s => s.value === e); return r >= 0 ? n.setContext(this.getContext(r)).lineWidth : 0 } drawGrid(e) { const n = this.options.grid, i = this.ctx, r = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(e)); let s, o; const a = (l, c, u) => { !u.width || !u.color || (i.save(), i.lineWidth = u.width, i.strokeStyle = u.color, i.setLineDash(u.borderDash || []), i.lineDashOffset = u.borderDashOffset, i.beginPath(), i.moveTo(l.x, l.y), i.lineTo(c.x, c.y), i.stroke(), i.restore()) }; if (n.display) for (s = 0, o = r.length; s < o; ++s) { const l = r[s]; n.drawOnChartArea && a({ x: l.x1, y: l.y1 }, { x: l.x2, y: l.y2 }, l), n.drawTicks && a({ x: l.tx1, y: l.ty1 }, { x: l.tx2, y: l.ty2 }, { color: l.tickColor, width: l.tickWidth, borderDash: l.tickBorderDash, borderDashOffset: l.tickBorderDashOffset }) } } drawBorder() { const { chart: e, ctx: n, options: { border: i, grid: r } } = this, s = i.setContext(this.getContext()), o = i.display ? s.width : 0; if (!o) return; const a = r.setContext(this.getContext(0)).lineWidth, l = this._borderValue; let c, u, d, f; this.isHorizontal() ? (c = Ai(e, this.left, o) - o / 2, u = Ai(e, this.right, a) + a / 2, d = f = l) : (d = Ai(e, this.top, o) - o / 2, f = Ai(e, this.bottom, a) + a / 2, c = u = l), n.save(), n.lineWidth = s.width, n.strokeStyle = s.color, n.beginPath(), n.moveTo(c, d), n.lineTo(u, f), n.stroke(), n.restore() } drawLabels(e) { if (!this.options.ticks.display) return; const i = this.ctx, r = this._computeLabelArea(); r && Zc(i, r); const s = this.getLabelItems(e); for (const o of s) { const a = o.options, l = o.font, c = o.label, u = o.textOffset; cr(i, c, 0, u, l, a) } r && Jc(i) } drawTitle() { const { ctx: e, options: { position: n, title: i, reverse: r } } = this; if (!i.display) return; const s = ze(i.font), o = Je(i.padding), a = i.align; let l = s.lineHeight / 2; n === "bottom" || n === "center" || ne(n) ? (l += o.bottom, me(i.text) && (l += s.lineHeight * (i.text.length - 1))) : l += o.top; const { titleX: c, titleY: u, maxWidth: d, rotation: f } = wR(this, l, n, a); cr(e, i.text, 0, 0, s, { color: i.color, maxWidth: d, rotation: f, textAlign: xR(a, n, r), textBaseline: "middle", translation: [c, u] }) } draw(e) { this._isVisible() && (this.drawBackground(), this.drawGrid(e), this.drawBorder(), this.drawTitle(), this.drawLabels(e)) } _layers() { const e = this.options, n = e.ticks && e.ticks.z || 0, i = Q(e.grid && e.grid.z, -1), r = Q(e.border && e.border.z, 0); return !this._isVisible() || this.draw !== pr.prototype.draw ? [{ z: n, draw: s => { this.draw(s) } }] : [{ z: i, draw: s => { this.drawBackground(), this.drawGrid(s), this.drawTitle() } }, { z: r, draw: () => { this.drawBorder() } }, { z: n, draw: s => { this.drawLabels(s) } }] } getMatchingVisibleMetas(e) { const n = this.chart.getSortedVisibleDatasetMetas(), i = this.axis + "AxisID", r = []; let s, o; for (s = 0, o = n.length; s < o; ++s) { const a = n[s]; a[i] === this.id && (!e || a.type === e) && r.push(a) } return r } _resolveTickFontOptions(e) { const n = this.options.ticks.setContext(this.getContext(e)); return ze(n.font) } _maxDigits() { const e = this._resolveTickFontOptions(0).lineHeight; return (this.isHorizontal() ? this.width : this.height) / e } } class Ka { constructor(e, n, i) { this.type = e, this.scope = n, this.override = i, this.items = Object.create(null) } isForType(e) { return Object.prototype.isPrototypeOf.call(this.type.prototype, e.prototype) } register(e) { const n = Object.getPrototypeOf(e); let i; SR(n) && (i = this.register(n)); const r = this.items, s = e.id, o = this.scope + "." + s; if (!s) throw new Error("class does not have id: " + e); return s in r || (r[s] = e, bR(e, o, i), this.override && Le.override(e.id, e.overrides)), o } get(e) { return this.items[e] } unregister(e) { const n = this.items, i = e.id, r = this.scope; i in n && delete n[i], r && i in Le[r] && (delete Le[r][i], this.override && delete lr[i]) } } function bR(t, e, n) { const i = yn(Object.create(null), [n ? Le.get(n) : {}, Le.get(e), t.defaults]); Le.set(e, i), t.defaultRoutes && _R(e, t.defaultRoutes), t.descriptors && Le.describe(e, t.descriptors) } function _R(t, e) { Object.keys(e).forEach(n => { const i = n.split("."), r = i.pop(), s = [t].concat(i).join("."), o = e[n].split("."), a = o.pop(), l = o.join("."); Le.route(s, r, l, a) }) } function SR(t) { return "id" in t && "defaults" in t } class kR { constructor() { this.controllers = new Ka(Jt, "datasets", !0), this.elements = new Ka(Wn, "elements"), this.plugins = new Ka(Object, "plugins"), this.scales = new Ka(pr, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements] } add(...e) { this._each("register", e) } remove(...e) { this._each("unregister", e) } addControllers(...e) { this._each("register", e, this.controllers) } addElements(...e) { this._each("register", e, this.elements) } addPlugins(...e) { this._each("register", e, this.plugins) } addScales(...e) { this._each("register", e, this.scales) } getController(e) { return this._get(e, this.controllers, "controller") } getElement(e) { return this._get(e, this.elements, "element") } getPlugin(e) { return this._get(e, this.plugins, "plugin") } getScale(e) { return this._get(e, this.scales, "scale") } removeControllers(...e) { this._each("unregister", e, this.controllers) } removeElements(...e) { this._each("unregister", e, this.elements) } removePlugins(...e) { this._each("unregister", e, this.plugins) } removeScales(...e) { this._each("unregister", e, this.scales) } _each(e, n, i) { [...n].forEach(r => { const s = i || this._getRegistryForType(r); i || s.isForType(r) || s === this.plugins && r.id ? this._exec(e, s, r) : ce(r, o => { const a = i || this._getRegistryForType(o); this._exec(e, a, o) }) }) } _exec(e, n, i) { const r = Rp(e); de(i["before" + r], [], i), n[e](i), de(i["after" + r], [], i) } _getRegistryForType(e) { for (let n = 0; n < this._typedRegistries.length; n++) { const i = this._typedRegistries[n]; if (i.isForType(e)) return i } return this.plugins } _get(e, n, i) { const r = n.get(e); if (r === void 0) throw new Error('"' + e + '" is not a registered ' + i + "."); return r } } var un = new kR; class PR { constructor() { this._init = [] } notify(e, n, i, r) { n === "beforeInit" && (this._init = this._createDescriptors(e, !0), this._notify(this._init, e, "install")); const s = r ? this._descriptors(e).filter(r) : this._descriptors(e), o = this._notify(s, e, n, i); return n === "afterDestroy" && (this._notify(s, e, "stop"), this._notify(this._init, e, "uninstall")), o } _notify(e, n, i, r) { r = r || {}; for (const s of e) { const o = s.plugin, a = o[i], l = [n, r, s.options]; if (de(a, l, o) === !1 && r.cancelable) return !1 } return !0 } invalidate() { te(this._cache) || (this._oldCache = this._cache, this._cache = void 0) } _descriptors(e) { if (this._cache) return this._cache; const n = this._cache = this._createDescriptors(e); return this._notifyStateChanges(e), n } _createDescriptors(e, n) { const i = e && e.config, r = Q(i.options && i.options.plugins, {}), s = CR(i); return r === !1 && !n ? [] : TR(e, s, r, n) } _notifyStateChanges(e) { const n = this._oldCache || [], i = this._cache, r = (s, o) => s.filter(a => !o.some(l => a.plugin.id === l.plugin.id)); this._notify(r(n, i), e, "stop"), this._notify(r(i, n), e, "start") } } function CR(t) { const e = {}, n = [], i = Object.keys(un.plugins.items); for (let s = 0; s < i.length; s++)n.push(un.getPlugin(i[s])); const r = t.plugins || []; for (let s = 0; s < r.length; s++) { const o = r[s]; n.indexOf(o) === -1 && (n.push(o), e[o.id] = !0) } return { plugins: n, localIds: e } } function MR(t, e) { return !e && t === !1 ? null : t === !0 ? {} : t } function TR(t, { plugins: e, localIds: n }, i, r) { const s = [], o = t.getContext(); for (const a of e) { const l = a.id, c = MR(i[l], r); c !== null && s.push({ plugin: a, options: ER(t.config, { plugin: a, local: n[l] }, c, o) }) } return s } function ER(t, { plugin: e, local: n }, i, r) { const s = t.pluginScopeKeys(e), o = t.getOptionScopes(i, s); return n && e.defaults && o.push(e.defaults), t.createResolver(o, r, [""], { scriptable: !1, indexable: !1, allKeys: !0 }) } function Hf(t, e) { const n = Le.datasets[t] || {}; return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || n.indexAxis || "x" } function DR(t, e) { let n = t; return t === "_index_" ? n = e : t === "_value_" && (n = e === "x" ? "y" : "x"), n } function OR(t, e) { return t === e ? "_index_" : "_value_" } function RR(t) { if (t === "top" || t === "bottom") return "x"; if (t === "left" || t === "right") return "y" } function hc(t, e) { if (t === "x" || t === "y" || t === "r" || (t = e.axis || RR(e.position) || t.length > 1 && hc(t[0].toLowerCase(), e), t)) return t; throw new Error(`Cannot determine type of '${name}' axis. Please provide 'axis' or 'position' option.`) } function LR(t, e) { const n = lr[t.type] || { scales: {} }, i = e.scales || {}, r = Hf(t.type, e), s = Object.create(null); return Object.keys(i).forEach(o => { const a = i[o]; if (!ne(a)) return console.error(`Invalid scale configuration for scale: ${o}`); if (a._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${o}`); const l = hc(o, a), c = OR(l, r), u = n.scales || {}; s[o] = to(Object.create(null), [{ axis: l }, a, u[l], u[c]]) }), t.data.datasets.forEach(o => { const a = o.type || t.type, l = o.indexAxis || Hf(a, e), u = (lr[a] || {}).scales || {}; Object.keys(u).forEach(d => { const f = DR(d, l), h = o[f + "AxisID"] || f; s[h] = s[h] || Object.create(null), to(s[h], [{ axis: f }, i[h], u[d]]) }) }), Object.keys(s).forEach(o => { const a = s[o]; to(a, [Le.scales[a.type], Le.scale]) }), s } function h_(t) { const e = t.options || (t.options = {}); e.plugins = Q(e.plugins, {}), e.scales = LR(t, e) } function p_(t) { return t = t || {}, t.datasets = t.datasets || [], t.labels = t.labels || [], t } function jR(t) { return t = t || {}, t.data = p_(t.data), h_(t), t } const F0 = new Map, m_ = new Set; function Xa(t, e) { let n = F0.get(t); return n || (n = e(), F0.set(t, n), m_.add(n)), n } const Ms = (t, e, n) => { const i = ki(e, n); i !== void 0 && t.add(i) }; class AR { constructor(e) { this._config = jR(e), this._scopeCache = new Map, this._resolverCache = new Map } get platform() { return this._config.platform } get type() { return this._config.type } set type(e) { this._config.type = e } get data() { return this._config.data } set data(e) { this._config.data = p_(e) } get options() { return this._config.options } set options(e) { this._config.options = e } get plugins() { return this._config.plugins } update() { const e = this._config; this.clearCache(), h_(e) } clearCache() { this._scopeCache.clear(), this._resolverCache.clear() } datasetScopeKeys(e) { return Xa(e, () => [[`datasets.${e}`, ""]]) } datasetAnimationScopeKeys(e, n) { return Xa(`${e}.transition.${n}`, () => [[`datasets.${e}.transitions.${n}`, `transitions.${n}`], [`datasets.${e}`, ""]]) } datasetElementScopeKeys(e, n) { return Xa(`${e}-${n}`, () => [[`datasets.${e}.elements.${n}`, `datasets.${e}`, `elements.${n}`, ""]]) } pluginScopeKeys(e) { const n = e.id, i = this.type; return Xa(`${i}-plugin-${n}`, () => [[`plugins.${n}`, ...e.additionalOptionScopes || []]]) } _cachedScopes(e, n) { const i = this._scopeCache; let r = i.get(e); return (!r || n) && (r = new Map, i.set(e, r)), r } getOptionScopes(e, n, i) { const { options: r, type: s } = this, o = this._cachedScopes(e, i), a = o.get(n); if (a) return a; const l = new Set; n.forEach(u => { e && (l.add(e), u.forEach(d => Ms(l, e, d))), u.forEach(d => Ms(l, r, d)), u.forEach(d => Ms(l, lr[s] || {}, d)), u.forEach(d => Ms(l, Le, d)), u.forEach(d => Ms(l, Vf, d)) }); const c = Array.from(l); return c.length === 0 && c.push(Object.create(null)), m_.has(n) && o.set(n, c), c } chartOptionScopes() { const { options: e, type: n } = this; return [e, lr[n] || {}, Le.datasets[n] || {}, { type: n }, Le, Vf] } resolveNamedOptions(e, n, i, r = [""]) { const s = { $shared: !0 }, { resolver: o, subPrefixes: a } = I0(this._resolverCache, e, r); let l = o; if (FR(o, n)) { s.$shared = !1, i = Pi(i) ? i() : i; const c = this.createResolver(e, i, a); l = ns(o, i, c) } for (const c of n) s[c] = l[c]; return s } createResolver(e, n, i = [""], r) { const { resolver: s } = I0(this._resolverCache, e, i); return ne(n) ? ns(s, n, void 0, r) : s } } function I0(t, e, n) { let i = t.get(e); i || (i = new Map, t.set(e, i)); const r = n.join(); let s = i.get(r); return s || (s = { resolver: Fp(e, n), subPrefixes: n.filter(a => !a.toLowerCase().includes("hover")) }, i.set(r, s)), s } const NR = t => ne(t) && Object.getOwnPropertyNames(t).reduce((e, n) => e || Pi(t[n]), !1); function FR(t, e) { const { isScriptable: n, isIndexable: i } = Kb(t); for (const r of e) { const s = n(r), o = i(r), a = (o || s) && t[r]; if (s && (Pi(a) || NR(a)) || o && me(a)) return !0 } return !1 } var IR = "4.2.1"; const VR = ["top", "bottom", "left", "right", "chartArea"]; function V0(t, e) { return t === "top" || t === "bottom" || VR.indexOf(t) === -1 && e === "x" } function z0(t, e) { return function (n, i) { return n[t] === i[t] ? n[e] - i[e] : n[t] - i[t] } } function B0(t) { const e = t.chart, n = e.options.animation; e.notifyPlugins("afterRender"), de(n && n.onComplete, [t], e) } function zR(t) { const e = t.chart, n = e.options.animation; de(n && n.onProgress, [t], e) } function g_(t) { return Jb() && typeof t == "string" ? t = document.getElementById(t) : t && t.length && (t = t[0]), t && t.canvas && (t = t.canvas), t } const kl = {}, H0 = t => { const e = g_(t); return Object.values(kl).filter(n => n.canvas === e).pop() }; function BR(t, e, n) { const i = Object.keys(t); for (const r of i) { const s = +r; if (s >= e) { const o = t[r]; delete t[r], (n > 0 || s > e) && (t[s + n] = o) } } } function HR(t, e, n, i) { return !n || t.type === "mouseout" ? null : i ? e : t } function WR(t) { const { xScale: e, yScale: n } = t; if (e && n) return { left: e.left, right: e.right, top: n.top, bottom: n.bottom } } var Xn; let aa = (Xn = class { static register(...e) { un.add(...e), W0() } static unregister(...e) { un.remove(...e), W0() } constructor(e, n) { const i = this.config = new AR(n), r = g_(e), s = H0(r); if (s) throw new Error("Canvas is already in use. Chart with ID '" + s.id + "' must be destroyed before the canvas with ID '" + s.canvas.id + "' can be reused."); const o = i.createResolver(i.chartOptionScopes(), this.getContext()); this.platform = new (i.platform || aR(r)), this.platform.updateConfig(i); const a = this.platform.acquireContext(r, o.aspectRatio), l = a && a.canvas, c = l && l.height, u = l && l.width; if (this.id = YO(), this.ctx = a, this.canvas = l, this.width = u, this.height = c, this._options = o, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new PR, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = l5(d => this.update(d), o.resizeDelay || 0), this._dataChanges = [], kl[this.id] = this, !a || !l) { console.error("Failed to create chart: can't acquire context from the given item"); return } Sn.listen(this, "complete", B0), Sn.listen(this, "progress", zR), this._initialize(), this.attached && this.update() } get aspectRatio() { const { options: { aspectRatio: e, maintainAspectRatio: n }, width: i, height: r, _aspectRatio: s } = this; return te(e) ? n && s ? s : r ? i / r : null : e } get data() { return this.config.data } set data(e) { this.config.data = e } get options() { return this._options } set options(e) { this.config.options = e } get registry() { return un } _initialize() { return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : f0(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this } clear() { return c0(this.canvas, this.ctx), this } stop() { return Sn.stop(this), this } resize(e, n) { Sn.running(this) ? this._resizeBeforeDraw = { width: e, height: n } : this._resize(e, n) } _resize(e, n) { const i = this.options, r = this.canvas, s = i.maintainAspectRatio && this.aspectRatio, o = this.platform.getMaximumSize(r, e, n, s), a = i.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach"; this.width = o.width, this.height = o.height, this._aspectRatio = this.aspectRatio, f0(this, a, !0) && (this.notifyPlugins("resize", { size: o }), de(i.onResize, [this, o], this), this.attached && this._doResize(l) && this.render()) } ensureScalesHaveIDs() { const n = this.options.scales || {}; ce(n, (i, r) => { i.id = r }) } buildOrUpdateScales() { const e = this.options, n = e.scales, i = this.scales, r = Object.keys(i).reduce((o, a) => (o[a] = !1, o), {}); let s = []; n && (s = s.concat(Object.keys(n).map(o => { const a = n[o], l = hc(o, a), c = l === "r", u = l === "x"; return { options: a, dposition: c ? "chartArea" : u ? "bottom" : "left", dtype: c ? "radialLinear" : u ? "category" : "linear" } }))), ce(s, o => { const a = o.options, l = a.id, c = hc(l, a), u = Q(a.type, o.dtype); (a.position === void 0 || V0(a.position, c) !== V0(o.dposition)) && (a.position = o.dposition), r[l] = !0; let d = null; if (l in i && i[l].type === u) d = i[l]; else { const f = un.getScale(u); d = new f({ id: l, type: u, ctx: this.ctx, chart: this }), i[d.id] = d } d.init(a, e) }), ce(r, (o, a) => { o || delete i[a] }), ce(i, o => { at.configure(this, o, o.options), at.addBox(this, o) }) } _updateMetasets() { const e = this._metasets, n = this.data.datasets.length, i = e.length; if (e.sort((r, s) => r.index - s.index), i > n) { for (let r = n; r < i; ++r)this._destroyDatasetMeta(r); e.splice(n, i - n) } this._sortedMetasets = e.slice(0).sort(z0("order", "index")) } _removeUnreferencedMetasets() { const { _metasets: e, data: { datasets: n } } = this; e.length > n.length && delete this._stacks, e.forEach((i, r) => { n.filter(s => s === i._dataset).length === 0 && this._destroyDatasetMeta(r) }) } buildOrUpdateControllers() { const e = [], n = this.data.datasets; let i, r; for (this._removeUnreferencedMetasets(), i = 0, r = n.length; i < r; i++) { const s = n[i]; let o = this.getDatasetMeta(i); const a = s.type || this.config.type; if (o.type && o.type !== a && (this._destroyDatasetMeta(i), o = this.getDatasetMeta(i)), o.type = a, o.indexAxis = s.indexAxis || Hf(a, this.options), o.order = s.order || 0, o.index = i, o.label = "" + s.label, o.visible = this.isDatasetVisible(i), o.controller) o.controller.updateIndex(i), o.controller.linkScales(); else { const l = un.getController(a), { datasetElementType: c, dataElementType: u } = Le.datasets[a]; Object.assign(l, { dataElementType: un.getElement(u), datasetElementType: c && un.getElement(c) }), o.controller = new l(this, i), e.push(o.controller) } } return this._updateMetasets(), e } _resetElements() { ce(this.data.datasets, (e, n) => { this.getDatasetMeta(n).controller.reset() }, this) } reset() { this._resetElements(), this.notifyPlugins("reset") } update(e) { const n = this.config; n.update(); const i = this._options = n.createResolver(n.chartOptionScopes(), this.getContext()), r = this._animationsDisabled = !i.animation; if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", { mode: e, cancelable: !0 }) === !1) return; const s = this.buildOrUpdateControllers(); this.notifyPlugins("beforeElementsUpdate"); let o = 0; for (let c = 0, u = this.data.datasets.length; c < u; c++) { const { controller: d } = this.getDatasetMeta(c), f = !r && s.indexOf(d) === -1; d.buildOrUpdateElements(f), o = Math.max(+d.getMaxOverflow(), o) } o = this._minPadding = i.layout.autoPadding ? o : 0, this._updateLayout(o), r || ce(s, c => { c.reset() }), this._updateDatasets(e), this.notifyPlugins("afterUpdate", { mode: e }), this._layers.sort(z0("z", "_idx")); const { _active: a, _lastEvent: l } = this; l ? this._eventHandler(l, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render() } _updateScales() { ce(this.scales, e => { at.removeBox(this, e) }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales() } _checkEventBindings() { const e = this.options, n = new Set(Object.keys(this._listeners)), i = new Set(e.events); (!e0(n, i) || !!this._responsiveListeners !== e.responsive) && (this.unbindEvents(), this.bindEvents()) } _updateHiddenIndices() { const { _hiddenIndices: e } = this, n = this._getUniformDataChanges() || []; for (const { method: i, start: r, count: s } of n) { const o = i === "_removeElements" ? -s : s; BR(e, r, o) } } _getUniformDataChanges() { const e = this._dataChanges; if (!e || !e.length) return; this._dataChanges = []; const n = this.data.datasets.length, i = s => new Set(e.filter(o => o[0] === s).map((o, a) => a + "," + o.splice(1).join(","))), r = i(0); for (let s = 1; s < n; s++)if (!e0(r, i(s))) return; return Array.from(r).map(s => s.split(",")).map(s => ({ method: s[1], start: +s[2], count: +s[3] })) } _updateLayout(e) { if (this.notifyPlugins("beforeLayout", { cancelable: !0 }) === !1) return; at.update(this, this.width, this.height, e); const n = this.chartArea, i = n.width <= 0 || n.height <= 0; this._layers = [], ce(this.boxes, r => { i && r.position === "chartArea" || (r.configure && r.configure(), this._layers.push(...r._layers())) }, this), this._layers.forEach((r, s) => { r._idx = s }), this.notifyPlugins("afterLayout") } _updateDatasets(e) { if (this.notifyPlugins("beforeDatasetsUpdate", { mode: e, cancelable: !0 }) !== !1) { for (let n = 0, i = this.data.datasets.length; n < i; ++n)this.getDatasetMeta(n).controller.configure(); for (let n = 0, i = this.data.datasets.length; n < i; ++n)this._updateDataset(n, Pi(e) ? e({ datasetIndex: n }) : e); this.notifyPlugins("afterDatasetsUpdate", { mode: e }) } } _updateDataset(e, n) { const i = this.getDatasetMeta(e), r = { meta: i, index: e, mode: n, cancelable: !0 }; this.notifyPlugins("beforeDatasetUpdate", r) !== !1 && (i.controller._update(n), r.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", r)) } render() { this.notifyPlugins("beforeRender", { cancelable: !0 }) !== !1 && (Sn.has(this) ? this.attached && !Sn.running(this) && Sn.start(this) : (this.draw(), B0({ chart: this }))) } draw() { let e; if (this._resizeBeforeDraw) { const { width: i, height: r } = this._resizeBeforeDraw; this._resize(i, r), this._resizeBeforeDraw = null } if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", { cancelable: !0 }) === !1) return; const n = this._layers; for (e = 0; e < n.length && n[e].z <= 0; ++e)n[e].draw(this.chartArea); for (this._drawDatasets(); e < n.length; ++e)n[e].draw(this.chartArea); this.notifyPlugins("afterDraw") } _getSortedDatasetMetas(e) { const n = this._sortedMetasets, i = []; let r, s; for (r = 0, s = n.length; r < s; ++r) { const o = n[r]; (!e || o.visible) && i.push(o) } return i } getSortedVisibleDatasetMetas() { return this._getSortedDatasetMetas(!0) } _drawDatasets() { if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: !0 }) === !1) return; const e = this.getSortedVisibleDatasetMetas(); for (let n = e.length - 1; n >= 0; --n)this._drawDataset(e[n]); this.notifyPlugins("afterDatasetsDraw") } _drawDataset(e) { const n = this.ctx, i = e._clip, r = !i.disabled, s = WR(e) || this.chartArea, o = { meta: e, index: e.index, cancelable: !0 }; this.notifyPlugins("beforeDatasetDraw", o) !== !1 && (r && Zc(n, { left: i.left === !1 ? 0 : s.left - i.left, right: i.right === !1 ? this.width : s.right + i.right, top: i.top === !1 ? 0 : s.top - i.top, bottom: i.bottom === !1 ? this.height : s.bottom + i.bottom }), e.controller.draw(), r && Jc(n), o.cancelable = !1, this.notifyPlugins("afterDatasetDraw", o)) } isPointInArea(e) { return Fo(e, this.chartArea, this._minPadding) } getElementsAtEventForMode(e, n, i, r) { const s = z3.modes[n]; return typeof s == "function" ? s(this, e, i, r) : [] } getDatasetMeta(e) { const n = this.data.datasets[e], i = this._metasets; let r = i.filter(s => s && s._dataset === n).pop(); return r || (r = { type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null, order: n && n.order || 0, index: e, _dataset: n, _parsed: [], _sorted: !1 }, i.push(r)), r } getContext() { return this.$context || (this.$context = Di(null, { chart: this, type: "chart" })) } getVisibleDatasetCount() { return this.getSortedVisibleDatasetMetas().length } isDatasetVisible(e) { const n = this.data.datasets[e]; if (!n) return !1; const i = this.getDatasetMeta(e); return typeof i.hidden == "boolean" ? !i.hidden : !n.hidden } setDatasetVisibility(e, n) { const i = this.getDatasetMeta(e); i.hidden = !n } toggleDataVisibility(e) { this._hiddenIndices[e] = !this._hiddenIndices[e] } getDataVisibility(e) { return !this._hiddenIndices[e] } _updateVisibility(e, n, i) { const r = i ? "show" : "hide", s = this.getDatasetMeta(e), o = s.controller._resolveAnimations(void 0, r); Wt(n) ? (s.data[n].hidden = !i, this.update()) : (this.setDatasetVisibility(e, i), o.update(s, { visible: i }), this.update(a => a.datasetIndex === e ? r : void 0)) } hide(e, n) { this._updateVisibility(e, n, !1) } show(e, n) { this._updateVisibility(e, n, !0) } _destroyDatasetMeta(e) { const n = this._metasets[e]; n && n.controller && n.controller._destroy(), delete this._metasets[e] } _stop() { let e, n; for (this.stop(), Sn.remove(this), e = 0, n = this.data.datasets.length; e < n; ++e)this._destroyDatasetMeta(e) } destroy() { this.notifyPlugins("beforeDestroy"); const { canvas: e, ctx: n } = this; this._stop(), this.config.clearCache(), e && (this.unbindEvents(), c0(e, n), this.platform.releaseContext(n), this.canvas = null, this.ctx = null), delete kl[this.id], this.notifyPlugins("afterDestroy") } toBase64Image(...e) { return this.canvas.toDataURL(...e) } bindEvents() { this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0 } bindUserEvents() { const e = this._listeners, n = this.platform, i = (s, o) => { n.addEventListener(this, s, o), e[s] = o }, r = (s, o, a) => { s.offsetX = o, s.offsetY = a, this._eventHandler(s) }; ce(this.options.events, s => i(s, r)) } bindResponsiveEvents() { this._responsiveListeners || (this._responsiveListeners = {}); const e = this._responsiveListeners, n = this.platform, i = (l, c) => { n.addEventListener(this, l, c), e[l] = c }, r = (l, c) => { e[l] && (n.removeEventListener(this, l, c), delete e[l]) }, s = (l, c) => { this.canvas && this.resize(l, c) }; let o; const a = () => { r("attach", a), this.attached = !0, this.resize(), i("resize", s), i("detach", o) }; o = () => { this.attached = !1, r("resize", s), this._stop(), this._resize(0, 0), i("attach", a) }, n.isAttached(this.canvas) ? a() : o() } unbindEvents() { ce(this._listeners, (e, n) => { this.platform.removeEventListener(this, n, e) }), this._listeners = {}, ce(this._responsiveListeners, (e, n) => { this.platform.removeEventListener(this, n, e) }), this._responsiveListeners = void 0 } updateHoverStyle(e, n, i) { const r = i ? "set" : "remove"; let s, o, a, l; for (n === "dataset" && (s = this.getDatasetMeta(e[0].datasetIndex), s.controller["_" + r + "DatasetHoverStyle"]()), a = 0, l = e.length; a < l; ++a) { o = e[a]; const c = o && this.getDatasetMeta(o.datasetIndex).controller; c && c[r + "HoverStyle"](o.element, o.datasetIndex, o.index) } } getActiveElements() { return this._active || [] } setActiveElements(e) { const n = this._active || [], i = e.map(({ datasetIndex: s, index: o }) => { const a = this.getDatasetMeta(s); if (!a) throw new Error("No dataset found at index " + s); return { datasetIndex: s, element: a.data[o], index: o } }); !ac(i, n) && (this._active = i, this._lastEvent = null, this._updateHoverStyles(i, n)) } notifyPlugins(e, n, i) { return this._plugins.notify(this, e, n, i) } isPluginEnabled(e) { return this._plugins._cache.filter(n => n.plugin.id === e).length === 1 } _updateHoverStyles(e, n, i) { const r = this.options.hover, s = (l, c) => l.filter(u => !c.some(d => u.datasetIndex === d.datasetIndex && u.index === d.index)), o = s(n, e), a = i ? e : s(e, n); o.length && this.updateHoverStyle(o, r.mode, !1), a.length && r.mode && this.updateHoverStyle(a, r.mode, !0) } _eventHandler(e, n) { const i = { event: e, replay: n, cancelable: !0, inChartArea: this.isPointInArea(e) }, r = o => (o.options.events || this.options.events).includes(e.native.type); if (this.notifyPlugins("beforeEvent", i, r) === !1) return; const s = this._handleEvent(e, n, i.inChartArea); return i.cancelable = !1, this.notifyPlugins("afterEvent", i, r), (s || i.changed) && this.render(), this } _handleEvent(e, n, i) { const { _active: r = [], options: s } = this, o = n, a = this._getActiveElements(e, r, i, o), l = ZO(e), c = HR(e, this._lastEvent, i, l); i && (this._lastEvent = null, de(s.onHover, [e, a, this], this), l && de(s.onClick, [e, a, this], this)); const u = !ac(a, r); return (u || n) && (this._active = a, this._updateHoverStyles(a, r, n)), this._lastEvent = c, u } _getActiveElements(e, n, i, r) { if (e.type === "mouseout") return []; if (!i) return n; const s = this.options.hover; return this.getElementsAtEventForMode(e, s.mode, s, r) } }, F(Xn, "defaults", Le), F(Xn, "instances", kl), F(Xn, "overrides", lr), F(Xn, "registry", un), F(Xn, "version", IR), F(Xn, "getChart", H0), Xn); function W0() { return ce(aa.instances, t => t._plugins.invalidate()) } function $R(t, e, n) { const { startAngle: i, pixelMargin: r, x: s, y: o, outerRadius: a, innerRadius: l } = e; let c = r / a; t.beginPath(), t.arc(s, o, a, i - c, n + c), l > r ? (c = r / l, t.arc(s, o, l, n + c, i - c, !0)) : t.arc(s, o, r, n + Re, i - Re), t.closePath(), t.clip() } function UR(t) { return Np(t, ["outerStart", "outerEnd", "innerStart", "innerEnd"]) } function YR(t, e, n, i) { const r = UR(t.options.borderRadius), s = (n - e) / 2, o = Math.min(s, i * e / 2), a = l => { const c = (n - Math.min(s, l)) * i / 2; return Xe(l, 0, Math.min(s, c)) }; return { outerStart: a(r.outerStart), outerEnd: a(r.outerEnd), innerStart: Xe(r.innerStart, 0, o), innerEnd: Xe(r.innerEnd, 0, o) } } function xr(t, e, n, i) { return { x: n + t * Math.cos(e), y: i + t * Math.sin(e) } } function pc(t, e, n, i, r, s) { const { x: o, y: a, startAngle: l, pixelMargin: c, innerRadius: u } = e, d = Math.max(e.outerRadius + i + n - c, 0), f = u > 0 ? u + i + n + c : 0; let h = 0; const m = r - l; if (i) { const z = u > 0 ? u - i : 0, J = d > 0 ? d - i : 0, re = (z + J) / 2, L = re !== 0 ? m * re / (re + i) : m; h = (m - L) / 2 } const p = Math.max(.001, m * d - n / we) / d, x = (m - p) / 2, y = l + x + h, g = r - x - h, { outerStart: v, outerEnd: b, innerStart: _, innerEnd: k } = YR(e, f, d, g - y), S = d - v, P = d - b, T = y + v / S, D = g - b / P, A = f + _, V = f + k, q = y + _ / A, G = g - k / V; if (t.beginPath(), s) { const z = (T + D) / 2; if (t.arc(o, a, d, T, z), t.arc(o, a, d, z, D), b > 0) { const j = xr(P, D, o, a); t.arc(j.x, j.y, b, D, g + Re) } const J = xr(V, g, o, a); if (t.lineTo(J.x, J.y), k > 0) { const j = xr(V, G, o, a); t.arc(j.x, j.y, k, g + Re, G + Math.PI) } const re = (g - k / f + (y + _ / f)) / 2; if (t.arc(o, a, f, g - k / f, re, !0), t.arc(o, a, f, re, y + _ / f, !0), _ > 0) { const j = xr(A, q, o, a); t.arc(j.x, j.y, _, q + Math.PI, y - Re) } const L = xr(S, y, o, a); if (t.lineTo(L.x, L.y), v > 0) { const j = xr(S, T, o, a); t.arc(j.x, j.y, v, y - Re, T) } } else { t.moveTo(o, a); const z = Math.cos(T) * d + o, J = Math.sin(T) * d + a; t.lineTo(z, J); const re = Math.cos(D) * d + o, L = Math.sin(D) * d + a; t.lineTo(re, L) } t.closePath() } function KR(t, e, n, i, r) { const { fullCircles: s, startAngle: o, circumference: a } = e; let l = e.endAngle; if (s) { pc(t, e, n, i, l, r); for (let c = 0; c < s; ++c)t.fill(); isNaN(a) || (l = o + (a % ye || ye)) } return pc(t, e, n, i, l, r), t.fill(), l } function XR(t, e, n, i, r) { const { fullCircles: s, startAngle: o, circumference: a, options: l } = e, { borderWidth: c, borderJoinStyle: u } = l, d = l.borderAlign === "inner"; if (!c) return; d ? (t.lineWidth = c * 2, t.lineJoin = u || "round") : (t.lineWidth = c, t.lineJoin = u || "bevel"); let f = e.endAngle; if (s) { pc(t, e, n, i, f, r); for (let h = 0; h < s; ++h)t.stroke(); isNaN(a) || (f = o + (a % ye || ye)) } d && $R(t, e, f), s || (pc(t, e, n, i, f, r), t.stroke()) } class oo extends Wn { constructor(e) { super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, e && Object.assign(this, e) } inRange(e, n, i) { const r = this.getProps(["x", "y"], i), { angle: s, distance: o } = Nb(r, { x: e, y: n }), { startAngle: a, endAngle: l, innerRadius: c, outerRadius: u, circumference: d } = this.getProps(["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], i), f = this.options.spacing / 2, m = Q(d, l - a) >= ye || No(s, a, l), p = Rn(o, c + f, u + f); return m && p } getCenterPoint(e) { const { x: n, y: i, startAngle: r, endAngle: s, innerRadius: o, outerRadius: a } = this.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"], e), { offset: l, spacing: c } = this.options, u = (r + s) / 2, d = (o + a + c + l) / 2; return { x: n + Math.cos(u) * d, y: i + Math.sin(u) * d } } tooltipPosition(e) { return this.getCenterPoint(e) } draw(e) { const { options: n, circumference: i } = this, r = (n.offset || 0) / 4, s = (n.spacing || 0) / 2, o = n.circular; if (this.pixelMargin = n.borderAlign === "inner" ? .33 : 0, this.fullCircles = i > ye ? Math.floor(i / ye) : 0, i === 0 || this.innerRadius < 0 || this.outerRadius < 0) return; e.save(); const a = (this.startAngle + this.endAngle) / 2; e.translate(Math.cos(a) * r, Math.sin(a) * r); const l = 1 - Math.sin(Math.min(we, i || 0)), c = r * l; e.fillStyle = n.backgroundColor, e.strokeStyle = n.borderColor, KR(e, this, c, s, o), XR(e, this, c, s, o), e.restore() } } F(oo, "id", "arc"), F(oo, "defaults", { borderAlign: "center", borderColor: "#fff", borderJoinStyle: void 0, borderRadius: 0, borderWidth: 2, offset: 0, spacing: 0, angle: void 0, circular: !0 }), F(oo, "defaultRoutes", { backgroundColor: "backgroundColor" }); function y_(t, e, n = e) { t.lineCap = Q(n.borderCapStyle, e.borderCapStyle), t.setLineDash(Q(n.borderDash, e.borderDash)), t.lineDashOffset = Q(n.borderDashOffset, e.borderDashOffset), t.lineJoin = Q(n.borderJoinStyle, e.borderJoinStyle), t.lineWidth = Q(n.borderWidth, e.borderWidth), t.strokeStyle = Q(n.borderColor, e.borderColor) } function GR(t, e, n) { t.lineTo(n.x, n.y) } function QR(t) { return t.stepped ? w5 : t.tension || t.cubicInterpolationMode === "monotone" ? b5 : GR } function v_(t, e, n = {}) { const i = t.length, { start: r = 0, end: s = i - 1 } = n, { start: o, end: a } = e, l = Math.max(r, o), c = Math.min(s, a), u = r < o && s < o || r > a && s > a; return { count: i, start: l, loop: e.loop, ilen: c < l && !u ? i + c - l : c - l } } function qR(t, e, n, i) { const { points: r, options: s } = e, { count: o, start: a, loop: l, ilen: c } = v_(r, n, i), u = QR(s); let { move: d = !0, reverse: f } = i || {}, h, m, p; for (h = 0; h <= c; ++h)m = r[(a + (f ? c - h : h)) % o], !m.skip && (d ? (t.moveTo(m.x, m.y), d = !1) : u(t, p, m, f, s.stepped), p = m); return l && (m = r[(a + (f ? c : 0)) % o], u(t, p, m, f, s.stepped)), !!l } function ZR(t, e, n, i) { const r = e.points, { count: s, start: o, ilen: a } = v_(r, n, i), { move: l = !0, reverse: c } = i || {}; let u = 0, d = 0, f, h, m, p, x, y; const g = b => (o + (c ? a - b : b)) % s, v = () => { p !== x && (t.lineTo(u, x), t.lineTo(u, p), t.lineTo(u, y)) }; for (l && (h = r[g(0)], t.moveTo(h.x, h.y)), f = 0; f <= a; ++f) { if (h = r[g(f)], h.skip) continue; const b = h.x, _ = h.y, k = b | 0; k === m ? (_ < p ? p = _ : _ > x && (x = _), u = (d * u + b) / ++d) : (v(), t.lineTo(b, _), m = k, d = 0, p = x = _), y = _ } v() } function Wf(t) { const e = t.options, n = e.borderDash && e.borderDash.length; return !t._decimated && !t._loop && !e.tension && e.cubicInterpolationMode !== "monotone" && !e.stepped && !n ? ZR : qR } function JR(t) { return t.stepped ? J5 : t.tension || t.cubicInterpolationMode === "monotone" ? e3 : Wi } function eL(t, e, n, i) { let r = e._path; r || (r = e._path = new Path2D, e.path(r, n, i) && r.closePath()), y_(t, e.options), t.stroke(r) } function tL(t, e, n, i) { const { segments: r, options: s } = e, o = Wf(e); for (const a of r) y_(t, s, a.style), t.beginPath(), o(t, e, a, { start: n, end: n + i - 1 }) && t.closePath(), t.stroke() } const nL = typeof Path2D == "function"; function iL(t, e, n, i) { nL && !e.options.segment ? eL(t, e, n, i) : tL(t, e, n, i) } class oi extends Wn { constructor(e) { super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, e && Object.assign(this, e) } updateControlPoints(e, n) { const i = this.options; if ((i.tension || i.cubicInterpolationMode === "monotone") && !i.stepped && !this._pointsUpdated) { const r = i.spanGaps ? this._loop : this._fullLoop; U5(this._points, i, e, r, n), this._pointsUpdated = !0 } } set points(e) { this._points = e, delete this._segments, delete this._path, this._pointsUpdated = !1 } get points() { return this._points } get segments() { return this._segments || (this._segments = o3(this, this.options.segment)) } first() { const e = this.segments, n = this.points; return e.length && n[e[0].start] } last() { const e = this.segments, n = this.points, i = e.length; return i && n[e[i - 1].end] } interpolate(e, n) { const i = this.options, r = e[n], s = this.points, o = r_(this, { property: n, start: r, end: r }); if (!o.length) return; const a = [], l = JR(i); let c, u; for (c = 0, u = o.length; c < u; ++c) { const { start: d, end: f } = o[c], h = s[d], m = s[f]; if (h === m) { a.push(h); continue } const p = Math.abs((r - h[n]) / (m[n] - h[n])), x = l(h, m, p, i.stepped); x[n] = e[n], a.push(x) } return a.length === 1 ? a[0] : a } pathSegment(e, n, i) { return Wf(this)(e, this, n, i) } path(e, n, i) { const r = this.segments, s = Wf(this); let o = this._loop; n = n || 0, i = i || this.points.length - n; for (const a of r) o &= s(e, this, a, { start: n, end: n + i - 1 }); return !!o } draw(e, n, i, r) { const s = this.options || {}; (this.points || []).length && s.borderWidth && (e.save(), iL(e, this, i, r), e.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0) } } F(oi, "id", "line"), F(oi, "defaults", { borderCapStyle: "butt", borderDash: [], borderDashOffset: 0, borderJoinStyle: "miter", borderWidth: 3, capBezierPoints: !0, cubicInterpolationMode: "default", fill: !1, spanGaps: !1, stepped: !1, tension: 0 }), F(oi, "defaultRoutes", { backgroundColor: "backgroundColor", borderColor: "borderColor" }), F(oi, "descriptors", { _scriptable: !0, _indexable: e => e !== "borderDash" && e !== "fill" }); function $0(t, e, n, i) { const r = t.options, { [n]: s } = t.getProps([n], i); return Math.abs(e - s) < r.radius + r.hitRadius } class ao extends Wn { constructor(e) { super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, e && Object.assign(this, e) } inRange(e, n, i) { const r = this.options, { x: s, y: o } = this.getProps(["x", "y"], i); return Math.pow(e - s, 2) + Math.pow(n - o, 2) < Math.pow(r.hitRadius + r.radius, 2) } inXRange(e, n) { return $0(this, e, "x", n) } inYRange(e, n) { return $0(this, e, "y", n) } getCenterPoint(e) { const { x: n, y: i } = this.getProps(["x", "y"], e); return { x: n, y: i } } size(e) { e = e || this.options || {}; let n = e.radius || 0; n = Math.max(n, n && e.hoverRadius || 0); const i = n && e.borderWidth || 0; return (n + i) * 2 } draw(e, n) { const i = this.options; this.skip || i.radius < .1 || !Fo(this, n, this.size(i) / 2) || (e.strokeStyle = i.borderColor, e.lineWidth = i.borderWidth, e.fillStyle = i.backgroundColor, zf(e, i, this.x, this.y)) } getRange() { const e = this.options || {}; return e.radius + e.hitRadius } } F(ao, "id", "point"), F(ao, "defaults", { borderWidth: 1, hitRadius: 1, hoverBorderWidth: 1, hoverRadius: 4, pointStyle: "circle", radius: 3, rotation: 0 }), F(ao, "defaultRoutes", { backgroundColor: "backgroundColor", borderColor: "borderColor" }); function x_(t, e) { const { x: n, y: i, base: r, width: s, height: o } = t.getProps(["x", "y", "base", "width", "height"], e); let a, l, c, u, d; return t.horizontal ? (d = o / 2, a = Math.min(n, r), l = Math.max(n, r), c = i - d, u = i + d) : (d = s / 2, a = n - d, l = n + d, c = Math.min(i, r), u = Math.max(i, r)), { left: a, top: c, right: l, bottom: u } } function ai(t, e, n, i) { return t ? 0 : Xe(e, n, i) } function rL(t, e, n) { const i = t.options.borderWidth, r = t.borderSkipped, s = Yb(i); return { t: ai(r.top, s.top, 0, n), r: ai(r.right, s.right, 0, e), b: ai(r.bottom, s.bottom, 0, n), l: ai(r.left, s.left, 0, e) } } function sL(t, e, n) { const { enableBorderRadius: i } = t.getProps(["enableBorderRadius"]), r = t.options.borderRadius, s = Zi(r), o = Math.min(e, n), a = t.borderSkipped, l = i || ne(r); return { topLeft: ai(!l || a.top || a.left, s.topLeft, 0, o), topRight: ai(!l || a.top || a.right, s.topRight, 0, o), bottomLeft: ai(!l || a.bottom || a.left, s.bottomLeft, 0, o), bottomRight: ai(!l || a.bottom || a.right, s.bottomRight, 0, o) } } function oL(t) { const e = x_(t), n = e.right - e.left, i = e.bottom - e.top, r = rL(t, n / 2, i / 2), s = sL(t, n / 2, i / 2); return { outer: { x: e.left, y: e.top, w: n, h: i, radius: s }, inner: { x: e.left + r.l, y: e.top + r.t, w: n - r.l - r.r, h: i - r.t - r.b, radius: { topLeft: Math.max(0, s.topLeft - Math.max(r.t, r.l)), topRight: Math.max(0, s.topRight - Math.max(r.t, r.r)), bottomLeft: Math.max(0, s.bottomLeft - Math.max(r.b, r.l)), bottomRight: Math.max(0, s.bottomRight - Math.max(r.b, r.r)) } } } } function ud(t, e, n, i) { const r = e === null, s = n === null, a = t && !(r && s) && x_(t, i); return a && (r || Rn(e, a.left, a.right)) && (s || Rn(n, a.top, a.bottom)) } function aL(t) { return t.topLeft || t.topRight || t.bottomLeft || t.bottomRight } function lL(t, e) { t.rect(e.x, e.y, e.w, e.h) } function dd(t, e, n = {}) { const i = t.x !== n.x ? -e : 0, r = t.y !== n.y ? -e : 0, s = (t.x + t.w !== n.x + n.w ? e : 0) - i, o = (t.y + t.h !== n.y + n.h ? e : 0) - r; return { x: t.x + i, y: t.y + r, w: t.w + s, h: t.h + o, radius: t.radius } } class lo extends Wn { constructor(e) { super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, e && Object.assign(this, e) } draw(e) { const { inflateAmount: n, options: { borderColor: i, backgroundColor: r } } = this, { inner: s, outer: o } = oL(this), a = aL(o.radius) ? Io : lL; e.save(), (o.w !== s.w || o.h !== s.h) && (e.beginPath(), a(e, dd(o, n, s)), e.clip(), a(e, dd(s, -n, o)), e.fillStyle = i, e.fill("evenodd")), e.beginPath(), a(e, dd(s, n)), e.fillStyle = r, e.fill(), e.restore() } inRange(e, n, i) { return ud(this, e, n, i) } inXRange(e, n) { return ud(this, e, null, n) } inYRange(e, n) { return ud(this, null, e, n) } getCenterPoint(e) { const { x: n, y: i, base: r, horizontal: s } = this.getProps(["x", "y", "base", "horizontal"], e); return { x: s ? (n + r) / 2 : n, y: s ? i : (i + r) / 2 } } getRange(e) { return e === "x" ? this.width / 2 : this.height / 2 } } F(lo, "id", "bar"), F(lo, "defaults", { borderSkipped: "start", borderWidth: 0, borderRadius: 0, inflateAmount: "auto", pointStyle: void 0 }), F(lo, "defaultRoutes", { backgroundColor: "backgroundColor", borderColor: "borderColor" }); var cL = Object.freeze({ __proto__: null, ArcElement: oo, LineElement: oi, PointElement: ao, BarElement: lo }); const $f = ["rgb(54, 162, 235)", "rgb(255, 99, 132)", "rgb(255, 159, 64)", "rgb(255, 205, 86)", "rgb(75, 192, 192)", "rgb(153, 102, 255)", "rgb(201, 203, 207)"], U0 = $f.map(t => t.replace("rgb(", "rgba(").replace(")", ", 0.5)")); function w_(t) { return $f[t % $f.length] } function b_(t) { return U0[t % U0.length] } function uL(t, e) { return t.borderColor = w_(e), t.backgroundColor = b_(e), ++e } function dL(t, e) { return t.backgroundColor = t.data.map(() => w_(e++)), e } function fL(t, e) { return t.backgroundColor = t.data.map(() => b_(e++)), e } function hL(t) { let e = 0; return (n, i) => { const r = t.getDatasetMeta(i).controller; r instanceof si ? e = dL(n, e) : r instanceof so ? e = fL(n, e) : r && (e = uL(n, e)) } } function Y0(t) { let e; for (e in t) if (t[e].borderColor || t[e].backgroundColor) return !0; return !1 } function pL(t) { return t && (t.borderColor || t.backgroundColor) } var mL = { id: "colors", defaults: { enabled: !0, forceOverride: !1 }, beforeLayout(t, e, n) { if (!n.enabled) return; const { data: { datasets: i }, options: r } = t.config, { elements: s } = r; if (!n.forceOverride && (Y0(i) || pL(r) || s && Y0(s))) return; const o = hL(t); i.forEach(o) } }; function gL(t, e, n, i, r) { const s = r.samples || i; if (s >= n) return t.slice(e, e + n); const o = [], a = (n - 2) / (s - 2); let l = 0; const c = e + n - 1; let u = e, d, f, h, m, p; for (o[l++] = t[u], d = 0; d < s - 2; d++) { let x = 0, y = 0, g; const v = Math.floor((d + 1) * a) + 1 + e, b = Math.min(Math.floor((d + 2) * a) + 1, n) + e, _ = b - v; for (g = v; g < b; g++)x += t[g].x, y += t[g].y; x /= _, y /= _; const k = Math.floor(d * a) + 1 + e, S = Math.min(Math.floor((d + 1) * a) + 1, n) + e, { x: P, y: T } = t[u]; for (h = m = -1, g = k; g < S; g++)m = .5 * Math.abs((P - x) * (t[g].y - T) - (P - t[g].x) * (y - T)), m > h && (h = m, f = t[g], p = g); o[l++] = f, u = p } return o[l++] = t[c], o } function yL(t, e, n, i) { let r = 0, s = 0, o, a, l, c, u, d, f, h, m, p; const x = [], y = e + n - 1, g = t[e].x, b = t[y].x - g; for (o = e; o < e + n; ++o) { a = t[o], l = (a.x - g) / b * i, c = a.y; const _ = l | 0; if (_ === u) c < m ? (m = c, d = o) : c > p && (p = c, f = o), r = (s * r + a.x) / ++s; else { const k = o - 1; if (!te(d) && !te(f)) { const S = Math.min(d, f), P = Math.max(d, f); S !== h && S !== k && x.push({ ...t[S], x: r }), P !== h && P !== k && x.push({ ...t[P], x: r }) } o > 0 && k !== h && x.push(t[k]), x.push(a), u = _, s = 0, m = p = c, d = f = h = o } } return x } function __(t) { if (t._decimated) { const e = t._data; delete t._decimated, delete t._data, Object.defineProperty(t, "data", { configurable: !0, enumerable: !0, writable: !0, value: e }) } } function K0(t) { t.data.datasets.forEach(e => { __(e) }) } function vL(t, e) { const n = e.length; let i = 0, r; const { iScale: s } = t, { min: o, max: a, minDefined: l, maxDefined: c } = s.getUserBounds(); return l && (i = Xe(Ln(e, s.axis, o).lo, 0, n - 1)), c ? r = Xe(Ln(e, s.axis, a).hi + 1, i, n) - i : r = n - i, { start: i, count: r } } var xL = { id: "decimation", defaults: { algorithm: "min-max", enabled: !1 }, beforeElementsUpdate: (t, e, n) => { if (!n.enabled) { K0(t); return } const i = t.width; t.data.datasets.forEach((r, s) => { const { _data: o, indexAxis: a } = r, l = t.getDatasetMeta(s), c = o || r.data; if (pe([a, t.options.indexAxis]) === "y" || !l.controller.supportsDecimation) return; const u = t.scales[l.xAxisID]; if (u.type !== "linear" && u.type !== "time" || t.options.parsing) return; let { start: d, count: f } = vL(l, c); const h = n.threshold || 4 * i; if (f <= h) { __(r); return } te(o) && (r._data = c, delete r.data, Object.defineProperty(r, "data", { configurable: !0, enumerable: !0, get: function () { return this._decimated }, set: function (p) { this._data = p } })); let m; switch (n.algorithm) { case "lttb": m = gL(c, d, f, i, n); break; case "min-max": m = yL(c, d, f, i); break; default: throw new Error(`Unsupported decimation algorithm '${n.algorithm}'`) }r._decimated = m }) }, destroy(t) { K0(t) } }; function wL(t, e, n) { const i = t.segments, r = t.points, s = e.points, o = []; for (const a of i) { let { start: l, end: c } = a; c = Hp(l, c, r); const u = Uf(n, r[l], r[c], a.loop); if (!e.segments) { o.push({ source: a, target: u, start: r[l], end: r[c] }); continue } const d = r_(e, u); for (const f of d) { const h = Uf(n, s[f.start], s[f.end], f.loop), m = i_(a, r, h); for (const p of m) o.push({ source: p, target: f, start: { [n]: X0(u, h, "start", Math.max) }, end: { [n]: X0(u, h, "end", Math.min) } }) } } return o } function Uf(t, e, n, i) { if (i) return; let r = e[t], s = n[t]; return t === "angle" && (r = Mt(r), s = Mt(s)), { property: t, start: r, end: s } } function bL(t, e) { const { x: n = null, y: i = null } = t || {}, r = e.points, s = []; return e.segments.forEach(({ start: o, end: a }) => { a = Hp(o, a, r); const l = r[o], c = r[a]; i !== null ? (s.push({ x: l.x, y: i }), s.push({ x: c.x, y: i })) : n !== null && (s.push({ x: n, y: l.y }), s.push({ x: n, y: c.y })) }), s } function Hp(t, e, n) { for (; e > t; e--) { const i = n[e]; if (!isNaN(i.x) && !isNaN(i.y)) break } return e } function X0(t, e, n, i) { return t && e ? i(t[n], e[n]) : t ? t[n] : e ? e[n] : 0 } function S_(t, e) { let n = [], i = !1; return me(t) ? (i = !0, n = t) : n = bL(t, e), n.length ? new oi({ points: n, options: { tension: 0 }, _loop: i, _fullLoop: i }) : null } function G0(t) { return t && t.fill !== !1 } function _L(t, e, n) { let r = t[e].fill; const s = [e]; let o; if (!n) return r; for (; r !== !1 && s.indexOf(r) === -1;) { if (!Oe(r)) return r; if (o = t[r], !o) return !1; if (o.visible) return r; s.push(r), r = o.fill } return !1 } function SL(t, e, n) { const i = ML(t); if (ne(i)) return isNaN(i.value) ? !1 : i; let r = parseFloat(i); return Oe(r) && Math.floor(r) === r ? kL(i[0], e, r, n) : ["origin", "start", "end", "stack", "shape"].indexOf(i) >= 0 && i } function kL(t, e, n, i) { return (t === "-" || t === "+") && (n = e + n), n === e || n < 0 || n >= i ? !1 : n } function PL(t, e) { let n = null; return t === "start" ? n = e.bottom : t === "end" ? n = e.top : ne(t) ? n = e.getPixelForValue(t.value) : e.getBasePixel && (n = e.getBasePixel()), n } function CL(t, e, n) { let i; return t === "start" ? i = n : t === "end" ? i = e.options.reverse ? e.min : e.max : ne(t) ? i = t.value : i = e.getBaseValue(), i } function ML(t) { const e = t.options, n = e.fill; let i = Q(n && n.target, n); return i === void 0 && (i = !!e.backgroundColor), i === !1 || i === null ? !1 : i === !0 ? "origin" : i } function TL(t) { const { scale: e, index: n, line: i } = t, r = [], s = i.segments, o = i.points, a = EL(e, n); a.push(S_({ x: null, y: e.bottom }, i)); for (let l = 0; l < s.length; l++) { const c = s[l]; for (let u = c.start; u <= c.end; u++)DL(r, o[u], a) } return new oi({ points: r, options: {} }) } function EL(t, e) { const n = [], i = t.getMatchingVisibleMetas("line"); for (let r = 0; r < i.length; r++) { const s = i[r]; if (s.index === e) break; s.hidden || n.unshift(s.dataset) } return n } function DL(t, e, n) { const i = []; for (let r = 0; r < n.length; r++) { const s = n[r], { first: o, last: a, point: l } = OL(s, e, "x"); if (!(!l || o && a)) { if (o) i.unshift(l); else if (t.push(l), !a) break } } t.push(...i) } function OL(t, e, n) { const i = t.interpolate(e, n); if (!i) return {}; const r = i[n], s = t.segments, o = t.points; let a = !1, l = !1; for (let c = 0; c < s.length; c++) { const u = s[c], d = o[u.start][n], f = o[u.end][n]; if (Rn(r, d, f)) { a = r === d, l = r === f; break } } return { first: a, last: l, point: i } } class k_ { constructor(e) { this.x = e.x, this.y = e.y, this.radius = e.radius } pathSegment(e, n, i) { const { x: r, y: s, radius: o } = this; return n = n || { start: 0, end: ye }, e.arc(r, s, o, n.end, n.start, !0), !i.bounds } interpolate(e) { const { x: n, y: i, radius: r } = this, s = e.angle; return { x: n + Math.cos(s) * r, y: i + Math.sin(s) * r, angle: s } } } function RL(t) { const { chart: e, fill: n, line: i } = t; if (Oe(n)) return LL(e, n); if (n === "stack") return TL(t); if (n === "shape") return !0; const r = jL(t); return r instanceof k_ ? r : S_(r, i) } function LL(t, e) { const n = t.getDatasetMeta(e); return n && t.isDatasetVisible(e) ? n.dataset : null } function jL(t) { return (t.scale || {}).getPointPositionForValue ? NL(t) : AL(t) } function AL(t) { const { scale: e = {}, fill: n } = t, i = PL(n, e); if (Oe(i)) { const r = e.isHorizontal(); return { x: r ? i : null, y: r ? null : i } } return null } function NL(t) { const { scale: e, fill: n } = t, i = e.options, r = e.getLabels().length, s = i.reverse ? e.max : e.min, o = CL(n, e, s), a = []; if (i.grid.circular) { const l = e.getPointPositionForValue(0, s); return new k_({ x: l.x, y: l.y, radius: e.getDistanceFromCenterForValue(o) }) } for (let l = 0; l < r; ++l)a.push(e.getPointPositionForValue(l, o)); return a } function fd(t, e, n) { const i = RL(e), { line: r, scale: s, axis: o } = e, a = r.options, l = a.fill, c = a.backgroundColor, { above: u = c, below: d = c } = l || {}; i && r.points.length && (Zc(t, n), FL(t, { line: r, target: i, above: u, below: d, area: n, scale: s, axis: o }), Jc(t)) } function FL(t, e) { const { line: n, target: i, above: r, below: s, area: o, scale: a } = e, l = n._loop ? "angle" : e.axis; t.save(), l === "x" && s !== r && (Q0(t, i, o.top), q0(t, { line: n, target: i, color: r, scale: a, property: l }), t.restore(), t.save(), Q0(t, i, o.bottom)), q0(t, { line: n, target: i, color: s, scale: a, property: l }), t.restore() } function Q0(t, e, n) { const { segments: i, points: r } = e; let s = !0, o = !1; t.beginPath(); for (const a of i) { const { start: l, end: c } = a, u = r[l], d = r[Hp(l, c, r)]; s ? (t.moveTo(u.x, u.y), s = !1) : (t.lineTo(u.x, n), t.lineTo(u.x, u.y)), o = !!e.pathSegment(t, a, { move: o }), o ? t.closePath() : t.lineTo(d.x, n) } t.lineTo(e.first().x, n), t.closePath(), t.clip() } function q0(t, e) { const { line: n, target: i, property: r, color: s, scale: o } = e, a = wL(n, i, r); for (const { source: l, target: c, start: u, end: d } of a) { const { style: { backgroundColor: f = s } = {} } = l, h = i !== !0; t.save(), t.fillStyle = f, IL(t, o, h && Uf(r, u, d)), t.beginPath(); const m = !!n.pathSegment(t, l); let p; if (h) { m ? t.closePath() : Z0(t, i, d, r); const x = !!i.pathSegment(t, c, { move: m, reverse: !0 }); p = m && x, p || Z0(t, i, u, r) } t.closePath(), t.fill(p ? "evenodd" : "nonzero"), t.restore() } } function IL(t, e, n) { const { top: i, bottom: r } = e.chart.chartArea, { property: s, start: o, end: a } = n || {}; s === "x" && (t.beginPath(), t.rect(o, i, a - o, r - i), t.clip()) } function Z0(t, e, n, i) { const r = e.interpolate(n, i); r && t.lineTo(r.x, r.y) } var VL = { id: "filler", afterDatasetsUpdate(t, e, n) { const i = (t.data.datasets || []).length, r = []; let s, o, a, l; for (o = 0; o < i; ++o)s = t.getDatasetMeta(o), a = s.dataset, l = null, a && a.options && a instanceof oi && (l = { visible: t.isDatasetVisible(o), index: o, fill: SL(a, o, i), chart: t, axis: s.controller.options.indexAxis, scale: s.vScale, line: a }), s.$filler = l, r.push(l); for (o = 0; o < i; ++o)l = r[o], !(!l || l.fill === !1) && (l.fill = _L(r, o, n.propagate)) }, beforeDraw(t, e, n) { const i = n.drawTime === "beforeDraw", r = t.getSortedVisibleDatasetMetas(), s = t.chartArea; for (let o = r.length - 1; o >= 0; --o) { const a = r[o].$filler; a && (a.line.updateControlPoints(s, a.axis), i && a.fill && fd(t.ctx, a, s)) } }, beforeDatasetsDraw(t, e, n) { if (n.drawTime !== "beforeDatasetsDraw") return; const i = t.getSortedVisibleDatasetMetas(); for (let r = i.length - 1; r >= 0; --r) { const s = i[r].$filler; G0(s) && fd(t.ctx, s, t.chartArea) } }, beforeDatasetDraw(t, e, n) { const i = e.meta.$filler; !G0(i) || n.drawTime !== "beforeDatasetDraw" || fd(t.ctx, i, t.chartArea) }, defaults: { propagate: !0, drawTime: "beforeDatasetDraw" } }; const J0 = (t, e) => { let { boxHeight: n = e, boxWidth: i = e } = t; return t.usePointStyle && (n = Math.min(n, e), i = t.pointStyleWidth || Math.min(i, e)), { boxWidth: i, boxHeight: n, itemHeight: Math.max(e, n) } }, zL = (t, e) => t !== null && e !== null && t.datasetIndex === e.datasetIndex && t.index === e.index; class ev extends Wn { constructor(e) { super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update(e, n, i) { this.maxWidth = e, this.maxHeight = n, this._margins = i, this.setDimensions(), this.buildLabels(), this.fit() } setDimensions() { this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height) } buildLabels() { const e = this.options.labels || {}; let n = de(e.generateLabels, [this.chart], this) || []; e.filter && (n = n.filter(i => e.filter(i, this.chart.data))), e.sort && (n = n.sort((i, r) => e.sort(i, r, this.chart.data))), this.options.reverse && n.reverse(), this.legendItems = n } fit() { const { options: e, ctx: n } = this; if (!e.display) { this.width = this.height = 0; return } const i = e.labels, r = ze(i.font), s = r.size, o = this._computeTitleHeight(), { boxWidth: a, itemHeight: l } = J0(i, s); let c, u; n.font = r.string, this.isHorizontal() ? (c = this.maxWidth, u = this._fitRows(o, s, a, l) + 10) : (u = this.maxHeight, c = this._fitCols(o, r, a, l) + 10), this.width = Math.min(c, e.maxWidth || this.maxWidth), this.height = Math.min(u, e.maxHeight || this.maxHeight) } _fitRows(e, n, i, r) { const { ctx: s, maxWidth: o, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.lineWidths = [0], u = r + a; let d = e; s.textAlign = "left", s.textBaseline = "middle"; let f = -1, h = -u; return this.legendItems.forEach((m, p) => { const x = i + n / 2 + s.measureText(m.text).width; (p === 0 || c[c.length - 1] + x + 2 * a > o) && (d += u, c[c.length - (p > 0 ? 0 : 1)] = 0, h += u, f++), l[p] = { left: 0, top: h, row: f, width: x, height: r }, c[c.length - 1] += x + a }), d } _fitCols(e, n, i, r) { const { ctx: s, maxHeight: o, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.columnSizes = [], u = o - e; let d = a, f = 0, h = 0, m = 0, p = 0; return this.legendItems.forEach((x, y) => { const { itemWidth: g, itemHeight: v } = BL(i, n, s, x, r); y > 0 && h + v + 2 * a > u && (d += f + a, c.push({ width: f, height: h }), m += f + a, p++, f = h = 0), l[y] = { left: m, top: h, col: p, width: g, height: v }, f = Math.max(f, g), h += v + a }), d += f, c.push({ width: f, height: h }), d } adjustHitBoxes() { if (!this.options.display) return; const e = this._computeTitleHeight(), { legendHitBoxes: n, options: { align: i, labels: { padding: r }, rtl: s } } = this, o = $r(s, this.left, this.width); if (this.isHorizontal()) { let a = 0, l = rt(i, this.left + r, this.right - this.lineWidths[a]); for (const c of n) a !== c.row && (a = c.row, l = rt(i, this.left + r, this.right - this.lineWidths[a])), c.top += this.top + e + r, c.left = o.leftForLtr(o.x(l), c.width), l += c.width + r } else { let a = 0, l = rt(i, this.top + e + r, this.bottom - this.columnSizes[a].height); for (const c of n) c.col !== a && (a = c.col, l = rt(i, this.top + e + r, this.bottom - this.columnSizes[a].height)), c.top = l, c.left += this.left + r, c.left = o.leftForLtr(o.x(c.left), c.width), l += c.height + r } } isHorizontal() { return this.options.position === "top" || this.options.position === "bottom" } draw() { if (this.options.display) { const e = this.ctx; Zc(e, this), this._draw(), Jc(e) } } _draw() { const { options: e, columnSizes: n, lineWidths: i, ctx: r } = this, { align: s, labels: o } = e, a = Le.color, l = $r(e.rtl, this.left, this.width), c = ze(o.font), { padding: u } = o, d = c.size, f = d / 2; let h; this.drawTitle(), r.textAlign = l.textAlign("left"), r.textBaseline = "middle", r.lineWidth = .5, r.font = c.string; const { boxWidth: m, boxHeight: p, itemHeight: x } = J0(o, d), y = function (k, S, P) { if (isNaN(m) || m <= 0 || isNaN(p) || p < 0) return; r.save(); const T = Q(P.lineWidth, 1); if (r.fillStyle = Q(P.fillStyle, a), r.lineCap = Q(P.lineCap, "butt"), r.lineDashOffset = Q(P.lineDashOffset, 0), r.lineJoin = Q(P.lineJoin, "miter"), r.lineWidth = T, r.strokeStyle = Q(P.strokeStyle, a), r.setLineDash(Q(P.lineDash, [])), o.usePointStyle) { const D = { radius: p * Math.SQRT2 / 2, pointStyle: P.pointStyle, rotation: P.rotation, borderWidth: T }, A = l.xPlus(k, m / 2), V = S + f; Ub(r, D, A, V, o.pointStyleWidth && m) } else { const D = S + Math.max((d - p) / 2, 0), A = l.leftForLtr(k, m), V = Zi(P.borderRadius); r.beginPath(), Object.values(V).some(q => q !== 0) ? Io(r, { x: A, y: D, w: m, h: p, radius: V }) : r.rect(A, D, m, p), r.fill(), T !== 0 && r.stroke() } r.restore() }, g = function (k, S, P) { cr(r, P.text, k, S + x / 2, c, { strikethrough: P.hidden, textAlign: l.textAlign(P.textAlign) }) }, v = this.isHorizontal(), b = this._computeTitleHeight(); v ? h = { x: rt(s, this.left + u, this.right - i[0]), y: this.top + u + b, line: 0 } : h = { x: this.left + u, y: rt(s, this.top + b + u, this.bottom - n[0].height), line: 0 }, e_(this.ctx, e.textDirection); const _ = x + u; this.legendItems.forEach((k, S) => { r.strokeStyle = k.fontColor, r.fillStyle = k.fontColor; const P = r.measureText(k.text).width, T = l.textAlign(k.textAlign || (k.textAlign = o.textAlign)), D = m + f + P; let A = h.x, V = h.y; l.setWidth(this.width), v ? S > 0 && A + D + u > this.right && (V = h.y += _, h.line++, A = h.x = rt(s, this.left + u, this.right - i[h.line])) : S > 0 && V + _ > this.bottom && (A = h.x = A + n[h.line].width + u, h.line++, V = h.y = rt(s, this.top + b + u, this.bottom - n[h.line].height)); const q = l.x(A); if (y(q, V, k), A = c5(T, A + m + f, v ? A + D : this.right, e.rtl), g(l.x(A), V, k), v) h.x += D + u; else if (typeof k.text != "string") { const G = c.lineHeight; h.y += P_(k, G) } else h.y += _ }), t_(this.ctx, e.textDirection) } drawTitle() { const e = this.options, n = e.title, i = ze(n.font), r = Je(n.padding); if (!n.display) return; const s = $r(e.rtl, this.left, this.width), o = this.ctx, a = n.position, l = i.size / 2, c = r.top + l; let u, d = this.left, f = this.width; if (this.isHorizontal()) f = Math.max(...this.lineWidths), u = this.top + c, d = rt(e.align, d, this.right - f); else { const m = this.columnSizes.reduce((p, x) => Math.max(p, x.height), 0); u = c + rt(e.align, this.top, this.bottom - m - e.labels.padding - this._computeTitleHeight()) } const h = rt(a, d, d + f); o.textAlign = s.textAlign(Ap(a)), o.textBaseline = "middle", o.strokeStyle = n.color, o.fillStyle = n.color, o.font = i.string, cr(o, n.text, h, u, i) } _computeTitleHeight() { const e = this.options.title, n = ze(e.font), i = Je(e.padding); return e.display ? n.lineHeight + i.height : 0 } _getLegendItemAt(e, n) { let i, r, s; if (Rn(e, this.left, this.right) && Rn(n, this.top, this.bottom)) { for (s = this.legendHitBoxes, i = 0; i < s.length; ++i)if (r = s[i], Rn(e, r.left, r.left + r.width) && Rn(n, r.top, r.top + r.height)) return this.legendItems[i] } return null } handleEvent(e) { const n = this.options; if (!$L(e.type, n)) return; const i = this._getLegendItemAt(e.x, e.y); if (e.type === "mousemove" || e.type === "mouseout") { const r = this._hoveredItem, s = zL(r, i); r && !s && de(n.onLeave, [e, r, this], this), this._hoveredItem = i, i && !s && de(n.onHover, [e, i, this], this) } else i && de(n.onClick, [e, i, this], this) } } function BL(t, e, n, i, r) { const s = HL(i, t, e, n), o = WL(r, i, e.lineHeight); return { itemWidth: s, itemHeight: o } } function HL(t, e, n, i) { let r = t.text; return r && typeof r != "string" && (r = r.reduce((s, o) => s.length > o.length ? s : o)), e + n.size / 2 + i.measureText(r).width } function WL(t, e, n) { let i = t; return typeof e.text != "string" && (i = P_(e, n)), i } function P_(t, e) { const n = t.text ? t.text.length + .5 : 0; return e * n } function $L(t, e) { return !!((t === "mousemove" || t === "mouseout") && (e.onHover || e.onLeave) || e.onClick && (t === "click" || t === "mouseup")) } var UL = { id: "legend", _element: ev, start(t, e, n) { const i = t.legend = new ev({ ctx: t.ctx, options: n, chart: t }); at.configure(t, i, n), at.addBox(t, i) }, stop(t) { at.removeBox(t, t.legend), delete t.legend }, beforeUpdate(t, e, n) { const i = t.legend; at.configure(t, i, n), i.options = n }, afterUpdate(t) { const e = t.legend; e.buildLabels(), e.adjustHitBoxes() }, afterEvent(t, e) { e.replay || t.legend.handleEvent(e.event) }, defaults: { display: !0, position: "top", align: "center", fullSize: !0, reverse: !1, weight: 1e3, onClick(t, e, n) { const i = e.datasetIndex, r = n.chart; r.isDatasetVisible(i) ? (r.hide(i), e.hidden = !0) : (r.show(i), e.hidden = !1) }, onHover: null, onLeave: null, labels: { color: t => t.chart.options.color, boxWidth: 40, padding: 10, generateLabels(t) { const e = t.data.datasets, { labels: { usePointStyle: n, pointStyle: i, textAlign: r, color: s, useBorderRadius: o, borderRadius: a } } = t.legend.options; return t._getSortedDatasetMetas().map(l => { const c = l.controller.getStyle(n ? 0 : void 0), u = Je(c.borderWidth); return { text: e[l.index].label, fillStyle: c.backgroundColor, fontColor: s, hidden: !l.visible, lineCap: c.borderCapStyle, lineDash: c.borderDash, lineDashOffset: c.borderDashOffset, lineJoin: c.borderJoinStyle, lineWidth: (u.width + u.height) / 4, strokeStyle: c.borderColor, pointStyle: i || c.pointStyle, rotation: c.rotation, textAlign: r || c.textAlign, borderRadius: o && (a || c.borderRadius), datasetIndex: l.index } }, this) } }, title: { color: t => t.chart.options.color, display: !1, position: "center", text: "" } }, descriptors: { _scriptable: t => !t.startsWith("on"), labels: { _scriptable: t => !["generateLabels", "filter", "sort"].includes(t) } } }; class Wp extends Wn { constructor(e) { super(), this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update(e, n) { const i = this.options; if (this.left = 0, this.top = 0, !i.display) { this.width = this.height = this.right = this.bottom = 0; return } this.width = this.right = e, this.height = this.bottom = n; const r = me(i.text) ? i.text.length : 1; this._padding = Je(i.padding); const s = r * ze(i.font).lineHeight + this._padding.height; this.isHorizontal() ? this.height = s : this.width = s } isHorizontal() { const e = this.options.position; return e === "top" || e === "bottom" } _drawArgs(e) { const { top: n, left: i, bottom: r, right: s, options: o } = this, a = o.align; let l = 0, c, u, d; return this.isHorizontal() ? (u = rt(a, i, s), d = n + e, c = s - i) : (o.position === "left" ? (u = i + e, d = rt(a, r, n), l = we * -.5) : (u = s - e, d = rt(a, n, r), l = we * .5), c = r - n), { titleX: u, titleY: d, maxWidth: c, rotation: l } } draw() { const e = this.ctx, n = this.options; if (!n.display) return; const i = ze(n.font), s = i.lineHeight / 2 + this._padding.top, { titleX: o, titleY: a, maxWidth: l, rotation: c } = this._drawArgs(s); cr(e, n.text, 0, 0, i, { color: n.color, maxWidth: l, rotation: c, textAlign: Ap(n.align), textBaseline: "middle", translation: [o, a] }) } } function YL(t, e) { const n = new Wp({ ctx: t.ctx, options: e, chart: t }); at.configure(t, n, e), at.addBox(t, n), t.titleBlock = n } var KL = { id: "title", _element: Wp, start(t, e, n) { YL(t, n) }, stop(t) { const e = t.titleBlock; at.removeBox(t, e), delete t.titleBlock }, beforeUpdate(t, e, n) { const i = t.titleBlock; at.configure(t, i, n), i.options = n }, defaults: { align: "center", display: !1, font: { weight: "bold" }, fullSize: !0, padding: 10, position: "top", text: "", weight: 2e3 }, defaultRoutes: { color: "color" }, descriptors: { _scriptable: !0, _indexable: !1 } }; const Ga = new WeakMap; var XL = { id: "subtitle", start(t, e, n) { const i = new Wp({ ctx: t.ctx, options: n, chart: t }); at.configure(t, i, n), at.addBox(t, i), Ga.set(t, i) }, stop(t) { at.removeBox(t, Ga.get(t)), Ga.delete(t) }, beforeUpdate(t, e, n) { const i = Ga.get(t); at.configure(t, i, n), i.options = n }, defaults: { align: "center", display: !1, font: { weight: "normal" }, fullSize: !0, padding: 0, position: "top", text: "", weight: 1500 }, defaultRoutes: { color: "color" }, descriptors: { _scriptable: !0, _indexable: !1 } }; const Ns = { average(t) { if (!t.length) return !1; let e, n, i = 0, r = 0, s = 0; for (e = 0, n = t.length; e < n; ++e) { const o = t[e].element; if (o && o.hasValue()) { const a = o.tooltipPosition(); i += a.x, r += a.y, ++s } } return { x: i / s, y: r / s } }, nearest(t, e) { if (!t.length) return !1; let n = e.x, i = e.y, r = Number.POSITIVE_INFINITY, s, o, a; for (s = 0, o = t.length; s < o; ++s) { const l = t[s].element; if (l && l.hasValue()) { const c = l.getCenterPoint(), u = If(e, c); u < r && (r = u, a = l) } } if (a) { const l = a.tooltipPosition(); n = l.x, i = l.y } return { x: n, y: i } } }; function on(t, e) { return e && (me(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t } function kn(t) {
    return (typeof t == "string" || t instanceof String) && t.indexOf(`
`) > -1 ? t.split(`
`) : t
} function GL(t, e) { const { element: n, datasetIndex: i, index: r } = e, s = t.getDatasetMeta(i).controller, { label: o, value: a } = s.getLabelAndValue(r); return { chart: t, label: o, parsed: s.getParsed(r), raw: t.data.datasets[i].data[r], formattedValue: a, dataset: s.getDataset(), dataIndex: r, datasetIndex: i, element: n } } function tv(t, e) { const n = t.chart.ctx, { body: i, footer: r, title: s } = t, { boxWidth: o, boxHeight: a } = e, l = ze(e.bodyFont), c = ze(e.titleFont), u = ze(e.footerFont), d = s.length, f = r.length, h = i.length, m = Je(e.padding); let p = m.height, x = 0, y = i.reduce((b, _) => b + _.before.length + _.lines.length + _.after.length, 0); if (y += t.beforeBody.length + t.afterBody.length, d && (p += d * c.lineHeight + (d - 1) * e.titleSpacing + e.titleMarginBottom), y) { const b = e.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight; p += h * b + (y - h) * l.lineHeight + (y - 1) * e.bodySpacing } f && (p += e.footerMarginTop + f * u.lineHeight + (f - 1) * e.footerSpacing); let g = 0; const v = function (b) { x = Math.max(x, n.measureText(b).width + g) }; return n.save(), n.font = c.string, ce(t.title, v), n.font = l.string, ce(t.beforeBody.concat(t.afterBody), v), g = e.displayColors ? o + 2 + e.boxPadding : 0, ce(i, b => { ce(b.before, v), ce(b.lines, v), ce(b.after, v) }), g = 0, n.font = u.string, ce(t.footer, v), n.restore(), x += m.width, { width: x, height: p } } function QL(t, e) { const { y: n, height: i } = e; return n < i / 2 ? "top" : n > t.height - i / 2 ? "bottom" : "center" } function qL(t, e, n, i) { const { x: r, width: s } = i, o = n.caretSize + n.caretPadding; if (t === "left" && r + s + o > e.width || t === "right" && r - s - o < 0) return !0 } function ZL(t, e, n, i) { const { x: r, width: s } = n, { width: o, chartArea: { left: a, right: l } } = t; let c = "center"; return i === "center" ? c = r <= (a + l) / 2 ? "left" : "right" : r <= s / 2 ? c = "left" : r >= o - s / 2 && (c = "right"), qL(c, t, e, n) && (c = "center"), c } function nv(t, e, n) { const i = n.yAlign || e.yAlign || QL(t, n); return { xAlign: n.xAlign || e.xAlign || ZL(t, e, n, i), yAlign: i } } function JL(t, e) { let { x: n, width: i } = t; return e === "right" ? n -= i : e === "center" && (n -= i / 2), n } function ej(t, e, n) { let { y: i, height: r } = t; return e === "top" ? i += n : e === "bottom" ? i -= r + n : i -= r / 2, i } function iv(t, e, n, i) { const { caretSize: r, caretPadding: s, cornerRadius: o } = t, { xAlign: a, yAlign: l } = n, c = r + s, { topLeft: u, topRight: d, bottomLeft: f, bottomRight: h } = Zi(o); let m = JL(e, a); const p = ej(e, l, c); return l === "center" ? a === "left" ? m += c : a === "right" && (m -= c) : a === "left" ? m -= Math.max(u, f) + r : a === "right" && (m += Math.max(d, h) + r), { x: Xe(m, 0, i.width - e.width), y: Xe(p, 0, i.height - e.height) } } function Qa(t, e, n) { const i = Je(n.padding); return e === "center" ? t.x + t.width / 2 : e === "right" ? t.x + t.width - i.right : t.x + i.left } function rv(t) { return on([], kn(t)) } function tj(t, e, n) { return Di(t, { tooltip: e, tooltipItems: n, type: "tooltip" }) } function sv(t, e) { const n = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks; return n ? t.override(n) : t } const C_ = { beforeTitle: _n, title(t) { if (t.length > 0) { const e = t[0], n = e.chart.data.labels, i = n ? n.length : 0; if (this && this.options && this.options.mode === "dataset") return e.dataset.label || ""; if (e.label) return e.label; if (i > 0 && e.dataIndex < i) return n[e.dataIndex] } return "" }, afterTitle: _n, beforeBody: _n, beforeLabel: _n, label(t) { if (this && this.options && this.options.mode === "dataset") return t.label + ": " + t.formattedValue || t.formattedValue; let e = t.dataset.label || ""; e && (e += ": "); const n = t.formattedValue; return te(n) || (e += n), e }, labelColor(t) { const n = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex); return { borderColor: n.borderColor, backgroundColor: n.backgroundColor, borderWidth: n.borderWidth, borderDash: n.borderDash, borderDashOffset: n.borderDashOffset, borderRadius: 0 } }, labelTextColor() { return this.options.bodyColor }, labelPointStyle(t) { const n = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex); return { pointStyle: n.pointStyle, rotation: n.rotation } }, afterLabel: _n, afterBody: _n, beforeFooter: _n, footer: _n, afterFooter: _n }; function gt(t, e, n, i) { const r = t[e].call(n, i); return typeof r > "u" ? C_[e].call(n, i) : r } class Yf extends Wn { constructor(e) { super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = e.chart, this.options = e.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0 } initialize(e) { this.options = e, this._cachedAnimations = void 0, this.$context = void 0 } _resolveAnimations() { const e = this._cachedAnimations; if (e) return e; const n = this.chart, i = this.options.setContext(this.getContext()), r = i.enabled && n.options.animation && i.animations, s = new s_(this.chart, r); return r._cacheable && (this._cachedAnimations = Object.freeze(s)), s } getContext() { return this.$context || (this.$context = tj(this.chart.getContext(), this, this._tooltipItems)) } getTitle(e, n) { const { callbacks: i } = n, r = gt(i, "beforeTitle", this, e), s = gt(i, "title", this, e), o = gt(i, "afterTitle", this, e); let a = []; return a = on(a, kn(r)), a = on(a, kn(s)), a = on(a, kn(o)), a } getBeforeBody(e, n) { return rv(gt(n.callbacks, "beforeBody", this, e)) } getBody(e, n) { const { callbacks: i } = n, r = []; return ce(e, s => { const o = { before: [], lines: [], after: [] }, a = sv(i, s); on(o.before, kn(gt(a, "beforeLabel", this, s))), on(o.lines, gt(a, "label", this, s)), on(o.after, kn(gt(a, "afterLabel", this, s))), r.push(o) }), r } getAfterBody(e, n) { return rv(gt(n.callbacks, "afterBody", this, e)) } getFooter(e, n) { const { callbacks: i } = n, r = gt(i, "beforeFooter", this, e), s = gt(i, "footer", this, e), o = gt(i, "afterFooter", this, e); let a = []; return a = on(a, kn(r)), a = on(a, kn(s)), a = on(a, kn(o)), a } _createItems(e) { const n = this._active, i = this.chart.data, r = [], s = [], o = []; let a = [], l, c; for (l = 0, c = n.length; l < c; ++l)a.push(GL(this.chart, n[l])); return e.filter && (a = a.filter((u, d, f) => e.filter(u, d, f, i))), e.itemSort && (a = a.sort((u, d) => e.itemSort(u, d, i))), ce(a, u => { const d = sv(e.callbacks, u); r.push(gt(d, "labelColor", this, u)), s.push(gt(d, "labelPointStyle", this, u)), o.push(gt(d, "labelTextColor", this, u)) }), this.labelColors = r, this.labelPointStyles = s, this.labelTextColors = o, this.dataPoints = a, a } update(e, n) { const i = this.options.setContext(this.getContext()), r = this._active; let s, o = []; if (!r.length) this.opacity !== 0 && (s = { opacity: 0 }); else { const a = Ns[i.position].call(this, r, this._eventPosition); o = this._createItems(i), this.title = this.getTitle(o, i), this.beforeBody = this.getBeforeBody(o, i), this.body = this.getBody(o, i), this.afterBody = this.getAfterBody(o, i), this.footer = this.getFooter(o, i); const l = this._size = tv(this, i), c = Object.assign({}, a, l), u = nv(this.chart, i, c), d = iv(i, c, u, this.chart); this.xAlign = u.xAlign, this.yAlign = u.yAlign, s = { opacity: 1, x: d.x, y: d.y, width: l.width, height: l.height, caretX: a.x, caretY: a.y } } this._tooltipItems = o, this.$context = void 0, s && this._resolveAnimations().update(this, s), e && i.external && i.external.call(this, { chart: this.chart, tooltip: this, replay: n }) } drawCaret(e, n, i, r) { const s = this.getCaretPosition(e, i, r); n.lineTo(s.x1, s.y1), n.lineTo(s.x2, s.y2), n.lineTo(s.x3, s.y3) } getCaretPosition(e, n, i) { const { xAlign: r, yAlign: s } = this, { caretSize: o, cornerRadius: a } = i, { topLeft: l, topRight: c, bottomLeft: u, bottomRight: d } = Zi(a), { x: f, y: h } = e, { width: m, height: p } = n; let x, y, g, v, b, _; return s === "center" ? (b = h + p / 2, r === "left" ? (x = f, y = x - o, v = b + o, _ = b - o) : (x = f + m, y = x + o, v = b - o, _ = b + o), g = x) : (r === "left" ? y = f + Math.max(l, u) + o : r === "right" ? y = f + m - Math.max(c, d) - o : y = this.caretX, s === "top" ? (v = h, b = v - o, x = y - o, g = y + o) : (v = h + p, b = v + o, x = y + o, g = y - o), _ = v), { x1: x, x2: y, x3: g, y1: v, y2: b, y3: _ } } drawTitle(e, n, i) { const r = this.title, s = r.length; let o, a, l; if (s) { const c = $r(i.rtl, this.x, this.width); for (e.x = Qa(this, i.titleAlign, i), n.textAlign = c.textAlign(i.titleAlign), n.textBaseline = "middle", o = ze(i.titleFont), a = i.titleSpacing, n.fillStyle = i.titleColor, n.font = o.string, l = 0; l < s; ++l)n.fillText(r[l], c.x(e.x), e.y + o.lineHeight / 2), e.y += o.lineHeight + a, l + 1 === s && (e.y += i.titleMarginBottom - a) } } _drawColorBox(e, n, i, r, s) { const o = this.labelColors[i], a = this.labelPointStyles[i], { boxHeight: l, boxWidth: c, boxPadding: u } = s, d = ze(s.bodyFont), f = Qa(this, "left", s), h = r.x(f), m = l < d.lineHeight ? (d.lineHeight - l) / 2 : 0, p = n.y + m; if (s.usePointStyle) { const x = { radius: Math.min(c, l) / 2, pointStyle: a.pointStyle, rotation: a.rotation, borderWidth: 1 }, y = r.leftForLtr(h, c) + c / 2, g = p + l / 2; e.strokeStyle = s.multiKeyBackground, e.fillStyle = s.multiKeyBackground, zf(e, x, y, g), e.strokeStyle = o.borderColor, e.fillStyle = o.backgroundColor, zf(e, x, y, g) } else { e.lineWidth = ne(o.borderWidth) ? Math.max(...Object.values(o.borderWidth)) : o.borderWidth || 1, e.strokeStyle = o.borderColor, e.setLineDash(o.borderDash || []), e.lineDashOffset = o.borderDashOffset || 0; const x = r.leftForLtr(h, c - u), y = r.leftForLtr(r.xPlus(h, 1), c - u - 2), g = Zi(o.borderRadius); Object.values(g).some(v => v !== 0) ? (e.beginPath(), e.fillStyle = s.multiKeyBackground, Io(e, { x, y: p, w: c, h: l, radius: g }), e.fill(), e.stroke(), e.fillStyle = o.backgroundColor, e.beginPath(), Io(e, { x: y, y: p + 1, w: c - 2, h: l - 2, radius: g }), e.fill()) : (e.fillStyle = s.multiKeyBackground, e.fillRect(x, p, c, l), e.strokeRect(x, p, c, l), e.fillStyle = o.backgroundColor, e.fillRect(y, p + 1, c - 2, l - 2)) } e.fillStyle = this.labelTextColors[i] } drawBody(e, n, i) { const { body: r } = this, { bodySpacing: s, bodyAlign: o, displayColors: a, boxHeight: l, boxWidth: c, boxPadding: u } = i, d = ze(i.bodyFont); let f = d.lineHeight, h = 0; const m = $r(i.rtl, this.x, this.width), p = function (P) { n.fillText(P, m.x(e.x + h), e.y + f / 2), e.y += f + s }, x = m.textAlign(o); let y, g, v, b, _, k, S; for (n.textAlign = o, n.textBaseline = "middle", n.font = d.string, e.x = Qa(this, x, i), n.fillStyle = i.bodyColor, ce(this.beforeBody, p), h = a && x !== "right" ? o === "center" ? c / 2 + u : c + 2 + u : 0, b = 0, k = r.length; b < k; ++b) { for (y = r[b], g = this.labelTextColors[b], n.fillStyle = g, ce(y.before, p), v = y.lines, a && v.length && (this._drawColorBox(n, e, b, m, i), f = Math.max(d.lineHeight, l)), _ = 0, S = v.length; _ < S; ++_)p(v[_]), f = d.lineHeight; ce(y.after, p) } h = 0, f = d.lineHeight, ce(this.afterBody, p), e.y -= s } drawFooter(e, n, i) { const r = this.footer, s = r.length; let o, a; if (s) { const l = $r(i.rtl, this.x, this.width); for (e.x = Qa(this, i.footerAlign, i), e.y += i.footerMarginTop, n.textAlign = l.textAlign(i.footerAlign), n.textBaseline = "middle", o = ze(i.footerFont), n.fillStyle = i.footerColor, n.font = o.string, a = 0; a < s; ++a)n.fillText(r[a], l.x(e.x), e.y + o.lineHeight / 2), e.y += o.lineHeight + i.footerSpacing } } drawBackground(e, n, i, r) { const { xAlign: s, yAlign: o } = this, { x: a, y: l } = e, { width: c, height: u } = i, { topLeft: d, topRight: f, bottomLeft: h, bottomRight: m } = Zi(r.cornerRadius); n.fillStyle = r.backgroundColor, n.strokeStyle = r.borderColor, n.lineWidth = r.borderWidth, n.beginPath(), n.moveTo(a + d, l), o === "top" && this.drawCaret(e, n, i, r), n.lineTo(a + c - f, l), n.quadraticCurveTo(a + c, l, a + c, l + f), o === "center" && s === "right" && this.drawCaret(e, n, i, r), n.lineTo(a + c, l + u - m), n.quadraticCurveTo(a + c, l + u, a + c - m, l + u), o === "bottom" && this.drawCaret(e, n, i, r), n.lineTo(a + h, l + u), n.quadraticCurveTo(a, l + u, a, l + u - h), o === "center" && s === "left" && this.drawCaret(e, n, i, r), n.lineTo(a, l + d), n.quadraticCurveTo(a, l, a + d, l), n.closePath(), n.fill(), r.borderWidth > 0 && n.stroke() } _updateAnimationTarget(e) { const n = this.chart, i = this.$animations, r = i && i.x, s = i && i.y; if (r || s) { const o = Ns[e.position].call(this, this._active, this._eventPosition); if (!o) return; const a = this._size = tv(this, e), l = Object.assign({}, o, this._size), c = nv(n, e, l), u = iv(e, l, c, n); (r._to !== u.x || s._to !== u.y) && (this.xAlign = c.xAlign, this.yAlign = c.yAlign, this.width = a.width, this.height = a.height, this.caretX = o.x, this.caretY = o.y, this._resolveAnimations().update(this, u)) } } _willRender() { return !!this.opacity } draw(e) { const n = this.options.setContext(this.getContext()); let i = this.opacity; if (!i) return; this._updateAnimationTarget(n); const r = { width: this.width, height: this.height }, s = { x: this.x, y: this.y }; i = Math.abs(i) < .001 ? 0 : i; const o = Je(n.padding), a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length; n.enabled && a && (e.save(), e.globalAlpha = i, this.drawBackground(s, e, r, n), e_(e, n.textDirection), s.y += o.top, this.drawTitle(s, e, n), this.drawBody(s, e, n), this.drawFooter(s, e, n), t_(e, n.textDirection), e.restore()) } getActiveElements() { return this._active || [] } setActiveElements(e, n) { const i = this._active, r = e.map(({ datasetIndex: a, index: l }) => { const c = this.chart.getDatasetMeta(a); if (!c) throw new Error("Cannot find a dataset at index " + a); return { datasetIndex: a, element: c.data[l], index: l } }), s = !ac(i, r), o = this._positionChanged(r, n); (s || o) && (this._active = r, this._eventPosition = n, this._ignoreReplayEvents = !0, this.update(!0)) } handleEvent(e, n, i = !0) { if (n && this._ignoreReplayEvents) return !1; this._ignoreReplayEvents = !1; const r = this.options, s = this._active || [], o = this._getActiveElements(e, s, n, i), a = this._positionChanged(o, e), l = n || !ac(o, s) || a; return l && (this._active = o, (r.enabled || r.external) && (this._eventPosition = { x: e.x, y: e.y }, this.update(!0, n))), l } _getActiveElements(e, n, i, r) { const s = this.options; if (e.type === "mouseout") return []; if (!r) return n; const o = this.chart.getElementsAtEventForMode(e, s.mode, s, i); return s.reverse && o.reverse(), o } _positionChanged(e, n) { const { caretX: i, caretY: r, options: s } = this, o = Ns[s.position].call(this, e, n); return o !== !1 && (i !== o.x || r !== o.y) } } F(Yf, "positioners", Ns); var nj = { id: "tooltip", _element: Yf, positioners: Ns, afterInit(t, e, n) { n && (t.tooltip = new Yf({ chart: t, options: n })) }, beforeUpdate(t, e, n) { t.tooltip && t.tooltip.initialize(n) }, reset(t, e, n) { t.tooltip && t.tooltip.initialize(n) }, afterDraw(t) { const e = t.tooltip; if (e && e._willRender()) { const n = { tooltip: e }; if (t.notifyPlugins("beforeTooltipDraw", { ...n, cancelable: !0 }) === !1) return; e.draw(t.ctx), t.notifyPlugins("afterTooltipDraw", n) } }, afterEvent(t, e) { if (t.tooltip) { const n = e.replay; t.tooltip.handleEvent(e.event, n, e.inChartArea) && (e.changed = !0) } }, defaults: { enabled: !0, external: null, position: "average", backgroundColor: "rgba(0,0,0,0.8)", titleColor: "#fff", titleFont: { weight: "bold" }, titleSpacing: 2, titleMarginBottom: 6, titleAlign: "left", bodyColor: "#fff", bodySpacing: 2, bodyFont: {}, bodyAlign: "left", footerColor: "#fff", footerSpacing: 2, footerMarginTop: 6, footerFont: { weight: "bold" }, footerAlign: "left", padding: 6, caretPadding: 2, caretSize: 5, cornerRadius: 6, boxHeight: (t, e) => e.bodyFont.size, boxWidth: (t, e) => e.bodyFont.size, multiKeyBackground: "#fff", displayColors: !0, boxPadding: 0, borderColor: "rgba(0,0,0,0)", borderWidth: 0, animation: { duration: 400, easing: "easeOutQuart" }, animations: { numbers: { type: "number", properties: ["x", "y", "width", "height", "caretX", "caretY"] }, opacity: { easing: "linear", duration: 200 } }, callbacks: C_ }, defaultRoutes: { bodyFont: "font", footerFont: "font", titleFont: "font" }, descriptors: { _scriptable: t => t !== "filter" && t !== "itemSort" && t !== "external", _indexable: !1, callbacks: { _scriptable: !1, _indexable: !1 }, animation: { _fallback: !1 }, animations: { _fallback: "animation" } }, additionalOptionScopes: ["interaction"] }, ij = Object.freeze({ __proto__: null, Colors: mL, Decimation: xL, Filler: VL, Legend: UL, SubTitle: XL, Title: KL, Tooltip: nj }); const rj = (t, e, n, i) => (typeof e == "string" ? (n = t.push(e) - 1, i.unshift({ index: n, label: e })) : isNaN(e) && (n = null), n); function sj(t, e, n, i) { const r = t.indexOf(e); if (r === -1) return rj(t, e, n, i); const s = t.lastIndexOf(e); return r !== s ? n : r } const oj = (t, e) => t === null ? null : Xe(Math.round(t), 0, e); function ov(t) { const e = this.getLabels(); return t >= 0 && t < e.length ? e[t] : t } class Kf extends pr { constructor(e) { super(e), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [] } init(e) { const n = this._addedLabels; if (n.length) { const i = this.getLabels(); for (const { index: r, label: s } of n) i[r] === s && i.splice(r, 1); this._addedLabels = [] } super.init(e) } parse(e, n) { if (te(e)) return null; const i = this.getLabels(); return n = isFinite(n) && i[n] === e ? n : sj(i, e, Q(n, e), this._addedLabels), oj(n, i.length - 1) } determineDataLimits() { const { minDefined: e, maxDefined: n } = this.getUserBounds(); let { min: i, max: r } = this.getMinMax(!0); this.options.bounds === "ticks" && (e || (i = 0), n || (r = this.getLabels().length - 1)), this.min = i, this.max = r } buildTicks() { const e = this.min, n = this.max, i = this.options.offset, r = []; let s = this.getLabels(); s = e === 0 && n === s.length - 1 ? s : s.slice(e, n + 1), this._valueRange = Math.max(s.length - (i ? 0 : 1), 1), this._startValue = this.min - (i ? .5 : 0); for (let o = e; o <= n; o++)r.push({ value: o }); return r } getLabelForValue(e) { return ov.call(this, e) } configure() { super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels) } getPixelForValue(e) { return typeof e != "number" && (e = this.parse(e)), e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange) } getPixelForTick(e) { const n = this.ticks; return e < 0 || e > n.length - 1 ? null : this.getPixelForValue(n[e].value) } getValueForPixel(e) { return Math.round(this._startValue + this.getDecimalForPixel(e) * this._valueRange) } getBasePixel() { return this.bottom } } F(Kf, "id", "category"), F(Kf, "defaults", { ticks: { callback: ov } }); function aj(t, e) { const n = [], { bounds: r, step: s, min: o, max: a, precision: l, count: c, maxTicks: u, maxDigits: d, includeBounds: f } = t, h = s || 1, m = u - 1, { min: p, max: x } = e, y = !te(o), g = !te(a), v = !te(c), b = (x - p) / (d + 1); let _ = n0((x - p) / m / h) * h, k, S, P, T; if (_ < 1e-14 && !y && !g) return [{ value: p }, { value: x }]; T = Math.ceil(x / _) - Math.floor(p / _), T > m && (_ = n0(T * _ / m / h) * h), te(l) || (k = Math.pow(10, l), _ = Math.ceil(_ * k) / k), r === "ticks" ? (S = Math.floor(p / _) * _, P = Math.ceil(x / _) * _) : (S = p, P = x), y && g && s && n5((a - o) / s, _ / 1e3) ? (T = Math.round(Math.min((a - o) / _, u)), _ = (a - o) / T, S = o, P = a) : v ? (S = y ? o : S, P = g ? a : P, T = c - 1, _ = (P - S) / T) : (T = (P - S) / _, no(T, Math.round(T), _ / 1e3) ? T = Math.round(T) : T = Math.ceil(T)); const D = Math.max(i0(_), i0(S)); k = Math.pow(10, te(l) ? D : l), S = Math.round(S * k) / k, P = Math.round(P * k) / k; let A = 0; for (y && (f && S !== o ? (n.push({ value: o }), S < o && A++, no(Math.round((S + A * _) * k) / k, o, av(o, b, t)) && A++) : S < o && A++); A < T; ++A)n.push({ value: Math.round((S + A * _) * k) / k }); return g && f && P !== a ? n.length && no(n[n.length - 1].value, a, av(a, b, t)) ? n[n.length - 1].value = a : n.push({ value: a }) : (!g || P === a) && n.push({ value: P }), n } function av(t, e, { horizontal: n, minRotation: i }) { const r = Qt(i), s = (n ? Math.sin(r) : Math.cos(r)) || .001, o = .75 * e * ("" + t).length; return Math.min(e / s, o) } class mc extends pr { constructor(e) { super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0 } parse(e, n) { return te(e) || (typeof e == "number" || e instanceof Number) && !isFinite(+e) ? null : +e } handleTickRangeOptions() { const { beginAtZero: e } = this.options, { minDefined: n, maxDefined: i } = this.getUserBounds(); let { min: r, max: s } = this; const o = l => r = n ? r : l, a = l => s = i ? s : l; if (e) { const l = gn(r), c = gn(s); l < 0 && c < 0 ? a(0) : l > 0 && c > 0 && o(0) } if (r === s) { let l = s === 0 ? 1 : Math.abs(s * .05); a(s + l), e || o(r - l) } this.min = r, this.max = s } getTickLimit() { const e = this.options.ticks; let { maxTicksLimit: n, stepSize: i } = e, r; return i ? (r = Math.ceil(this.max / i) - Math.floor(this.min / i) + 1, r > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${i} would result generating up to ${r} ticks. Limiting to 1000.`), r = 1e3)) : (r = this.computeTickLimit(), n = n || 11), n && (r = Math.min(n, r)), r } computeTickLimit() { return Number.POSITIVE_INFINITY } buildTicks() { const e = this.options, n = e.ticks; let i = this.getTickLimit(); i = Math.max(2, i); const r = { maxTicks: i, bounds: e.bounds, min: e.min, max: e.max, precision: n.precision, step: n.stepSize, count: n.count, maxDigits: this._maxDigits(), horizontal: this.isHorizontal(), minRotation: n.minRotation || 0, includeBounds: n.includeBounds !== !1 }, s = this._range || this, o = aj(r, s); return e.bounds === "ticks" && Ab(o, this, "value"), e.reverse ? (o.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), o } configure() { const e = this.ticks; let n = this.min, i = this.max; if (super.configure(), this.options.offset && e.length) { const r = (i - n) / Math.max(e.length - 1, 1) / 2; n -= r, i += r } this._startValue = n, this._endValue = i, this._valueRange = i - n } getLabelForValue(e) { return sa(e, this.chart.options.locale, this.options.ticks.format) } } class Xf extends mc { determineDataLimits() { const { min: e, max: n } = this.getMinMax(!0); this.min = Oe(e) ? e : 0, this.max = Oe(n) ? n : 1, this.handleTickRangeOptions() } computeTickLimit() { const e = this.isHorizontal(), n = e ? this.width : this.height, i = Qt(this.options.ticks.minRotation), r = (e ? Math.sin(i) : Math.cos(i)) || .001, s = this._resolveTickFontOptions(0); return Math.ceil(n / Math.min(40, s.lineHeight / r)) } getPixelForValue(e) { return e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange) } getValueForPixel(e) { return this._startValue + this.getDecimalForPixel(e) * this._valueRange } } F(Xf, "id", "linear"), F(Xf, "defaults", { ticks: { callback: qc.formatters.numeric } }); const zo = t => Math.floor(ri(t)), Fi = (t, e) => Math.pow(10, zo(t) + e); function lv(t) { return t / Math.pow(10, zo(t)) === 1 } function cv(t, e, n) { const i = Math.pow(10, n), r = Math.floor(t / i); return Math.ceil(e / i) - r } function lj(t, e) { const n = e - t; let i = zo(n); for (; cv(t, e, i) > 10;)i++; for (; cv(t, e, i) < 10;)i--; return Math.min(i, zo(t)) } function cj(t, { min: e, max: n }) { e = Pt(t.min, e); const i = [], r = zo(e); let s = lj(e, n), o = s < 0 ? Math.pow(10, Math.abs(s)) : 1; const a = Math.pow(10, s), l = r > s ? Math.pow(10, r) : 0, c = Math.round((e - l) * o) / o, u = Math.floor((e - l) / a / 10) * a * 10; let d = Math.floor((c - u) / Math.pow(10, s)), f = Pt(t.min, Math.round((l + u + d * Math.pow(10, s)) * o) / o); for (; f < n;)i.push({ value: f, major: lv(f), significand: d }), d >= 10 ? d = d < 15 ? 15 : 20 : d++, d >= 20 && (s++, d = 2, o = s >= 0 ? 1 : o), f = Math.round((l + u + d * Math.pow(10, s)) * o) / o; const h = Pt(t.max, f); return i.push({ value: h, major: lv(h), significand: d }), i } class Gf extends pr { constructor(e) { super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0 } parse(e, n) { const i = mc.prototype.parse.apply(this, [e, n]); if (i === 0) { this._zero = !0; return } return Oe(i) && i > 0 ? i : null } determineDataLimits() { const { min: e, max: n } = this.getMinMax(!0); this.min = Oe(e) ? Math.max(0, e) : null, this.max = Oe(n) ? Math.max(0, n) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !Oe(this._userMin) && (this.min = e === Fi(this.min, 0) ? Fi(this.min, -1) : Fi(this.min, 0)), this.handleTickRangeOptions() } handleTickRangeOptions() { const { minDefined: e, maxDefined: n } = this.getUserBounds(); let i = this.min, r = this.max; const s = a => i = e ? i : a, o = a => r = n ? r : a; i === r && (i <= 0 ? (s(1), o(10)) : (s(Fi(i, -1)), o(Fi(r, 1)))), i <= 0 && s(Fi(r, -1)), r <= 0 && o(Fi(i, 1)), this.min = i, this.max = r } buildTicks() { const e = this.options, n = { min: this._userMin, max: this._userMax }, i = cj(n, this); return e.bounds === "ticks" && Ab(i, this, "value"), e.reverse ? (i.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), i } getLabelForValue(e) { return e === void 0 ? "0" : sa(e, this.chart.options.locale, this.options.ticks.format) } configure() { const e = this.min; super.configure(), this._startValue = ri(e), this._valueRange = ri(this.max) - ri(e) } getPixelForValue(e) { return (e === void 0 || e === 0) && (e = this.min), e === null || isNaN(e) ? NaN : this.getPixelForDecimal(e === this.min ? 0 : (ri(e) - this._startValue) / this._valueRange) } getValueForPixel(e) { const n = this.getDecimalForPixel(e); return Math.pow(10, this._startValue + n * this._valueRange) } } F(Gf, "id", "logarithmic"), F(Gf, "defaults", { ticks: { callback: qc.formatters.logarithmic, major: { enabled: !0 } } }); function Qf(t) { const e = t.ticks; if (e.display && t.display) { const n = Je(e.backdropPadding); return Q(e.font && e.font.size, Le.font.size) + n.height } return 0 } function uj(t, e, n) { return n = me(n) ? n : [n], { w: x5(t, e.string, n), h: n.length * e.lineHeight } } function uv(t, e, n, i, r) { return t === i || t === r ? { start: e - n / 2, end: e + n / 2 } : t < i || t > r ? { start: e - n, end: e } : { start: e, end: e + n } } function dj(t) { const e = { l: t.left + t._padding.left, r: t.right - t._padding.right, t: t.top + t._padding.top, b: t.bottom - t._padding.bottom }, n = Object.assign({}, e), i = [], r = [], s = t._pointLabels.length, o = t.options.pointLabels, a = o.centerPointLabels ? we / s : 0; for (let l = 0; l < s; l++) { const c = o.setContext(t.getPointLabelContext(l)); r[l] = c.padding; const u = t.getPointPosition(l, t.drawingArea + r[l], a), d = ze(c.font), f = uj(t.ctx, d, t._pointLabels[l]); i[l] = f; const h = Mt(t.getIndexAngle(l) + a), m = Math.round(Lp(h)), p = uv(m, u.x, f.w, 0, 180), x = uv(m, u.y, f.h, 90, 270); fj(n, e, h, p, x) } t.setCenterPoint(e.l - n.l, n.r - e.r, e.t - n.t, n.b - e.b), t._pointLabelItems = hj(t, i, r) } function fj(t, e, n, i, r) { const s = Math.abs(Math.sin(n)), o = Math.abs(Math.cos(n)); let a = 0, l = 0; i.start < e.l ? (a = (e.l - i.start) / s, t.l = Math.min(t.l, e.l - a)) : i.end > e.r && (a = (i.end - e.r) / s, t.r = Math.max(t.r, e.r + a)), r.start < e.t ? (l = (e.t - r.start) / o, t.t = Math.min(t.t, e.t - l)) : r.end > e.b && (l = (r.end - e.b) / o, t.b = Math.max(t.b, e.b + l)) } function hj(t, e, n) { const i = [], r = t._pointLabels.length, s = t.options, o = Qf(s) / 2, a = t.drawingArea, l = s.pointLabels.centerPointLabels ? we / r : 0; for (let c = 0; c < r; c++) { const u = t.getPointPosition(c, a + o + n[c], l), d = Math.round(Lp(Mt(u.angle + Re))), f = e[c], h = gj(u.y, f.h, d), m = pj(d), p = mj(u.x, f.w, m); i.push({ x: u.x, y: h, textAlign: m, left: p, top: h, right: p + f.w, bottom: h + f.h }) } return i } function pj(t) { return t === 0 || t === 180 ? "center" : t < 180 ? "left" : "right" } function mj(t, e, n) { return n === "right" ? t -= e : n === "center" && (t -= e / 2), t } function gj(t, e, n) { return n === 90 || n === 270 ? t -= e / 2 : (n > 270 || n < 90) && (t -= e), t } function yj(t, e) { const { ctx: n, options: { pointLabels: i } } = t; for (let r = e - 1; r >= 0; r--) { const s = i.setContext(t.getPointLabelContext(r)), o = ze(s.font), { x: a, y: l, textAlign: c, left: u, top: d, right: f, bottom: h } = t._pointLabelItems[r], { backdropColor: m } = s; if (!te(m)) { const p = Zi(s.borderRadius), x = Je(s.backdropPadding); n.fillStyle = m; const y = u - x.left, g = d - x.top, v = f - u + x.width, b = h - d + x.height; Object.values(p).some(_ => _ !== 0) ? (n.beginPath(), Io(n, { x: y, y: g, w: v, h: b, radius: p }), n.fill()) : n.fillRect(y, g, v, b) } cr(n, t._pointLabels[r], a, l + o.lineHeight / 2, o, { color: s.color, textAlign: c, textBaseline: "middle" }) } } function M_(t, e, n, i) { const { ctx: r } = t; if (n) r.arc(t.xCenter, t.yCenter, e, 0, ye); else { let s = t.getPointPosition(0, e); r.moveTo(s.x, s.y); for (let o = 1; o < i; o++)s = t.getPointPosition(o, e), r.lineTo(s.x, s.y) } } function vj(t, e, n, i, r) { const s = t.ctx, o = e.circular, { color: a, lineWidth: l } = e; !o && !i || !a || !l || n < 0 || (s.save(), s.strokeStyle = a, s.lineWidth = l, s.setLineDash(r.dash), s.lineDashOffset = r.dashOffset, s.beginPath(), M_(t, n, o, i), s.closePath(), s.stroke(), s.restore()) } function xj(t, e, n) { return Di(t, { label: n, index: e, type: "pointLabel" }) } class Fs extends mc { constructor(e) { super(e), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [] } setDimensions() { const e = this._padding = Je(Qf(this.options) / 2), n = this.width = this.maxWidth - e.width, i = this.height = this.maxHeight - e.height; this.xCenter = Math.floor(this.left + n / 2 + e.left), this.yCenter = Math.floor(this.top + i / 2 + e.top), this.drawingArea = Math.floor(Math.min(n, i) / 2) } determineDataLimits() { const { min: e, max: n } = this.getMinMax(!1); this.min = Oe(e) && !isNaN(e) ? e : 0, this.max = Oe(n) && !isNaN(n) ? n : 0, this.handleTickRangeOptions() } computeTickLimit() { return Math.ceil(this.drawingArea / Qf(this.options)) } generateTickLabels(e) { mc.prototype.generateTickLabels.call(this, e), this._pointLabels = this.getLabels().map((n, i) => { const r = de(this.options.pointLabels.callback, [n, i], this); return r || r === 0 ? r : "" }).filter((n, i) => this.chart.getDataVisibility(i)) } fit() { const e = this.options; e.display && e.pointLabels.display ? dj(this) : this.setCenterPoint(0, 0, 0, 0) } setCenterPoint(e, n, i, r) { this.xCenter += Math.floor((e - n) / 2), this.yCenter += Math.floor((i - r) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(e, n, i, r)) } getIndexAngle(e) { const n = ye / (this._pointLabels.length || 1), i = this.options.startAngle || 0; return Mt(e * n + Qt(i)) } getDistanceFromCenterForValue(e) { if (te(e)) return NaN; const n = this.drawingArea / (this.max - this.min); return this.options.reverse ? (this.max - e) * n : (e - this.min) * n } getValueForDistanceFromCenter(e) { if (te(e)) return NaN; const n = e / (this.drawingArea / (this.max - this.min)); return this.options.reverse ? this.max - n : this.min + n } getPointLabelContext(e) { const n = this._pointLabels || []; if (e >= 0 && e < n.length) { const i = n[e]; return xj(this.getContext(), e, i) } } getPointPosition(e, n, i = 0) { const r = this.getIndexAngle(e) - Re + i; return { x: Math.cos(r) * n + this.xCenter, y: Math.sin(r) * n + this.yCenter, angle: r } } getPointPositionForValue(e, n) { return this.getPointPosition(e, this.getDistanceFromCenterForValue(n)) } getBasePosition(e) { return this.getPointPositionForValue(e || 0, this.getBaseValue()) } getPointLabelPosition(e) { const { left: n, top: i, right: r, bottom: s } = this._pointLabelItems[e]; return { left: n, top: i, right: r, bottom: s } } drawBackground() { const { backgroundColor: e, grid: { circular: n } } = this.options; if (e) { const i = this.ctx; i.save(), i.beginPath(), M_(this, this.getDistanceFromCenterForValue(this._endValue), n, this._pointLabels.length), i.closePath(), i.fillStyle = e, i.fill(), i.restore() } } drawGrid() { const e = this.ctx, n = this.options, { angleLines: i, grid: r, border: s } = n, o = this._pointLabels.length; let a, l, c; if (n.pointLabels.display && yj(this, o), r.display && this.ticks.forEach((u, d) => { if (d !== 0) { l = this.getDistanceFromCenterForValue(u.value); const f = this.getContext(d), h = r.setContext(f), m = s.setContext(f); vj(this, h, l, o, m) } }), i.display) { for (e.save(), a = o - 1; a >= 0; a--) { const u = i.setContext(this.getPointLabelContext(a)), { color: d, lineWidth: f } = u; !f || !d || (e.lineWidth = f, e.strokeStyle = d, e.setLineDash(u.borderDash), e.lineDashOffset = u.borderDashOffset, l = this.getDistanceFromCenterForValue(n.ticks.reverse ? this.min : this.max), c = this.getPointPosition(a, l), e.beginPath(), e.moveTo(this.xCenter, this.yCenter), e.lineTo(c.x, c.y), e.stroke()) } e.restore() } } drawBorder() { } drawLabels() { const e = this.ctx, n = this.options, i = n.ticks; if (!i.display) return; const r = this.getIndexAngle(0); let s, o; e.save(), e.translate(this.xCenter, this.yCenter), e.rotate(r), e.textAlign = "center", e.textBaseline = "middle", this.ticks.forEach((a, l) => { if (l === 0 && !n.reverse) return; const c = i.setContext(this.getContext(l)), u = ze(c.font); if (s = this.getDistanceFromCenterForValue(this.ticks[l].value), c.showLabelBackdrop) { e.font = u.string, o = e.measureText(a.label).width, e.fillStyle = c.backdropColor; const d = Je(c.backdropPadding); e.fillRect(-o / 2 - d.left, -s - u.size / 2 - d.top, o + d.width, u.size + d.height) } cr(e, a.label, 0, -s, u, { color: c.color }) }), e.restore() } drawTitle() { } } F(Fs, "id", "radialLinear"), F(Fs, "defaults", { display: !0, animate: !0, position: "chartArea", angleLines: { display: !0, lineWidth: 1, borderDash: [], borderDashOffset: 0 }, grid: { circular: !1 }, startAngle: 0, ticks: { showLabelBackdrop: !0, callback: qc.formatters.numeric }, pointLabels: { backdropColor: void 0, backdropPadding: 2, display: !0, font: { size: 10 }, callback(e) { return e }, padding: 5, centerPointLabels: !1 } }), F(Fs, "defaultRoutes", { "angleLines.color": "borderColor", "pointLabels.color": "color", "ticks.color": "color" }), F(Fs, "descriptors", { angleLines: { _fallback: "grid" } }); const tu = { millisecond: { common: !0, size: 1, steps: 1e3 }, second: { common: !0, size: 1e3, steps: 60 }, minute: { common: !0, size: 6e4, steps: 60 }, hour: { common: !0, size: 36e5, steps: 24 }, day: { common: !0, size: 864e5, steps: 30 }, week: { common: !1, size: 6048e5, steps: 4 }, month: { common: !0, size: 2628e6, steps: 12 }, quarter: { common: !1, size: 7884e6, steps: 4 }, year: { common: !0, size: 3154e7 } }, xt = Object.keys(tu); function wj(t, e) { return t - e } function dv(t, e) { if (te(e)) return null; const n = t._adapter, { parser: i, round: r, isoWeekday: s } = t._parseOpts; let o = e; return typeof i == "function" && (o = i(o)), Oe(o) || (o = typeof i == "string" ? n.parse(o, i) : n.parse(o)), o === null ? null : (r && (o = r === "week" && (ts(s) || s === !0) ? n.startOf(o, "isoWeek", s) : n.startOf(o, r)), +o) } function fv(t, e, n, i) { const r = xt.length; for (let s = xt.indexOf(t); s < r - 1; ++s) { const o = tu[xt[s]], a = o.steps ? o.steps : Number.MAX_SAFE_INTEGER; if (o.common && Math.ceil((n - e) / (a * o.size)) <= i) return xt[s] } return xt[r - 1] } function bj(t, e, n, i, r) { for (let s = xt.length - 1; s >= xt.indexOf(n); s--) { const o = xt[s]; if (tu[o].common && t._adapter.diff(r, i, o) >= e - 1) return o } return xt[n ? xt.indexOf(n) : 0] } function _j(t) { for (let e = xt.indexOf(t) + 1, n = xt.length; e < n; ++e)if (tu[xt[e]].common) return xt[e] } function hv(t, e, n) { if (!n) t[e] = !0; else if (n.length) { const { lo: i, hi: r } = jp(n, e), s = n[i] >= e ? n[i] : n[r]; t[s] = !0 } } function Sj(t, e, n, i) { const r = t._adapter, s = +r.startOf(e[0].value, i), o = e[e.length - 1].value; let a, l; for (a = s; a <= o; a = +r.add(a, 1, i))l = n[a], l >= 0 && (e[l].major = !0); return e } function pv(t, e, n) { const i = [], r = {}, s = e.length; let o, a; for (o = 0; o < s; ++o)a = e[o], r[a] = o, i.push({ value: a, major: !1 }); return s === 0 || !n ? i : Sj(t, i, r, n) } class Bo extends pr { constructor(e) { super(e), this._cache = { data: [], labels: [], all: [] }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0 } init(e, n = {}) { const i = e.time || (e.time = {}), r = this._adapter = new A3._date(e.adapters.date); r.init(n), to(i.displayFormats, r.formats()), this._parseOpts = { parser: i.parser, round: i.round, isoWeekday: i.isoWeekday }, super.init(e), this._normalized = n.normalized } parse(e, n) { return e === void 0 ? null : dv(this, e) } beforeLayout() { super.beforeLayout(), this._cache = { data: [], labels: [], all: [] } } determineDataLimits() { const e = this.options, n = this._adapter, i = e.time.unit || "day"; let { min: r, max: s, minDefined: o, maxDefined: a } = this.getUserBounds(); function l(c) { !o && !isNaN(c.min) && (r = Math.min(r, c.min)), !a && !isNaN(c.max) && (s = Math.max(s, c.max)) } (!o || !a) && (l(this._getLabelBounds()), (e.bounds !== "ticks" || e.ticks.source !== "labels") && l(this.getMinMax(!1))), r = Oe(r) && !isNaN(r) ? r : +n.startOf(Date.now(), i), s = Oe(s) && !isNaN(s) ? s : +n.endOf(Date.now(), i) + 1, this.min = Math.min(r, s - 1), this.max = Math.max(r + 1, s) } _getLabelBounds() { const e = this.getLabelTimestamps(); let n = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY; return e.length && (n = e[0], i = e[e.length - 1]), { min: n, max: i } } buildTicks() { const e = this.options, n = e.time, i = e.ticks, r = i.source === "labels" ? this.getLabelTimestamps() : this._generate(); e.bounds === "ticks" && r.length && (this.min = this._userMin || r[0], this.max = this._userMax || r[r.length - 1]); const s = this.min, o = this.max, a = o5(r, s, o); return this._unit = n.unit || (i.autoSkip ? fv(n.minUnit, this.min, this.max, this._getLabelCapacity(s)) : bj(this, a.length, n.minUnit, this.min, this.max)), this._majorUnit = !i.major.enabled || this._unit === "year" ? void 0 : _j(this._unit), this.initOffsets(r), e.reverse && a.reverse(), pv(this, a, this._majorUnit) } afterAutoSkip() { this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map(e => +e.value)) } initOffsets(e = []) { let n = 0, i = 0, r, s; this.options.offset && e.length && (r = this.getDecimalForValue(e[0]), e.length === 1 ? n = 1 - r : n = (this.getDecimalForValue(e[1]) - r) / 2, s = this.getDecimalForValue(e[e.length - 1]), e.length === 1 ? i = s : i = (s - this.getDecimalForValue(e[e.length - 2])) / 2); const o = e.length < 3 ? .5 : .25; n = Xe(n, 0, o), i = Xe(i, 0, o), this._offsets = { start: n, end: i, factor: 1 / (n + 1 + i) } } _generate() { const e = this._adapter, n = this.min, i = this.max, r = this.options, s = r.time, o = s.unit || fv(s.minUnit, n, i, this._getLabelCapacity(n)), a = Q(r.ticks.stepSize, 1), l = o === "week" ? s.isoWeekday : !1, c = ts(l) || l === !0, u = {}; let d = n, f, h; if (c && (d = +e.startOf(d, "isoWeek", l)), d = +e.startOf(d, c ? "day" : o), e.diff(i, n, o) > 1e5 * a) throw new Error(n + " and " + i + " are too far apart with stepSize of " + a + " " + o); const m = r.ticks.source === "data" && this.getDataTimestamps(); for (f = d, h = 0; f < i; f = +e.add(f, a, o), h++)hv(u, f, m); return (f === i || r.bounds === "ticks" || h === 1) && hv(u, f, m), Object.keys(u).sort((p, x) => p - x).map(p => +p) } getLabelForValue(e) { const n = this._adapter, i = this.options.time; return i.tooltipFormat ? n.format(e, i.tooltipFormat) : n.format(e, i.displayFormats.datetime) } format(e, n) { const r = this.options.time.displayFormats, s = this._unit, o = n || r[s]; return this._adapter.format(e, o) } _tickFormatFunction(e, n, i, r) { const s = this.options, o = s.ticks.callback; if (o) return de(o, [e, n, i], this); const a = s.time.displayFormats, l = this._unit, c = this._majorUnit, u = l && a[l], d = c && a[c], f = i[n], h = c && d && f && f.major; return this._adapter.format(e, r || (h ? d : u)) } generateTickLabels(e) { let n, i, r; for (n = 0, i = e.length; n < i; ++n)r = e[n], r.label = this._tickFormatFunction(r.value, n, e) } getDecimalForValue(e) { return e === null ? NaN : (e - this.min) / (this.max - this.min) } getPixelForValue(e) { const n = this._offsets, i = this.getDecimalForValue(e); return this.getPixelForDecimal((n.start + i) * n.factor) } getValueForPixel(e) { const n = this._offsets, i = this.getDecimalForPixel(e) / n.factor - n.end; return this.min + i * (this.max - this.min) } _getLabelSize(e) { const n = this.options.ticks, i = this.ctx.measureText(e).width, r = Qt(this.isHorizontal() ? n.maxRotation : n.minRotation), s = Math.cos(r), o = Math.sin(r), a = this._resolveTickFontOptions(0).size; return { w: i * s + a * o, h: i * o + a * s } } _getLabelCapacity(e) { const n = this.options.time, i = n.displayFormats, r = i[n.unit] || i.millisecond, s = this._tickFormatFunction(e, 0, pv(this, [e], this._majorUnit), r), o = this._getLabelSize(s), a = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1; return a > 0 ? a : 1 } getDataTimestamps() { let e = this._cache.data || [], n, i; if (e.length) return e; const r = this.getMatchingVisibleMetas(); if (this._normalized && r.length) return this._cache.data = r[0].controller.getAllParsedValues(this); for (n = 0, i = r.length; n < i; ++n)e = e.concat(r[n].controller.getAllParsedValues(this)); return this._cache.data = this.normalize(e) } getLabelTimestamps() { const e = this._cache.labels || []; let n, i; if (e.length) return e; const r = this.getLabels(); for (n = 0, i = r.length; n < i; ++n)e.push(dv(this, r[n])); return this._cache.labels = this._normalized ? e : this.normalize(e) } normalize(e) { return Ib(e.sort(wj)) } } F(Bo, "id", "time"), F(Bo, "defaults", { bounds: "data", adapters: {}, time: { parser: !1, unit: !1, round: !1, isoWeekday: !1, minUnit: "millisecond", displayFormats: {} }, ticks: { source: "auto", callback: !1, major: { enabled: !1 } } }); function qa(t, e, n) { let i = 0, r = t.length - 1, s, o, a, l; n ? (e >= t[i].pos && e <= t[r].pos && ({ lo: i, hi: r } = Ln(t, "pos", e)), { pos: s, time: a } = t[i], { pos: o, time: l } = t[r]) : (e >= t[i].time && e <= t[r].time && ({ lo: i, hi: r } = Ln(t, "time", e)), { time: s, pos: a } = t[i], { time: o, pos: l } = t[r]); const c = o - s; return c ? a + (l - a) * (e - s) / c : a } class qf extends Bo { constructor(e) { super(e), this._table = [], this._minPos = void 0, this._tableRange = void 0 } initOffsets() { const e = this._getTimestampsForTable(), n = this._table = this.buildLookupTable(e); this._minPos = qa(n, this.min), this._tableRange = qa(n, this.max) - this._minPos, super.initOffsets(e) } buildLookupTable(e) { const { min: n, max: i } = this, r = [], s = []; let o, a, l, c, u; for (o = 0, a = e.length; o < a; ++o)c = e[o], c >= n && c <= i && r.push(c); if (r.length < 2) return [{ time: n, pos: 0 }, { time: i, pos: 1 }]; for (o = 0, a = r.length; o < a; ++o)u = r[o + 1], l = r[o - 1], c = r[o], Math.round((u + l) / 2) !== c && s.push({ time: c, pos: o / (a - 1) }); return s } _getTimestampsForTable() { let e = this._cache.all || []; if (e.length) return e; const n = this.getDataTimestamps(), i = this.getLabelTimestamps(); return n.length && i.length ? e = this.normalize(n.concat(i)) : e = n.length ? n : i, e = this._cache.all = e, e } getDecimalForValue(e) { return (qa(this._table, e) - this._minPos) / this._tableRange } getValueForPixel(e) { const n = this._offsets, i = this.getDecimalForPixel(e) / n.factor - n.end; return qa(this._table, i * this._tableRange + this._minPos, !0) } } F(qf, "id", "timeseries"), F(qf, "defaults", Bo.defaults); var kj = Object.freeze({ __proto__: null, CategoryScale: Kf, LinearScale: Xf, LogarithmicScale: Gf, RadialLinearScale: Fs, TimeScale: Bo, TimeSeriesScale: qf }); const Pj = [j3, cL, ij, kj], T_ = "label"; function mv(t, e) { typeof t == "function" ? t(e) : t && (t.current = e) } function Cj(t, e) { const n = t.options; n && e && Object.assign(n, e) } function E_(t, e) { t.labels = e } function D_(t, e) { let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : T_; const i = []; t.datasets = e.map(r => { const s = t.datasets.find(o => o[n] === r[n]); return !s || !r.data || i.includes(s) ? { ...r } : (i.push(s), Object.assign(s, r), s) }) } function Mj(t) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : T_; const n = { labels: [], datasets: [] }; return E_(n, t.labels), D_(n, t.datasets, e), n } function Tj(t, e) { const { height: n = 150, width: i = 300, redraw: r = !1, datasetIdKey: s, type: o, data: a, options: l, plugins: c = [], fallbackContent: u, updateMode: d, ...f } = t, h = M.useRef(null), m = M.useRef(), p = () => { h.current && (m.current = new aa(h.current, { type: o, data: Mj(a, s), options: l && { ...l }, plugins: c }), mv(e, m.current)) }, x = () => { mv(e, null), m.current && (m.current.destroy(), m.current = null) }; return M.useEffect(() => { !r && m.current && l && Cj(m.current, l) }, [r, l]), M.useEffect(() => { !r && m.current && E_(m.current.config.data, a.labels) }, [r, a.labels]), M.useEffect(() => { !r && m.current && a.datasets && D_(m.current.config.data, a.datasets, s) }, [r, a.datasets]), M.useEffect(() => { m.current && (r ? (x(), setTimeout(p)) : m.current.update(d)) }, [r, l, a.labels, a.datasets, d]), M.useEffect(() => { m.current && (x(), setTimeout(p)) }, [o]), M.useEffect(() => (p(), () => x()), []), Et.createElement("canvas", Object.assign({ ref: h, role: "img", height: n, width: i }, f), u) } const Ej = M.forwardRef(Tj); function Dj(t, e) { return aa.register(e), M.forwardRef((n, i) => Et.createElement(Ej, Object.assign({}, n, { ref: i, type: t }))) } const O_ = Dj("doughnut", si); aa.register(...Pj);/*!
 * chartjs-plugin-datalabels v2.2.0
 * https://chartjs-plugin-datalabels.netlify.app
 * (c) 2017-2022 chartjs-plugin-datalabels contributors
 * Released under the MIT license
 */var gv = function () { if (typeof window < "u") { if (window.devicePixelRatio) return window.devicePixelRatio; var t = window.screen; if (t) return (t.deviceXDPI || 1) / (t.logicalXDPI || 1) } return 1 }(), co = {
    toTextLines: function (t) {
        var e = [], n; for (t = [].concat(t); t.length;)n = t.pop(), typeof n == "string" ? e.unshift.apply(e, n.split(`
`)) : Array.isArray(n) ? t.push.apply(t, n) : te(t) || e.unshift("" + n); return e
    }, textSize: function (t, e, n) { var i = [].concat(e), r = i.length, s = t.font, o = 0, a; for (t.font = n.string, a = 0; a < r; ++a)o = Math.max(t.measureText(i[a]).width, o); return t.font = s, { height: r * n.lineHeight, width: o } }, bound: function (t, e, n) { return Math.max(t, Math.min(e, n)) }, arrayDiff: function (t, e) { var n = t.slice(), i = [], r, s, o, a; for (r = 0, o = e.length; r < o; ++r)a = e[r], s = n.indexOf(a), s === -1 ? i.push([a, 1]) : n.splice(s, 1); for (r = 0, o = n.length; r < o; ++r)i.push([n[r], -1]); return i }, rasterize: function (t) { return Math.round(t * gv) / gv }
}; function hd(t, e) { var n = e.x, i = e.y; if (n === null) return { x: 0, y: -1 }; if (i === null) return { x: 1, y: 0 }; var r = t.x - n, s = t.y - i, o = Math.sqrt(r * r + s * s); return { x: o ? r / o : 0, y: o ? s / o : -1 } } function Oj(t, e, n, i, r) { switch (r) { case "center": n = i = 0; break; case "bottom": n = 0, i = 1; break; case "right": n = 1, i = 0; break; case "left": n = -1, i = 0; break; case "top": n = 0, i = -1; break; case "start": n = -n, i = -i; break; case "end": break; default: r *= Math.PI / 180, n = Math.cos(r), i = Math.sin(r); break }return { x: t, y: e, vx: n, vy: i } } var Rj = 0, R_ = 1, L_ = 2, j_ = 4, A_ = 8; function Za(t, e, n) { var i = Rj; return t < n.left ? i |= R_ : t > n.right && (i |= L_), e < n.top ? i |= A_ : e > n.bottom && (i |= j_), i } function Lj(t, e) { for (var n = t.x0, i = t.y0, r = t.x1, s = t.y1, o = Za(n, i, e), a = Za(r, s, e), l, c, u; !(!(o | a) || o & a);)l = o || a, l & A_ ? (c = n + (r - n) * (e.top - i) / (s - i), u = e.top) : l & j_ ? (c = n + (r - n) * (e.bottom - i) / (s - i), u = e.bottom) : l & L_ ? (u = i + (s - i) * (e.right - n) / (r - n), c = e.right) : l & R_ && (u = i + (s - i) * (e.left - n) / (r - n), c = e.left), l === o ? (n = c, i = u, o = Za(n, i, e)) : (r = c, s = u, a = Za(r, s, e)); return { x0: n, x1: r, y0: i, y1: s } } function Ja(t, e) { var n = e.anchor, i = t, r, s; return e.clamp && (i = Lj(i, e.area)), n === "start" ? (r = i.x0, s = i.y0) : n === "end" ? (r = i.x1, s = i.y1) : (r = (i.x0 + i.x1) / 2, s = (i.y0 + i.y1) / 2), Oj(r, s, t.vx, t.vy, e.align) } var el = { arc: function (t, e) { var n = (t.startAngle + t.endAngle) / 2, i = Math.cos(n), r = Math.sin(n), s = t.innerRadius, o = t.outerRadius; return Ja({ x0: t.x + i * s, y0: t.y + r * s, x1: t.x + i * o, y1: t.y + r * o, vx: i, vy: r }, e) }, point: function (t, e) { var n = hd(t, e.origin), i = n.x * t.options.radius, r = n.y * t.options.radius; return Ja({ x0: t.x - i, y0: t.y - r, x1: t.x + i, y1: t.y + r, vx: n.x, vy: n.y }, e) }, bar: function (t, e) { var n = hd(t, e.origin), i = t.x, r = t.y, s = 0, o = 0; return t.horizontal ? (i = Math.min(t.x, t.base), s = Math.abs(t.base - t.x)) : (r = Math.min(t.y, t.base), o = Math.abs(t.base - t.y)), Ja({ x0: i, y0: r + o, x1: i + s, y1: r, vx: n.x, vy: n.y }, e) }, fallback: function (t, e) { var n = hd(t, e.origin); return Ja({ x0: t.x, y0: t.y, x1: t.x + (t.width || 0), y1: t.y + (t.height || 0), vx: n.x, vy: n.y }, e) } }, jn = co.rasterize; function jj(t) { var e = t.borderWidth || 0, n = t.padding, i = t.size.height, r = t.size.width, s = -r / 2, o = -i / 2; return { frame: { x: s - n.left - e, y: o - n.top - e, w: r + n.width + e * 2, h: i + n.height + e * 2 }, text: { x: s, y: o, w: r, h: i } } } function Aj(t, e) { var n = e.chart.getDatasetMeta(e.datasetIndex).vScale; if (!n) return null; if (n.xCenter !== void 0 && n.yCenter !== void 0) return { x: n.xCenter, y: n.yCenter }; var i = n.getBasePixel(); return t.horizontal ? { x: i, y: null } : { x: null, y: i } } function Nj(t) { return t instanceof oo ? el.arc : t instanceof ao ? el.point : t instanceof lo ? el.bar : el.fallback } function Fj(t, e, n, i, r, s) { var o = Math.PI / 2; if (s) { var a = Math.min(s, r / 2, i / 2), l = e + a, c = n + a, u = e + i - a, d = n + r - a; t.moveTo(e, c), l < u && c < d ? (t.arc(l, c, a, -Math.PI, -o), t.arc(u, c, a, -o, 0), t.arc(u, d, a, 0, o), t.arc(l, d, a, o, Math.PI)) : l < u ? (t.moveTo(l, n), t.arc(u, c, a, -o, o), t.arc(l, c, a, o, Math.PI + o)) : c < d ? (t.arc(l, c, a, -Math.PI, 0), t.arc(l, d, a, 0, Math.PI)) : t.arc(l, c, a, -Math.PI, Math.PI), t.closePath(), t.moveTo(e, n) } else t.rect(e, n, i, r) } function Ij(t, e, n) { var i = n.backgroundColor, r = n.borderColor, s = n.borderWidth; !i && (!r || !s) || (t.beginPath(), Fj(t, jn(e.x) + s / 2, jn(e.y) + s / 2, jn(e.w) - s, jn(e.h) - s, n.borderRadius), t.closePath(), i && (t.fillStyle = i, t.fill()), r && s && (t.strokeStyle = r, t.lineWidth = s, t.lineJoin = "miter", t.stroke())) } function Vj(t, e, n) { var i = n.lineHeight, r = t.w, s = t.x, o = t.y + i / 2; return e === "center" ? s += r / 2 : (e === "end" || e === "right") && (s += r), { h: i, w: r, x: s, y: o } } function zj(t, e, n) { var i = t.shadowBlur, r = n.stroked, s = jn(n.x), o = jn(n.y), a = jn(n.w); r && t.strokeText(e, s, o, a), n.filled && (i && r && (t.shadowBlur = 0), t.fillText(e, s, o, a), i && r && (t.shadowBlur = i)) } function Bj(t, e, n, i) { var r = i.textAlign, s = i.color, o = !!s, a = i.font, l = e.length, c = i.textStrokeColor, u = i.textStrokeWidth, d = c && u, f; if (!(!l || !o && !d)) for (n = Vj(n, r, a), t.font = a.string, t.textAlign = r, t.textBaseline = "middle", t.shadowBlur = i.textShadowBlur, t.shadowColor = i.textShadowColor, o && (t.fillStyle = s), d && (t.lineJoin = "round", t.lineWidth = u, t.strokeStyle = c), f = 0, l = e.length; f < l; ++f)zj(t, e[f], { stroked: d, filled: o, w: n.w, x: n.x, y: n.y + n.h * f }) } var N_ = function (t, e, n, i) { var r = this; r._config = t, r._index = i, r._model = null, r._rects = null, r._ctx = e, r._el = n }; yn(N_.prototype, { _modelize: function (t, e, n, i) { var r = this, s = r._index, o = ze(pe([n.font, {}], i, s)), a = pe([n.color, Le.color], i, s); return { align: pe([n.align, "center"], i, s), anchor: pe([n.anchor, "center"], i, s), area: i.chart.chartArea, backgroundColor: pe([n.backgroundColor, null], i, s), borderColor: pe([n.borderColor, null], i, s), borderRadius: pe([n.borderRadius, 0], i, s), borderWidth: pe([n.borderWidth, 0], i, s), clamp: pe([n.clamp, !1], i, s), clip: pe([n.clip, !1], i, s), color: a, display: t, font: o, lines: e, offset: pe([n.offset, 4], i, s), opacity: pe([n.opacity, 1], i, s), origin: Aj(r._el, i), padding: Je(pe([n.padding, 4], i, s)), positioner: Nj(r._el), rotation: pe([n.rotation, 0], i, s) * (Math.PI / 180), size: co.textSize(r._ctx, e, o), textAlign: pe([n.textAlign, "start"], i, s), textShadowBlur: pe([n.textShadowBlur, 0], i, s), textShadowColor: pe([n.textShadowColor, a], i, s), textStrokeColor: pe([n.textStrokeColor, a], i, s), textStrokeWidth: pe([n.textStrokeWidth, 0], i, s) } }, update: function (t) { var e = this, n = null, i = null, r = e._index, s = e._config, o, a, l, c = pe([s.display, !0], t, r); c && (o = t.dataset.data[r], a = Q(de(s.formatter, [o, t]), o), l = te(a) ? [] : co.toTextLines(a), l.length && (n = e._modelize(c, l, s, t), i = jj(n))), e._model = n, e._rects = i }, geometry: function () { return this._rects ? this._rects.frame : {} }, rotation: function () { return this._model ? this._model.rotation : 0 }, visible: function () { return this._model && this._model.opacity }, model: function () { return this._model }, draw: function (t, e) { var n = this, i = t.ctx, r = n._model, s = n._rects, o; this.visible() && (i.save(), r.clip && (o = r.area, i.beginPath(), i.rect(o.left, o.top, o.right - o.left, o.bottom - o.top), i.clip()), i.globalAlpha = co.bound(0, r.opacity, 1), i.translate(jn(e.x), jn(e.y)), i.rotate(r.rotation), Ij(i, s.frame, r), Bj(i, r.lines, s.text, r), i.restore()) } }); var Hj = Number.MIN_SAFE_INTEGER || -9007199254740991, Wj = Number.MAX_SAFE_INTEGER || 9007199254740991; function Ts(t, e, n) { var i = Math.cos(n), r = Math.sin(n), s = e.x, o = e.y; return { x: s + i * (t.x - s) - r * (t.y - o), y: o + r * (t.x - s) + i * (t.y - o) } } function yv(t, e) { var n = Wj, i = Hj, r = e.origin, s, o, a, l, c; for (s = 0; s < t.length; ++s)o = t[s], a = o.x - r.x, l = o.y - r.y, c = e.vx * a + e.vy * l, n = Math.min(n, c), i = Math.max(i, c); return { min: n, max: i } } function tl(t, e) { var n = e.x - t.x, i = e.y - t.y, r = Math.sqrt(n * n + i * i); return { vx: (e.x - t.x) / r, vy: (e.y - t.y) / r, origin: t, ln: r } } var F_ = function () { this._rotation = 0, this._rect = { x: 0, y: 0, w: 0, h: 0 } }; yn(F_.prototype, { center: function () { var t = this._rect; return { x: t.x + t.w / 2, y: t.y + t.h / 2 } }, update: function (t, e, n) { this._rotation = n, this._rect = { x: e.x + t.x, y: e.y + t.y, w: e.w, h: e.h } }, contains: function (t) { var e = this, n = 1, i = e._rect; return t = Ts(t, e.center(), -e._rotation), !(t.x < i.x - n || t.y < i.y - n || t.x > i.x + i.w + n * 2 || t.y > i.y + i.h + n * 2) }, intersects: function (t) { var e = this._points(), n = t._points(), i = [tl(e[0], e[1]), tl(e[0], e[3])], r, s, o; for (this._rotation !== t._rotation && i.push(tl(n[0], n[1]), tl(n[0], n[3])), r = 0; r < i.length; ++r)if (s = yv(e, i[r]), o = yv(n, i[r]), s.max < o.min || o.max < s.min) return !1; return !0 }, _points: function () { var t = this, e = t._rect, n = t._rotation, i = t.center(); return [Ts({ x: e.x, y: e.y }, i, n), Ts({ x: e.x + e.w, y: e.y }, i, n), Ts({ x: e.x + e.w, y: e.y + e.h }, i, n), Ts({ x: e.x, y: e.y + e.h }, i, n)] } }); function I_(t, e, n) { var i = e.positioner(t, e), r = i.vx, s = i.vy; if (!r && !s) return { x: i.x, y: i.y }; var o = n.w, a = n.h, l = e.rotation, c = Math.abs(o / 2 * Math.cos(l)) + Math.abs(a / 2 * Math.sin(l)), u = Math.abs(o / 2 * Math.sin(l)) + Math.abs(a / 2 * Math.cos(l)), d = 1 / Math.max(Math.abs(r), Math.abs(s)); return c *= r * d, u *= s * d, c += e.offset * r, u += e.offset * s, { x: i.x + c, y: i.y + u } } function $j(t, e) { var n, i, r, s; for (n = t.length - 1; n >= 0; --n)for (r = t[n].$layout, i = n - 1; i >= 0 && r._visible; --i)s = t[i].$layout, s._visible && r._box.intersects(s._box) && e(r, s); return t } function Uj(t) { var e, n, i, r, s, o, a; for (e = 0, n = t.length; e < n; ++e)i = t[e], r = i.$layout, r._visible && (a = new Proxy(i._el, { get: (l, c) => l.getProps([c], !0)[c] }), s = i.geometry(), o = I_(a, i.model(), s), r._box.update(o, s, i.rotation())); return $j(t, function (l, c) { var u = l._hidable, d = c._hidable; u && d || d ? c._visible = !1 : u && (l._visible = !1) }) } var uo = { prepare: function (t) { var e = [], n, i, r, s, o; for (n = 0, r = t.length; n < r; ++n)for (i = 0, s = t[n].length; i < s; ++i)o = t[n][i], e.push(o), o.$layout = { _box: new F_, _hidable: !1, _visible: !0, _set: n, _idx: o._index }; return e.sort(function (a, l) { var c = a.$layout, u = l.$layout; return c._idx === u._idx ? u._set - c._set : u._idx - c._idx }), this.update(e), e }, update: function (t) { var e = !1, n, i, r, s, o; for (n = 0, i = t.length; n < i; ++n)r = t[n], s = r.model(), o = r.$layout, o._hidable = s && s.display === "auto", o._visible = r.visible(), e |= o._hidable; e && Uj(t) }, lookup: function (t, e) { var n, i; for (n = t.length - 1; n >= 0; --n)if (i = t[n].$layout, i && i._visible && i._box.contains(e)) return t[n]; return null }, draw: function (t, e) { var n, i, r, s, o, a; for (n = 0, i = e.length; n < i; ++n)r = e[n], s = r.$layout, s._visible && (o = r.geometry(), a = I_(r._el, r.model(), o), s._box.update(a, o, r.rotation()), r.draw(t, a)) } }, Yj = function (t) { if (te(t)) return null; var e = t, n, i, r; if (ne(t)) if (!te(t.label)) e = t.label; else if (!te(t.r)) e = t.r; else for (e = "", n = Object.keys(t), r = 0, i = n.length; r < i; ++r)e += (r !== 0 ? ", " : "") + n[r] + ": " + t[n[r]]; return "" + e }, Kj = { align: "center", anchor: "center", backgroundColor: null, borderColor: null, borderRadius: 0, borderWidth: 0, clamp: !1, clip: !1, color: void 0, display: !0, font: { family: void 0, lineHeight: 1.2, size: void 0, style: void 0, weight: null }, formatter: Yj, labels: void 0, listeners: {}, offset: 4, opacity: 1, padding: { top: 4, right: 4, bottom: 4, left: 4 }, rotation: 0, textAlign: "start", textStrokeColor: void 0, textStrokeWidth: 0, textShadowBlur: 0, textShadowColor: void 0 }, yt = "$datalabels", V_ = "$default"; function Xj(t, e) { var n = t.datalabels, i = {}, r = [], s, o; return n === !1 ? null : (n === !0 && (n = {}), e = yn({}, [e, n]), s = e.labels || {}, o = Object.keys(s), delete e.labels, o.length ? o.forEach(function (a) { s[a] && r.push(yn({}, [e, s[a], { _key: a }])) }) : r.push(e), i = r.reduce(function (a, l) { return ce(l.listeners || {}, function (c, u) { a[u] = a[u] || {}, a[u][l._key || V_] = c }), delete l.listeners, a }, {}), { labels: r, listeners: i }) } function Zf(t, e, n, i) { if (e) { var r = n.$context, s = n.$groups, o; e[s._set] && (o = e[s._set][s._key], o && de(o, [r, i]) === !0 && (t[yt]._dirty = !0, n.update(r))) } } function Gj(t, e, n, i, r) { var s, o; !n && !i || (n ? i ? n !== i && (o = s = !0) : o = !0 : s = !0, o && Zf(t, e.leave, n, r), s && Zf(t, e.enter, i, r)) } function Qj(t, e) { var n = t[yt], i = n._listeners, r, s; if (!(!i.enter && !i.leave)) { if (e.type === "mousemove") s = uo.lookup(n._labels, e); else if (e.type !== "mouseout") return; r = n._hovered, n._hovered = s, Gj(t, i, r, s, e) } } function qj(t, e) { var n = t[yt], i = n._listeners.click, r = i && uo.lookup(n._labels, e); r && Zf(t, i, r, e) } var Zj = { id: "datalabels", defaults: Kj, beforeInit: function (t) { t[yt] = { _actives: [] } }, beforeUpdate: function (t) { var e = t[yt]; e._listened = !1, e._listeners = {}, e._datasets = [], e._labels = [] }, afterDatasetUpdate: function (t, e, n) { var i = e.index, r = t[yt], s = r._datasets[i] = [], o = t.isDatasetVisible(i), a = t.data.datasets[i], l = Xj(a, n), c = e.meta.data || [], u = t.ctx, d, f, h, m, p, x, y, g; for (u.save(), d = 0, h = c.length; d < h; ++d)if (y = c[d], y[yt] = [], o && y && t.getDataVisibility(d) && !y.skip) for (f = 0, m = l.labels.length; f < m; ++f)p = l.labels[f], x = p._key, g = new N_(p, u, y, d), g.$groups = { _set: i, _key: x || V_ }, g.$context = { active: !1, chart: t, dataIndex: d, dataset: a, datasetIndex: i }, g.update(g.$context), y[yt].push(g), s.push(g); u.restore(), yn(r._listeners, l.listeners, { merger: function (v, b, _) { b[v] = b[v] || {}, b[v][e.index] = _[v], r._listened = !0 } }) }, afterUpdate: function (t) { t[yt]._labels = uo.prepare(t[yt]._datasets) }, afterDatasetsDraw: function (t) { uo.draw(t, t[yt]._labels) }, beforeEvent: function (t, e) { if (t[yt]._listened) { var n = e.event; switch (n.type) { case "mousemove": case "mouseout": Qj(t, n); break; case "click": qj(t, n); break } } }, afterEvent: function (t) { var e = t[yt], n = e._actives, i = e._actives = t.getActiveElements(), r = co.arrayDiff(n, i), s, o, a, l, c, u, d; for (s = 0, o = r.length; s < o; ++s)if (c = r[s], c[1]) for (d = c[0].element[yt] || [], a = 0, l = d.length; a < l; ++a)u = d[a], u.$context.active = c[1] === 1, u.update(u.$context); (e._dirty || r.length) && (uo.update(e._labels), t.render()), delete e._dirty } }, $p = {}, Jf = globalThis && globalThis.__assign || function () { return (Jf = Object.assign || function (t) { for (var e, n = 1, i = arguments.length; n < i; n++)for (var r in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t }).apply(this, arguments) }, Jj = function () { function t(e, n, i) { var r = this; this.endVal = n, this.options = i, this.version = "2.6.0", this.defaults = { startVal: 0, decimalPlaces: 0, duration: 2, useEasing: !0, useGrouping: !0, useIndianSeparators: !1, smartEasingThreshold: 999, smartEasingAmount: 333, separator: ",", decimal: ".", prefix: "", suffix: "", enableScrollSpy: !1, scrollSpyDelay: 200, scrollSpyOnce: !1 }, this.finalEndVal = null, this.useEasing = !0, this.countDown = !1, this.error = "", this.startVal = 0, this.paused = !0, this.once = !1, this.count = function (s) { r.startTime || (r.startTime = s); var o = s - r.startTime; r.remaining = r.duration - o, r.useEasing ? r.countDown ? r.frameVal = r.startVal - r.easingFn(o, 0, r.startVal - r.endVal, r.duration) : r.frameVal = r.easingFn(o, r.startVal, r.endVal - r.startVal, r.duration) : r.frameVal = r.startVal + (r.endVal - r.startVal) * (o / r.duration); var a = r.countDown ? r.frameVal < r.endVal : r.frameVal > r.endVal; r.frameVal = a ? r.endVal : r.frameVal, r.frameVal = Number(r.frameVal.toFixed(r.options.decimalPlaces)), r.printValue(r.frameVal), o < r.duration ? r.rAF = requestAnimationFrame(r.count) : r.finalEndVal !== null ? r.update(r.finalEndVal) : r.options.onCompleteCallback && r.options.onCompleteCallback() }, this.formatNumber = function (s) { var o, a, l, c, u = s < 0 ? "-" : ""; o = Math.abs(s).toFixed(r.options.decimalPlaces); var d = (o += "").split("."); if (a = d[0], l = d.length > 1 ? r.options.decimal + d[1] : "", r.options.useGrouping) { c = ""; for (var f = 3, h = 0, m = 0, p = a.length; m < p; ++m)r.options.useIndianSeparators && m === 4 && (f = 2, h = 1), m !== 0 && h % f == 0 && (c = r.options.separator + c), h++, c = a[p - m - 1] + c; a = c } return r.options.numerals && r.options.numerals.length && (a = a.replace(/[0-9]/g, function (x) { return r.options.numerals[+x] }), l = l.replace(/[0-9]/g, function (x) { return r.options.numerals[+x] })), u + r.options.prefix + a + l + r.options.suffix }, this.easeOutExpo = function (s, o, a, l) { return a * (1 - Math.pow(2, -10 * s / l)) * 1024 / 1023 + o }, this.options = Jf(Jf({}, this.defaults), i), this.formattingFn = this.options.formattingFn ? this.options.formattingFn : this.formatNumber, this.easingFn = this.options.easingFn ? this.options.easingFn : this.easeOutExpo, this.startVal = this.validateValue(this.options.startVal), this.frameVal = this.startVal, this.endVal = this.validateValue(n), this.options.decimalPlaces = Math.max(this.options.decimalPlaces), this.resetDuration(), this.options.separator = String(this.options.separator), this.useEasing = this.options.useEasing, this.options.separator === "" && (this.options.useGrouping = !1), this.el = typeof e == "string" ? document.getElementById(e) : e, this.el ? this.printValue(this.startVal) : this.error = "[CountUp] target is null or undefined", typeof window < "u" && this.options.enableScrollSpy && (this.error ? console.error(this.error, e) : (window.onScrollFns = window.onScrollFns || [], window.onScrollFns.push(function () { return r.handleScroll(r) }), window.onscroll = function () { window.onScrollFns.forEach(function (s) { return s() }) }, this.handleScroll(this))) } return t.prototype.handleScroll = function (e) { if (e && window && !e.once) { var n = window.innerHeight + window.scrollY, i = e.el.getBoundingClientRect(), r = i.top + window.pageYOffset, s = i.top + i.height + window.pageYOffset; s < n && s > window.scrollY && e.paused ? (e.paused = !1, setTimeout(function () { return e.start() }, e.options.scrollSpyDelay), e.options.scrollSpyOnce && (e.once = !0)) : (window.scrollY > s || r > n) && !e.paused && e.reset() } }, t.prototype.determineDirectionAndSmartEasing = function () { var e = this.finalEndVal ? this.finalEndVal : this.endVal; this.countDown = this.startVal > e; var n = e - this.startVal; if (Math.abs(n) > this.options.smartEasingThreshold && this.options.useEasing) { this.finalEndVal = e; var i = this.countDown ? 1 : -1; this.endVal = e + i * this.options.smartEasingAmount, this.duration = this.duration / 2 } else this.endVal = e, this.finalEndVal = null; this.finalEndVal !== null ? this.useEasing = !1 : this.useEasing = this.options.useEasing }, t.prototype.start = function (e) { this.error || (e && (this.options.onCompleteCallback = e), this.duration > 0 ? (this.determineDirectionAndSmartEasing(), this.paused = !1, this.rAF = requestAnimationFrame(this.count)) : this.printValue(this.endVal)) }, t.prototype.pauseResume = function () { this.paused ? (this.startTime = null, this.duration = this.remaining, this.startVal = this.frameVal, this.determineDirectionAndSmartEasing(), this.rAF = requestAnimationFrame(this.count)) : cancelAnimationFrame(this.rAF), this.paused = !this.paused }, t.prototype.reset = function () { cancelAnimationFrame(this.rAF), this.paused = !0, this.resetDuration(), this.startVal = this.validateValue(this.options.startVal), this.frameVal = this.startVal, this.printValue(this.startVal) }, t.prototype.update = function (e) { cancelAnimationFrame(this.rAF), this.startTime = null, this.endVal = this.validateValue(e), this.endVal !== this.frameVal && (this.startVal = this.frameVal, this.finalEndVal == null && this.resetDuration(), this.finalEndVal = null, this.determineDirectionAndSmartEasing(), this.rAF = requestAnimationFrame(this.count)) }, t.prototype.printValue = function (e) { var n; if (this.el) { var i = this.formattingFn(e); (n = this.options.plugin) !== null && n !== void 0 && n.render ? this.options.plugin.render(this.el, i) : this.el.tagName === "INPUT" ? this.el.value = i : this.el.tagName === "text" || this.el.tagName === "tspan" ? this.el.textContent = i : this.el.innerHTML = i } }, t.prototype.ensureNumber = function (e) { return typeof e == "number" && !isNaN(e) }, t.prototype.validateValue = function (e) { var n = Number(e); return this.ensureNumber(n) ? n : (this.error = "[CountUp] invalid start or end value: ".concat(e), null) }, t.prototype.resetDuration = function () { this.startTime = null, this.duration = 1e3 * Number(this.options.duration), this.remaining = this.duration }, t }(); const eA = Object.freeze(Object.defineProperty({ __proto__: null, CountUp: Jj }, Symbol.toStringTag, { value: "Module" })), tA = t2(eA); Object.defineProperty($p, "__esModule", { value: !0 }); var Ye = M, nA = tA; function iA(t, e) { var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]; if (n != null) { var i, r, s, o, a = [], l = !0, c = !1; try { if (s = (n = n.call(t)).next, e === 0) { if (Object(n) !== n) return; l = !1 } else for (; !(l = (i = s.call(n)).done) && (a.push(i.value), a.length !== e); l = !0); } catch (u) { c = !0, r = u } finally { try { if (!l && n.return != null && (o = n.return(), Object(o) !== o)) return } finally { if (c) throw r } } return a } } function vv(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter(function (r) { return Object.getOwnPropertyDescriptor(t, r).enumerable })), n.push.apply(n, i) } return n } function gc(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? vv(Object(n), !0).forEach(function (i) { rA(t, i, n[i]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : vv(Object(n)).forEach(function (i) { Object.defineProperty(t, i, Object.getOwnPropertyDescriptor(n, i)) }) } return t } function rA(t, e, n) { return e = dA(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function eh() { return eh = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]) } return t }, eh.apply(this, arguments) } function sA(t, e) { if (t == null) return {}; var n = {}, i = Object.keys(t), r, s; for (s = 0; s < i.length; s++)r = i[s], !(e.indexOf(r) >= 0) && (n[r] = t[r]); return n } function z_(t, e) { if (t == null) return {}; var n = sA(t, e), i, r; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(t); for (r = 0; r < s.length; r++)i = s[r], !(e.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(t, i) && (n[i] = t[i]) } return n } function oA(t, e) { return aA(t) || iA(t, e) || lA(t, e) || cA() } function aA(t) { if (Array.isArray(t)) return t } function lA(t, e) { if (t) { if (typeof t == "string") return xv(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return xv(t, e) } } function xv(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, i = new Array(e); n < e; n++)i[n] = t[n]; return i } function cA() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function uA(t, e) { if (typeof t != "object" || t === null) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var i = n.call(t, e || "default"); if (typeof i != "object") return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } function dA(t) { var e = uA(t, "string"); return typeof e == "symbol" ? e : String(e) } var fA = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? Ye.useLayoutEffect : Ye.useEffect; function Kt(t) { var e = Ye.useRef(t); return fA(function () { e.current = t }), Ye.useCallback(function () { for (var n = arguments.length, i = new Array(n), r = 0; r < n; r++)i[r] = arguments[r]; return e.current.apply(void 0, i) }, []) } var hA = function (e, n) { var i = n.decimal, r = n.decimals, s = n.duration, o = n.easingFn, a = n.end, l = n.formattingFn, c = n.numerals, u = n.prefix, d = n.separator, f = n.start, h = n.suffix, m = n.useEasing, p = n.useGrouping, x = n.useIndianSeparators, y = n.enableScrollSpy, g = n.scrollSpyDelay, v = n.scrollSpyOnce; return new nA.CountUp(e, a, { startVal: f, duration: s, decimal: i, decimalPlaces: r, easingFn: o, formattingFn: l, numerals: c, separator: d, prefix: u, suffix: h, useEasing: m, useIndianSeparators: x, useGrouping: p, enableScrollSpy: y, scrollSpyDelay: g, scrollSpyOnce: v }) }, pA = ["ref", "startOnMount", "enableReinitialize", "delay", "onEnd", "onStart", "onPauseResume", "onReset", "onUpdate"], mA = { decimal: ".", separator: ",", delay: null, prefix: "", suffix: "", duration: 2, start: 0, decimals: 0, startOnMount: !0, enableReinitialize: !0, useEasing: !0, useGrouping: !0, useIndianSeparators: !1 }, B_ = function (e) { var n = Object.fromEntries(Object.entries(e).filter(function (T) { var D = oA(T, 2), A = D[1]; return A !== void 0 })), i = Ye.useMemo(function () { return gc(gc({}, mA), n) }, [e]), r = i.ref, s = i.startOnMount, o = i.enableReinitialize, a = i.delay, l = i.onEnd, c = i.onStart, u = i.onPauseResume, d = i.onReset, f = i.onUpdate, h = z_(i, pA), m = Ye.useRef(), p = Ye.useRef(), x = Ye.useRef(!1), y = Kt(function () { return hA(typeof r == "string" ? r : r.current, h) }), g = Kt(function (T) { var D = m.current; if (D && !T) return D; var A = y(); return m.current = A, A }), v = Kt(function () { var T = function () { return g(!0).start(function () { l == null || l({ pauseResume: b, reset: _, start: S, update: k }) }) }; a && a > 0 ? p.current = setTimeout(T, a * 1e3) : T(), c == null || c({ pauseResume: b, reset: _, update: k }) }), b = Kt(function () { g().pauseResume(), u == null || u({ reset: _, start: S, update: k }) }), _ = Kt(function () { g().el && (p.current && clearTimeout(p.current), g().reset(), d == null || d({ pauseResume: b, start: S, update: k })) }), k = Kt(function (T) { g().update(T), f == null || f({ pauseResume: b, reset: _, start: S }) }), S = Kt(function () { _(), v() }), P = Kt(function (T) { s && (T && _(), v()) }); return Ye.useEffect(function () { x.current ? o && P(!0) : (x.current = !0, P()) }, [o, x, P, a, e.start, e.suffix, e.prefix, e.duration, e.separator, e.decimals, e.decimal, e.formattingFn]), Ye.useEffect(function () { return function () { _() } }, [_]), { start: S, pauseResume: b, reset: _, update: k, getCountUp: g } }, gA = ["className", "redraw", "containerProps", "children", "style"], yA = function (e) { var n = e.className, i = e.redraw, r = e.containerProps, s = e.children, o = e.style, a = z_(e, gA), l = Ye.useRef(null), c = Ye.useRef(!1), u = B_(gc(gc({}, a), {}, { ref: l, startOnMount: typeof s != "function" || e.delay === 0, enableReinitialize: !1 })), d = u.start, f = u.reset, h = u.update, m = u.pauseResume, p = u.getCountUp, x = Kt(function () { d() }), y = Kt(function (b) { e.preserveValue || f(), h(b) }), g = Kt(function () { if (typeof e.children == "function" && !(l.current instanceof Element)) { console.error(`Couldn't find attached element to hook the CountUp instance into! Try to attach "containerRef" from the render prop to a an Element, eg. <span ref={containerRef} />.`); return } p() }); Ye.useEffect(function () { g() }, [g]), Ye.useEffect(function () { c.current && y(e.end) }, [e.end, y]); var v = i && e; return Ye.useEffect(function () { i && c.current && x() }, [x, i, v]), Ye.useEffect(function () { !i && c.current && x() }, [x, i, e.start, e.suffix, e.prefix, e.duration, e.separator, e.decimals, e.decimal, e.className, e.formattingFn]), Ye.useEffect(function () { c.current = !0 }, []), typeof s == "function" ? s({ countUpRef: l, start: d, reset: f, update: h, pauseResume: m, getCountUp: p }) : Ye.createElement("span", eh({ className: n, ref: l, style: o }, r), typeof e.start < "u" ? p().formattingFn(e.start) : "") }, wv = $p.default = yA; $p.useCountUp = B_; function vA(t) { return xn({ tag: "svg", attr: { viewBox: "0 0 1024 1024" }, child: [{ tag: "path", attr: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { tag: "path", attr: { d: "M686.7 638.6L544.1 535.5V288c0-4.4-3.6-8-8-8H488c-4.4 0-8 3.6-8 8v275.4c0 2.6 1.2 5 3.3 6.5l165.4 120.6c3.6 2.6 8.6 1.8 11.2-1.7l28.6-39c2.6-3.7 1.8-8.7-1.8-11.2z" } }] })(t) } function xA(t) { return xn({ tag: "svg", attr: { role: "img", viewBox: "0 0 24 24" }, child: [{ tag: "title", attr: {}, child: [] }, { tag: "path", attr: { d: "M16.624 13.9202l2.7175 2.7154-7.353 7.353-7.353-7.352 2.7175-2.7164 4.6355 4.6595 4.6356-4.6595zm4.6366-4.6366L24 12l-2.7154 2.7164L18.5682 12l2.6924-2.7164zm-9.272.001l2.7163 2.6914-2.7164 2.7174v-.001L9.2721 12l2.7164-2.7154zm-9.2722-.001L5.4088 12l-2.6914 2.6924L0 12l2.7164-2.7164zM11.9885.0115l7.353 7.329-2.7174 2.7154-4.6356-4.6356-4.6355 4.6595-2.7174-2.7154 7.353-7.353z" } }] })(t) } aa.register(Zj); const wA = { labels: ["Liquidity", "Marketing", "Operations"], datasets: [{ label: "Fee", data: ["1", 2, 2], backgroundColor: ["#1d4ed8", "#0e2c68", "#65baff"], hoverOffset: 4 }] }, bA = { labels: ["Critical", "Medium", "Minor", "Informationl"], datasets: [{ label: "Score", data: [0, 0, 0, 1], backgroundColor: ["#f87272", "#fbbd23", "#fef08a", "#435ebe"], hoverOffset: 4 }] }, _A = { responsive: !0, maintainAspectRatio: !0, plugins: { legend: { display: !1 }, datalabels: { color: "#fff", font: { size: 25 }, formatter: (t, e) => t + "%" } } }, SA = () => { const t = M.useRef(null); return w.jsx("section", { ref: t, id: "audit", className: "gradiant relative flex justify-center flex-wrap", children: w.jsxs("div", { className: "screen-optz w-full z-20 flex p-8 justify-center lg:py-4 lg:pb-8 flex-wrap ", children: [w.jsx(U.p, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0, x: -50 }, whileInView: { x: 0, opacity: [.5, .7, 1] }, className: "w-full -mb-2 text-base font-semibold leading-7 text-secondary", children: "Safety & Security" }), w.jsx(U.h1, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0, x: -50 }, whileInView: { x: 0, opacity: [.5, .7, 1] }, className: "w-full text-4xl lg:text-6xl font-extrabold tracking-wide text-accent sm:text-4xl mb-16 ", children: "Audit Details" }), w.jsx("a", { className: "text-2xl font-bold text-accent", target: "_blank", href: "https://github.com/solidproof/projects/blob/main/2023/TTF%20Bot/SmartContract_Audit_Solidproof_TTF.pdf", children: "Audit and KYC by SolidProof" }), w.jsx("h4", { className: "text-xl mt-12 my-4", children: "Security Score" }), w.jsxs("div", { className: "flex gap-12 justify-center flex-wrap", children: [w.jsxs("div", { className: "w-full lg:w-[25rem] bg-secondary rounded-3xl ", children: [w.jsxs("div", { className: "flex items-center w-fit p-1 px-2 rounded-full mt-4 mx-4 border border-accent", children: [w.jsx(vA, { className: "mr-2" }), w.jsx("div", { children: "October 5, 2023" })] }), w.jsx("div", { className: "flex justify-center items-center mb-16 mt-4 mx-4 ", children: w.jsxs("div", { className: "h-40 w-40 bg-accent rounded-full p-1 relative", children: [w.jsx("img", { className: "h-full w-full border-secondary border-8 rounded-full ", src: "/logo.gif" }), w.jsx("span", { className: "h-8 w-8 p-1.5 -bottom-2  right-0 mx-auto left-0 bg-yellow-400 absolute rounded-full flex justify-center items-center text-accent", children: w.jsx(xA, { className: "h-full w-full" }) })] }) }), w.jsxs("div", { className: "h-[20rem] bg-neutral rounded-[2rem] flex flex-col items-center justify-around ", children: [w.jsxs("div", { className: "text-3xl text-gray-400 ", children: [w.jsx("h2", { children: "Score:" }), w.jsx("h2", { children: "98" })] }), w.jsx("h3", { className: "text-black font-bold text-3xl", children: "TTF" }), w.jsx("a", { className: "btn btn-secondary w-36", target: "_blank", href: "https://github.com/solidproof/projects/blob/main/2023/TTF%20Bot/SmartContract_Audit_Solidproof_TTF.pdf", children: "View" })] })] }), w.jsxs("div", { className: "w-full lg:w-[25rem] flex flex-col justify-between", children: [w.jsxs("div", { className: "flex justify-between text-2xl font-medium text-black", children: [w.jsx("div", { children: "Total" }), w.jsx("div", { children: "0" })] }), w.jsxs("div", { className: "flex justify-between text-2xl font-medium text-error", children: [w.jsx("div", { children: "Critical" }), w.jsx("div", { children: "0" })] }), w.jsxs("div", { className: "flex justify-between text-2xl font-medium text-warning", children: [w.jsx("div", { children: "Medium" }), w.jsx("div", { children: "0" })] }), w.jsxs("div", { className: "flex justify-between text-2xl font-medium text-yellow-200", children: [w.jsx("div", { children: "Minor" }), w.jsx("div", { children: "0" })] }), w.jsxs("div", { className: "flex justify-between text-2xl font-medium text-secondary", children: [w.jsx("div", { children: "Informational" }), w.jsx("div", { children: "1" })] }), w.jsx("div", { className: "", children: w.jsx(O_, { id: "1", data: bA }) })] })] })] }) }) }, kA = () => w.jsx("section", { id: "supply", className: "w-full relative flex justify-center py-10 px-8", children: w.jsxs("div", { className: "stats block lg:inline-grid shadow-2xl bg-primary text-primary-content rounded-lg ", children: [w.jsxs("div", { className: "stat", children: [w.jsx("div", { className: "stat-title text-accent", children: "Max Wallet" }), w.jsxs("div", { className: "stat-value text-secondary", children: [w.jsx(wv, { scrollSpyOnce: !0, enableScrollSpy: !0, start: .1, decimals: 2, end: 2, duration: 4 }), "%"] })] }), w.jsxs("div", { className: "stat", children: [w.jsx("div", { className: "stat-title text-accent", children: "Total Supply" }), w.jsx("div", { className: "stat-value text-secondary", children: w.jsx(wv, { scrollSpyOnce: !0, enableScrollSpy: !0, start: 1, end: 1e8, duration: 4 }) })] })] }) }), PA = () => { const t = M.useRef(null), e = eo(t); return w.jsx("section", { ref: t, id: "tokenomics", className: "gradiant relative flex justify-center flex-wrap", children: w.jsxs("div", { className: "screen-optz w-full z-20 flex p-8 justify-center lg:py-4 lg:pb-8 flex-wrap ", children: [w.jsx(U.p, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0, x: -50 }, whileInView: { x: 0, opacity: [.5, .7, 1] }, className: "w-full -mb-2 text-base font-semibold leading-7 text-secondary", children: "Our Economic Value" }), w.jsx(U.h1, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0, x: -50 }, whileInView: { x: 0, opacity: [.5, .7, 1] }, className: "w-full text-4xl lg:text-6xl font-extrabold tracking-wide text-accent sm:text-4xl mb-16 ", children: "Tokenomics" }), w.jsx("span", { className: "p-2 text-3xl text-accent font-bold m-8 tracking-wide w-full text-center", children: "Buy/Sell Fee" }), w.jsx("div", { className: "w-full lg:w-1/2 p-4 h-96 lg:h-[30rem] flex justify-center items-center", children: e && w.jsx(O_, { id: "0", options: _A, data: wA }) }), w.jsxs("div", { className: "w-full lg:w-1/2 flex justify-center items-center flex-wrap content-center", children: [w.jsxs("div", { className: "flex w-full items-center justify-center my-8 ", children: [w.jsx("div", { className: "w-5/12 flex justify-end pr-6", children: w.jsx(U.div, { transition: { ease: "linear", duration: .7 }, initial: { height: 0 }, whileInView: { height: ["0.5rem", "1rem", "1.5rem", "2rem"] }, className: "h-8 w-8 rounded-sm bg-[#1d4ed8]" }) }), w.jsx("h4", { className: "w-7/12 h-full font-semibold text-accent text-2xl", children: "Liquidity 1%" })] }), w.jsxs("div", { className: "flex w-full items-center justify-center my-8 ", children: [w.jsx("div", { className: "w-5/12 flex justify-end pr-6", children: w.jsx(U.div, { transition: { ease: "linear", duration: .7 }, initial: { height: 0 }, whileInView: { height: ["0.5rem", "1rem", "1.5rem", "2rem"] }, className: "h-8 w-8 rounded-sm bg-[#65baff]" }) }), w.jsx("h4", { className: "w-7/12 font-semibold text-accent text-2xl", children: "Operations 2%" })] }), w.jsxs("div", { className: "flex w-full items-center justify-center my-8 ", children: [w.jsx("div", { className: "w-5/12 flex justify-end pr-6", children: w.jsx(U.div, { transition: { ease: "linear", duration: .7 }, initial: { height: 0 }, whileInView: { height: ["0.5rem", "1rem", "1.5rem", "2rem"] }, className: "h-8 w-8 rounded-sm bg-[#0e2c68]" }) }), w.jsx("h4", { className: "w-7/12 font-semibold text-accent text-2xl", children: "Marketing 2%" })] }), w.jsx("h4", { className: "w-7/12 font-semibold text-accent text-2xl tracking-wider mt-8  ", children: "Total Fee 5%" })] }), w.jsx(kA, {})] }) }) }, CA = () => w.jsxs("section", { children: [w.jsx(PA, {}), w.jsx(SA, {})] }), MA = () => w.jsx("section", { id: "supps", className: "bg-accent  relative flex justify-center", children: w.jsxs("div", { className: "screen-optz w-full z-20 flex py-4 justify-center lg:justify-between flex-wrap ", children: [w.jsx("div", { className: "w-full text-secondary text-center text-xl lg:text-3xl font-bold tracking-wider mb-8", children: "Buy TTF Token or view chart on your preferred platform" }), w.jsx("div", { className: "w-1/2 lg:w-1/6 flex justify-center items-center ", children: w.jsx("a", { href: "https://app.uniswap.org/tokens/ethereum/0x8e32b8a41f2e86a3ee198912ac8d756c84295b40", children: w.jsx("img", { src: "/uniswap.png", className: "h-24" }) }) }), w.jsx("div", { className: "w-1/2 lg:w-1/6 flex justify-center items-center ", children: w.jsx("a", { href: "https://dexscreener.com/ethereum/0x8e32b8a41f2e86a3ee198912ac8d756c84295b40", children: w.jsx("img", { src: "/dexscreener1.png", className: "h-28" }) }) }), w.jsx("div", { className: "w-7/12 lg:w-1/6 p-4 lg:p-0 flex justify-center items-center ", children: w.jsx("img", { src: "/home-text.gif" }) }), w.jsx("div", { className: "w-1/2 lg:w-1/6  flex justify-center items-center ", children: w.jsx("a", { href: "https://www.dexview.com/eth/0x8e32b8a41f2e86a3ee198912ac8d756c84295b40", children: w.jsx("img", { src: "/dexview.png", className: "h-24" }) }) }), w.jsx("div", { className: "w-1/2 lg:w-1/6  flex justify-center items-center ", children: w.jsx("a", { href: "https://www.dextools.io/app/en/ether/pair-explorer/0x8e32b8a41f2e86a3ee198912ac8d756c84295b40", children: w.jsx("img", { src: "/dextools.png", className: "h-24" }) }) })] }) }); function H_(t) { return xn({ tag: "svg", attr: { viewBox: "0 0 15 15", fill: "none" }, child: [{ tag: "path", attr: { fillRule: "evenodd", clipRule: "evenodd", d: "M7.49991 0.877045C3.84222 0.877045 0.877075 3.84219 0.877075 7.49988C0.877075 11.1575 3.84222 14.1227 7.49991 14.1227C11.1576 14.1227 14.1227 11.1575 14.1227 7.49988C14.1227 3.84219 11.1576 0.877045 7.49991 0.877045ZM1.82708 7.49988C1.82708 4.36686 4.36689 1.82704 7.49991 1.82704C10.6329 1.82704 13.1727 4.36686 13.1727 7.49988C13.1727 10.6329 10.6329 13.1727 7.49991 13.1727C4.36689 13.1727 1.82708 10.6329 1.82708 7.49988ZM10.1589 5.53774C10.3178 5.31191 10.2636 5.00001 10.0378 4.84109C9.81194 4.68217 9.50004 4.73642 9.34112 4.96225L6.51977 8.97154L5.35681 7.78706C5.16334 7.59002 4.84677 7.58711 4.64973 7.78058C4.45268 7.97404 4.44978 8.29061 4.64325 8.48765L6.22658 10.1003C6.33054 10.2062 6.47617 10.2604 6.62407 10.2483C6.77197 10.2363 6.90686 10.1591 6.99226 10.0377L10.1589 5.53774Z", fill: "currentColor" } }] })(t) } const nl = [{ id: 1, function: "Analysis Reports", a: !0, b: !1, c: !1, d: !1 }, { id: 2, function: "On-demand Charts", a: !0, b: !1, c: !1, d: !1 }, { id: 3, function: "Fees Summary Report", a: !0, b: !1, c: !1, d: !1 }, { id: 4, function: "Monitor Tax Changes", a: !0, b: !1, c: !1, d: !1 }, { id: 5, function: "Monitor Max Trx's", a: !0, b: !1, c: !1, d: !1 }, { id: 6, function: "Monitor Team Funds", a: !0, b: !1, c: !1, d: !1 }, { id: 50, function: "Everything in Free", a: !1, b: !0, c: !1, d: !1 }, { id: 7, function: "Monitor Liquidity", a: !1, b: !0, c: !1, d: !1 }, { id: 8, function: "Monitor Contracts", a: !1, b: !0, c: !1, d: !1 }, { id: 9, function: "Monitor Airdrops", a: !1, b: !0, c: !1, d: !1 }, { id: 10, function: "Buybacks, Burns, Sells", a: !1, b: !0, c: !1, d: !1 }, { id: 10, function: "No Sponsored Ads", a: !1, b: !0, c: !1, d: !1 }, { id: 100, function: "Everything in Pro", a: !1, b: !1, c: !0, d: !0 }, { id: 11, function: "Labeled Callers", a: !1, b: !1, c: !0, d: !1 }, { id: 12, function: "Labeled Influencers", a: !1, b: !1, c: !0, d: !1 }, { id: 13, function: "Labeled Exchanges", a: !1, b: !1, c: !0, d: !1 }, { id: 14, function: "TTF VIP Lounge", a: !1, b: !1, c: !0, d: !1 }, { id: 15, function: "Facilitate OTC Trades", a: !1, b: !1, c: !0, d: !1 }, { id: 16, function: "No Sponsored Ads", a: !1, b: !1, c: !1, d: !0 }, { id: 17, function: "Set a Default Token", a: !1, b: !1, c: !1, d: !0 }, { id: 18, function: "Pinned in TTF Channel", a: !1, b: !1, c: !1, d: !0 }, { id: 19, function: "Follow-up Pinned Post", a: !1, b: !1, c: !1, d: !0 }, { id: 20, function: "Buyback into Project", a: !1, b: !1, c: !1, d: !0 }], il = () => w.jsx("div", { className: "flex", children: w.jsx(H_, { className: "text-primary h-6 w-6 bg-success rounded-full" }) }), TA = () => w.jsx("section", { id: "versions", className: " gradiant relative flex justify-center", children: w.jsxs("div", { className: "screen-optz lg:py-16 px-8 lg:px-4  w-full z-20 flex py-4 justify-center flex-wrap ", children: [w.jsx(U.p, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0, x: -50 }, whileInView: { x: 0, opacity: [.5, .7, 1] }, className: "w-full -mb-2 text-base font-semibold leading-7 text-secondary", children: "What We Offer " }), w.jsx(U.h1, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0, x: -50 }, whileInView: { x: 0, opacity: [.5, .7, 1] }, className: "w-full text-4xl lg:text-6xl font-extrabold tracking-wide text-accent sm:text-4xl mb-8 ", children: "Bot Versions" }), w.jsxs("div", { className: "container flex gap-4  my-2 lg:flex-nowrap flex-wrap", children: [w.jsxs(U.div, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0 }, whileInView: { opacity: [.5, .7, 1] }, className: " w-full lg:w-1/3 bg-primary rounded-lg p-8 relative", children: [w.jsxs("h2", { className: "font-bold text-3xl text-accent my-2", children: ["FREE", w.jsx("span", { className: "text-sm ml-4 text-gray-500", children: "for Everyone" })] }), w.jsx("div", { className: "mt-8 h-64 flex flex-col justify-around ", children: nl.map(t => t.a && w.jsxs("div", { className: "flex items-center", children: [w.jsx(il, {}), w.jsx("span", { className: "ml-4", children: t.function })] })) }), w.jsx("a", { href: "https://t.me/ttfbotbot", target: "_blank", className: "btn w-full bg-transparent text-accent border-accent mt-4", children: "Get Access Now" })] }), w.jsxs(U.div, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0 }, whileInView: { opacity: [.5, .7, 1] }, className: " w-full lg:w-1/3 bg-primary rounded-lg p-8 relative", children: [w.jsxs("h2", { className: "font-bold text-3xl text-accent my-2", children: ["PRO", w.jsx("span", { className: "text-sm ml-4 text-gray-500", children: "for Holders" })] }), w.jsx("div", { className: "mt-8 h-64 flex flex-col justify-around ", children: nl.map(t => t.b && w.jsxs("div", { className: "flex items-center", children: [w.jsx(il, {}), w.jsx("span", { className: "ml-4", children: t.function })] })) }), w.jsx("a", { href: "https://app.uniswap.org/tokens/ethereum/0x8e32b8a41f2e86a3ee198912ac8d756c84295b40", target: "_blank", className: "btn w-full bg-transparent text-accent border-accent mt-4", children: "Hold 100K of TTF" })] }), w.jsxs(U.div, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0 }, whileInView: { opacity: [.5, .7, 1] }, className: " w-full lg:w-1/3 bg-primary rounded-lg p-8 relative", children: [w.jsxs("h2", { className: "font-bold text-3xl text-accent my-2", children: ["PREMIUM", w.jsx("span", { className: "text-sm ml-4 text-gray-500", children: "for VIP" })] }), w.jsx("div", { className: "mt-8 h-64 flex flex-col justify-around ", children: nl.map(t => t.c && w.jsxs("div", { className: "flex items-center", children: [w.jsx(il, {}), w.jsx("span", { className: "ml-4", children: t.function })] })) }), w.jsx("a", { href: "https://app.uniswap.org/tokens/ethereum/0x8e32b8a41f2e86a3ee198912ac8d756c84295b40", target: "_blank", className: "btn w-full bg-transparent text-accent border-accent mt-4", children: "Hold 500K of TTF" })] }), w.jsxs(U.div, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0 }, whileInView: { opacity: [.5, .7, 1] }, className: " w-full lg:w-1/3 bg-primary rounded-lg p-8 relative", children: [w.jsxs("h2", { className: "font-bold text-3xl text-accent my-2", children: ["CUSTOM", w.jsx("span", { className: "text-sm ml-4 text-gray-500", children: "for Devs" })] }), w.jsx("div", { className: "mt-8 h-64 flex flex-col justify-around ", children: nl.map(t => t.d && w.jsxs("div", { className: "flex items-center", children: [w.jsx(il, {}), w.jsx("span", { className: "ml-4", children: t.function })] })) }), w.jsx("a", { href: "https://t.me/dantek5", target: "_blank", className: "btn w-full bg-transparent text-accent border-accent mt-4", children: "Chat Now" })] })] })] }) }), EA = ({ done: t }) => w.jsx("div", { className: "rounded-full w-2/12 lg:w-3/12 flex justify-end items-center", children: w.jsx(H_, { className: `${t ? "bg-success text-primary" : "text-success"} rounded-full text-primary h-6 w-6` }) }), pd = ({ info: t, done: e }) => w.jsxs("div", { className: "flex w-full my-1 lg:my-0", children: [w.jsx(EA, { done: e }), w.jsx("h4", { className: "w-10/12 lg:w-9/12 text-md lg:text-xl font-medium flex justify-left ml-4 items-center", children: t })] }), DA = [{ id: 1, info: "Project Conception", done: !0 }, { id: 2, info: "Contact Deployment", done: !0 }, { id: 3, info: "Launch Token", done: !0 }, { id: 4, info: "Launch Website", done: !0 }, { id: 5, info: "Create Socials", done: !0 }, { id: 6, info: "Release Whitepaper", done: !0 }, { id: 7, info: "Onboard Mods", done: !0 }, { id: 8, info: "Beta Test TTF Bot", done: !0 }, { id: 9, info: "Release TTF Bot", done: !0 }, { id: 10, info: "Organic Growth", done: !0 }], OA = [{ id: 11, info: "AMA Marketing", done: !0 }, { id: 12, info: "KYC Certificate", done: !0 }, { id: 13, info: "Contract Audit", done: !0 }, { id: 1, info: "List on Token sites", done: !0 }, { id: 3, info: "Etherscan Update", done: !0 }, { id: 2, info: "Launch Custom", done: !1 }, { id: 3, info: "Launch TTF Pro", done: !0 }, { id: 4, info: "Monetize TTF Bot", done: !1 }, { id: 5, info: "Telegram Marketing", done: !0 }, { id: 6, info: "Partnership Marketing", done: !1 }, { id: 8, info: "Banners Marketing", done: !1 }, { id: 10, info: "Influencers Marketing", done: !1 }], RA = [{ id: 1, info: "Launch TTF Premium", done: !1 }, { id: 2, info: "Billboards Marketing", done: !1 }, { id: 4, info: "Launch Arbitrum", done: !1 }, { id: 5, info: "Launch TTF for Discord", done: !1 }, { id: 6, info: "List on CoinGecko", done: !1 }, { id: 7, info: "List On CoinMarketCap", done: !1 }, { id: 8, info: "Launch Portfolio Bot", done: !1 }, { id: 9, info: "Launch Utility NFT's", done: !1 }], LA = () => { const t = M.useRef(null), e = M.useRef(null), n = M.useRef(null), i = eo(t, { once: !0 }), r = eo(e, { once: !0 }), s = eo(n, { once: !0 }), o = oc(); return M.useEffect(() => { i && o.start({ height: ["0%", "15%"] }), r && o.start({ height: ["15%", "48%"] }), s && o.start({ height: ["48%", "80%"] }) }, [i, r, s]), w.jsx("section", { id: "roadmap", className: "gradiant relative flex justify-center", children: w.jsx("div", { className: "screen-optz w-full z-20 flex py-4 pb-20 px-8 lg:px-0 justify-center flex-wrap ", children: w.jsxs("div", { className: "container mx-auto w-full h-full text-center", children: [w.jsxs("div", { className: "text-left my-8 ", children: [w.jsx(U.p, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0, x: -50 }, whileInView: { x: 0, opacity: [.5, .7, 1] }, className: "w-full -mb-2 text-base font-semibold leading-7 text-secondary", children: "Our Detailed  Plan " }), w.jsx(U.h1, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0, x: -50 }, whileInView: { x: 0, opacity: [.5, .7, 1] }, className: "w-full text-4xl lg:text-6xl font-extrabold tracking-wide text-accent sm:text-4xl mb-16 ", children: "TTF Roadmap" })] }), w.jsx("span", { className: "p-2 text-3xl text-accent font-bold text-center", children: "Roadmap" }), w.jsxs("div", { className: "relative flex flex-wrap py-8 lg:p-8 h-full", children: [w.jsx(U.div, { transition: { ease: "linear", duration: 1 }, initial: { height: 0 }, animate: o, className: "border-2-2 absolute border-opacity-20 text-primary h-[calc(100%-6.5rem)]  border left-1/2" }), w.jsx("div", { className: "lg:w-5/12 " }), w.jsxs("div", { className: "lg:w-2/12 hidden relative lg:flex justify-center items-center", children: [w.jsx("div", { className: "z-20 flex justify-center items-center gradiant order-1  border-accent border-2 shadow-xl w-8 h-8 rounded-full", children: w.jsx("h1", { className: "mx-auto font-semibold text-lg text-accent ", children: "1" }) }), w.jsx(U.div, { transition: { ease: "linear", duration: .5, delay: 1 }, initial: { width: 0 }, whileInView: { width: ["0%", "50%"] }, className: "border-2-2 absolute border-opacity-20 text-accent w-full border left-1/2" })] }), w.jsxs(U.div, { transition: { ease: "linear", duration: .5, delay: 1.5 }, initial: { opacity: 0 }, whileInView: { opacity: [0, 1] }, viewport: { once: !0 }, ref: t, className: "mb-8 justify-between items-center w-full lg:w-5/12 relative ", children: [w.jsx("div", { className: "z-20 flex lg:hidden items-center order-1 bg-primary shadow-xl w-8 h-8 rounded-full border-2 border-accent absolute -top-4 -left-4", children: w.jsx("h1", { className: "mx-auto font-semibold text-lg text-accent ", children: "1" }) }), w.jsx("div", { className: "order-1 lg:h-[25rem] lg:items-center flex flex-wrap gradiant border-2 border-accent text-accent rounded-lg shadow-xl w-full px-6 py-4 text-center", children: DA.map(a => w.jsx(pd, { ...a }, a.id)) })] }), w.jsxs(U.div, { transition: { ease: "linear", duration: .5, delay: 1.5 }, initial: { opacity: 0 }, whileInView: { opacity: [0, 1] }, viewport: { once: !0 }, ref: e, className: "mb-8 justify-between items-center w-full lg:w-5/12 relative", children: [w.jsx("div", { className: "z-20 flex lg:hidden items-center order-1 bg-primary shadow-xl w-8 h-8 rounded-full border-2 border-accent absolute -top-4 -left-4", children: w.jsx("h1", { className: "mx-auto font-semibold text-lg text-accent ", children: "2" }) }), w.jsx("div", { className: "order-2 lg:h-[25rem] lg:items-center flex flex-wrap  gradiant border-2 border-accent text-accent rounded-lg shadow-xl w-full px-6 py-4 text-center", children: OA.map(a => w.jsx(pd, { ...a }, a.id)) })] }), w.jsxs("div", { className: "lg:w-2/12 hidden relative lg:flex  justify-center items-center overflow-hidden", children: [w.jsx("div", { className: "z-20 flex justify-center items-center gradiant order-1  border-accent border-2 shadow-xl w-8 h-8 rounded-full", children: w.jsx("h1", { className: "mx-auto font-semibold text-lg text-accent ", children: "2" }) }), w.jsx(U.div, { transition: { ease: "linear", duration: .5, delay: 1 }, initial: { width: 0 }, whileInView: { width: ["0%", "50%"] }, viewport: { once: !0 }, className: "border-2-2 absolute border-opacity-20 text-accent w-full border right-1/2" })] }), w.jsx("div", { className: "lg:w-5/12 " }), w.jsx("div", { className: "lg:w-5/12 " }), w.jsxs("div", { className: "lg:w-2/12 hidden relative lg:flex  justify-center items-center", children: [w.jsx("div", { className: "z-20 flex justify-center items-center gradiant order-1  border-accent border-2 shadow-xl w-8 h-8 rounded-full", children: w.jsx("h1", { className: "mx-auto font-semibold text-lg text-accent ", children: "3" }) }), w.jsx(U.div, { transition: { ease: "linear", duration: .5, delay: 1 }, initial: { width: 0 }, whileInView: { width: ["0%", "50%"] }, viewport: { once: !0 }, className: "border-2-2 absolute border-opacity-20 text-accent w-full border left-1/2" })] }), w.jsxs(U.div, { transition: { ease: "linear", duration: .5, delay: 1.5 }, initial: { opacity: 0 }, whileInView: { opacity: [0, 1] }, viewport: { once: !0 }, ref: n, className: "mb-16 justify-between items-center w-full lg:w-5/12 relative", children: [w.jsx("div", { className: "z-20 flex lg:hidden items-center order-1 bg-primary shadow-xl w-8 h-8 rounded-full border-2 border-accent absolute -top-4 -left-4", children: w.jsx("h1", { className: "mx-auto font-semibold text-lg text-accent ", children: "3" }) }), w.jsx("div", { className: "order-3 lg:h-[25rem] lg:items-center flex flex-wrap  gradiant border-2 border-accent text-accent rounded-lg shadow-xl w-full px-6 py-4 text-center", children: RA.map(a => w.jsx(pd, { ...a }, a.id)) })] })] })] }) }) }) }, jA = () => w.jsx("section", { id: "about", className: "gradiant relative flex justify-center", children: w.jsx("div", { className: "relative w-full isolate flex justify-center items-center  overflow-hidden  ", children: w.jsx("div", { className: "screen-optz w-full z-20 flex p-8 lg:px-0", children: w.jsxs("div", { className: "w-full flex justify-center items-center flex-wrap content-center", children: [w.jsx(U.p, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0, x: -50 }, whileInView: { x: 0, opacity: [.5, .7, 1] }, className: "w-full -mb-2 text-base font-semibold leading-7 text-secondary", children: "Introduction" }), w.jsx(U.h1, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0, x: -50 }, whileInView: { x: 0, opacity: [.5, .7, 1] }, className: "w-full text-4xl lg:text-6xl font-extrabold tracking-wide text-accent sm:text-4xl mb-8 ", children: "About TTF" }), w.jsx("div", { className: "w-full flex flex-wrap py-8 lg:p-8 pt-0 text-lg  text-netural lg:text-xl ", children: w.jsxs(U.div, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0, x: -50 }, whileInView: { x: 0, opacity: [.5, .7, 1] }, className: "w-full", children: [w.jsx("div", { className: "mb-8", children: "We are going to share with you a truly inspiring story of how our team of individuals came together to fight back against scammers in the cryptocurrency market." }), w.jsx("div", { className: "mb-8", children: "As many of you know, the cryptocurrency market has been plagued by scams and fraudulent activities, which have caused significant financial losses and undermined trust in the market. Unfortunately, our team fell victim to one of these scams, losing a significant amount of money in the process. Each team member of this project has been a victim on multiple occasions, and we're sure all of you can relate. From the ashes of a project where we were victims, we all started chatting. We realized we had similar values and principles." }), w.jsx("div", { className: "mb-8", children: "So instead of giving up and walking away, we decided to take action. We gathered our skills, knowledge, and experience and began working on a solution that would help protect others from the same fate. And that's how the idea for our TTF BOT was born. We researched the types of scams that exist and how we can try to identify them. The Blockchain is available to all, but not all know how to use it effectively. And even if you knew how to use it, you certainly can't monitor it 24/7." })] }) }), w.jsx("div", { className: "bg-primary rounded-lg shadow-lg p-8 text-lg   text-netural lg:text-xl  ", children: w.jsxs(U.div, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0, y: -25 }, whileInView: { y: 0, opacity: [.5, .7, 1] }, className: "w-full", children: [w.jsx("div", { className: "mb-8", children: "Our team worked tirelessly to create an advanced tool that could monitor the cryptocurrency market and detect suspicious activities and potential scams. We poured our hearts and souls into this project, determined to make a difference and prevent others from falling victim to these scams. This project was not born yesterday; we were strategizing and in development for over 2 months prior to launching the TTF Token. We like to think, this is a well thought out project which actually will have a positive impact in the cryptocurrency space." }), w.jsx("div", { className: "mb-8", children: "We faced countless setbacks, challenges, and obstacles along the way. But we persevered, driven by a shared vision of a better future and a determination to succeed. These bumps are expected when we are doing something novel, never been done in crypto before!" }), w.jsx("div", { className: "mb-8", children: "Today, We are proud to say that our BOT has become a powerful tool in the fight against crypto scams. It will help countless investors avoid fraudulent activities and make informed decisions about their investments. We believe we can create a safer and more transparent market, where everyone can participate with confidence and trust. Our team's dedication and hard work have paid off, and we are hoping to make a real difference in the cryptocurrency market. And we are here to stay! The fight against scammers is ongoing, and much work still needs to be done. But this is one positive step in the fight against them." })] }) })] }) }) }) }); function AA(t) { return xn({ tag: "svg", attr: { fill: "currentColor", viewBox: "0 0 16 16" }, child: [{ tag: "path", attr: { d: "M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM8.287 5.906c-.778.324-2.334.994-4.666 2.01-.378.15-.577.298-.595.442-.03.243.275.339.69.47l.175.055c.408.133.958.288 1.243.294.26.006.549-.1.868-.32 2.179-1.471 3.304-2.214 3.374-2.23.05-.012.12-.026.166.016.047.041.042.12.037.141-.03.129-1.227 1.241-1.846 1.817-.193.18-.33.307-.358.336a8.154 8.154 0 0 1-.188.186c-.38.366-.664.64.015 1.088.327.216.589.393.85.571.284.194.568.387.936.629.093.06.183.125.27.187.331.236.63.448.997.414.214-.02.435-.22.547-.82.265-1.417.786-4.486.906-5.751a1.426 1.426 0 0 0-.013-.315.337.337 0 0 0-.114-.217.526.526 0 0 0-.31-.093c-.3.005-.763.166-2.984 1.09z" } }] })(t) } const NA = [{ id: 1, name: "Don", image: "/don.jpg", title: "CEO & Project Manager", telegram: "https://t.me/DON_the_only" }, { id: 2, name: "Dan", image: "/dan.jpg", title: "CMO & Strategic Advisor", telegram: "https://t.me/dantek5" }, { id: 3, name: "Muhammad", image: "/b1q.jpg", title: "CTO & Senior Developer", telegram: "https://t.me/hosnybtw" }], FA = ({ image: t, name: e, title: n, telegram: i }) => { const r = M.useRef(null), s = eo(r), o = oc(); return M.useEffect(() => { s ? o.start({ pathLength: [0, 1] }) : o.start({ pathLength: 0 }) }, [s]), w.jsx("div", { ref: r, className: "xl:w-1/5 sm:w-3/4 md:w-2/5 relative mt-16 mb-32 sm:mb-24 xl:max-w-sm lg:w-2/5", children: w.jsxs("div", { className: "rounded-lg overflow-hidden shadow-md  shadow-primary  bg-primary", children: [w.jsxs("div", { className: "absolute -mt-20 w-full flex justify-center", children: [w.jsx(U.svg, { className: "z-50 h-[calc(100%+2rem)] w-full absolute -bottom-4 left-0", viewBox: "0 0 110 110", children: w.jsx(U.circle, { className: "z-50", cx: "55", cy: "55", r: "45", fill: "transparent", initial: { pathLength: 0 }, animate: o, transition: { ease: "easeOut", duration: .7 }, stroke: "#435ebe", strokeWidth: 3 }) }), w.jsx("div", { className: "h-32 w-32 ", children: w.jsx("img", { src: t, className: "rounded-full object-cover h-full w-full shadow-md " }) })] }), w.jsxs("div", { className: "px-6 mt-16 h-48 flex justify-around flex-wrap", children: [w.jsx("div", { className: "text-accent font-bold text-3xl text-center pb-1 w-full", children: e }), w.jsx(U.p, { transition: { ease: "linear", duration: .7, delay: .7 }, initial: { opacity: 0, y: 10 }, whileInView: { opacity: [0, 1], y: [10, 0] }, className: "text-secondary text-sm text-center  w-full", children: n }), w.jsx("div", { className: "w-full flex justify-center pt-5 pb-5", children: w.jsx(U.a, { transition: { ease: "linear", duration: .7 }, initial: { scale: .5, opacity: .3 }, whileInView: { scale: [.5, 1], opacity: [.3, 1] }, href: i, className: "mx-5", children: w.jsx(AA, { className: "h-8 w-8 text-accent" }) }) })] })] }) }) }, IA = () => w.jsx("section", { id: "team", className: "bg-accent relative flex justify-center flex-wrap", children: w.jsxs("div", { className: "screen-optz w-full px-10 pt-20", children: [w.jsxs("div", { className: "container", children: [w.jsx(U.p, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0, x: -50 }, whileInView: { x: 0, opacity: [.5, .7, 1] }, className: "w-full -mb-2 text-base font-semibold leading-7 text-secondary", children: "The Hard Working Members " }), w.jsx(U.h1, { transition: { ease: "linear", duration: .5 }, initial: { opacity: 0, x: -50 }, whileInView: { x: 0, opacity: [.5, .7, 1] }, className: "w-full text-4xl lg:text-6xl font-extrabold tracking-wide text-primary sm:text-4xl mb-8 ", children: "TTF Team" }), w.jsx("h1", { className: "text-lg text-black max-w-4xl pb-6 sm:w-4/6 w-5/6", children: "We are an international team of 3 from Canada, Egypt, and Australia, with a diversified skill set from development, marketing, and business management. We share a common vision about safer trading, and have come together to help traders with their due diligence and help founders to provide transparency." })] }), w.jsx("div", { className: "container mx-auto my-16", children: w.jsx("div", { className: "flex flex-wrap  justify-around", children: NA.map(t => w.jsx(FA, { ...t }, t.id)) }) })] }) }); function VA() { const [t, e] = M.useState(!0); return M.useEffect(() => { typeof window < "u" && window.document && (document.body.style.overflow = "hidden") }, []), w.jsxs("main", { children: [t && w.jsx(yO, { loading: t, setLoading: e }), w.jsx(ZM, {}), w.jsx(vO, {}), w.jsx(_O, {}), w.jsx(SO, {}), w.jsx(TA, {}), w.jsx(CA, {}), w.jsx(MA, {}), w.jsx(LA, {}), w.jsx(IA, {}), w.jsx(jA, {}), w.jsx(rT, {})] }) } function zA() { const t = $1(); return console.error(t), w.jsxs("div", { className: "h-screen w-screen flex justify-center items-center flex-col ", id: "error-page", children: [w.jsx("h1", { className: "text-4xl font-bold mb-4", children: "Oops!" }), w.jsx("p", { className: "my-4", children: "Sorry, an unexpected error has occurred." }), w.jsx("p", { className: "mt-4", children: w.jsx("i", { children: t.statusText || t.message }) })] }) } const BA = UP([{ path: "/", element: w.jsx(VA, {}), errorElement: w.jsx(zA, {}) }]); gd.createRoot(document.getElementById("root")).render(w.jsx(Et.StrictMode, { children: w.jsx(zP, { router: BA }) }));